1. Una Architettura RISC è caratterizzata da:
A. Istruzioni in Linguaggio Macchina più semplici ed un Hardware meno complesso
B. Istruzioni complesse progettate per ridurre il numero di istruzioni del programma
C. Un elevato numero di modalità di indirizzamento per istruzione
D. Un’architettura progettata per eseguire direttamente linguaggi ad alto livello

2. Una istruzione in Linguaggio Macchina del MIPS è rappresentata da:
A. Una sequenza di 32 cifre binarie
B. Una sequenza di 16 cifre binarie per le istruzioni aritmetiche
C. Una sequenza di lunghezza variabile in base al formato
D. Una sequenza di 64 cifre binarie per supportare indirizzi estesi

3. L’Assembler è:
A. Un programma che traduce un programma scritto in Assembly in un programma scritto in Linguaggio Macchina
B. Un interprete che esegue istruzioni Assembly una alla volta
C. Un compilatore che traduce linguaggi ad alto livello in Assembly
D. Un programma che collega moduli oggetto risolvendo riferimenti esterni

4. Per accedere al contenuto di un particolare registro è necessario conoscere:
A. L’indirizzo di tale registro
B. Il valore contenuto nel registro Program Counter
C. L’indirizzo di memoria associato al registro
D. Il nome simbolico assegnato dal compilatore

5. Nel Linguaggio Assembly del MIPS il simbolo $ seguito da caratteri alfanumerici rappresenta:
A. Il contenuto di un registro del processore
B. L’indirizzo fisico del registro nella memoria
C. Una costante immediata utilizzata dall’ALU
D. Un’etichetta associata a una istruzione

6. In un registro del Processore MIPS si può memorizzare:
A. Una sequenza di 32 cifre binarie
B. Un numero reale in virgola mobile IEEE 754
C. Un’istruzione in Linguaggio Macchina
D. Un indirizzo di memoria a 64 bit

7. Un programma scritto in un Linguaggio ad Alto Livello ed uno scritto in Assembly possono essere eseguiti:
A. Il primo su un qualunque computer, il secondo solo su un computer con Architettura corrispondente all’Assembly
B. Entrambi su qualunque computer purché dotato di sistema operativo
C. Solo dopo interpretazione dinamica delle istruzioni
D. Solo su computer che supportano la JVM

8. Una istruzione Assembly corrisponde sempre a:
A. Una sola istruzione in Linguaggio Macchina
B. Più istruzioni in Linguaggio Macchina a seconda del contesto
C. Una macro espansa dal processore a tempo di esecuzione
D. Una sequenza di micro-operazioni visibili al programmatore

9. I registri del Processore MIPS con indirizzi da $t0 a $t9 e da $s0 a $s7 sono utilizzati per:
A. Memorizzare sequenze di 32 bit che rappresentano il valore degli operandi delle istruzioni
B. Contenere esclusivamente indirizzi di memoria
C. Gestire il contenuto del Program Counter
D. Memorizzare istruzioni di controllo del flusso

10. Gli indirizzi dei registri del Processore MIPS sono:
A. I 32 numeri da 0 a 31
B. I 32 numeri rappresentati in esadecimale
C. I 64 numeri da 0 a 63
D. Sequenze di 32 bit memorizzate nella memoria principale

11. La Sintassi di un Linguaggio Formale stabilisce:
A. Le regole per scrivere ogni istruzione del Linguaggio Formale in modo corretto
B. Il significato semantico delle istruzioni
C. L’ordine di esecuzione delle istruzioni
D. Le ottimizzazioni applicate dal compilatore

12. La traduzione dal Linguaggio C in Assembly MIPS dell’istruzione max = 200; con max → $s5 è:
A. addi $s5, $zero, 200
B. add $s5, $s5, 200
C. ori $s5, $zero, 200
D. li $s5, 200

13. La traduzione dal Linguaggio C in Assembly MIPS dell’istruzione a = a * 2; con a → $s0 è:
A. add $s0, $s0, $s0
B. mul $s0, $s0, 2
C. sll $s0, $s0, 1
D. addi $s0, $s0, 2

14. La traduzione dal Linguaggio C in Assembly MIPS dell’istruzione h = b + c; con b → $s5, c → $s2, h → $t0 è:
A. add $t0, $s5, $s2
B. addi $t0, $s5, $s2
C. add $s5, $t0, $s2
D. addu $s2, $s5, $t0

15. Il registro destinazione nell’istruzione add $s2, $t0, $t1 è:
A. $s2
B. $t0
C. $t1
D. $zero

16. Il Codice Operativo di una istruzione aritmetica dell’Assembly stabilisce:
A. L’operazione aritmetica da eseguire e come reperire gli operandi
B. Il valore degli operandi da utilizzare
C. Il registro destinazione del risultato
D. Il numero di cicli di clock necessari

17. Nell’istruzione addi dell’Assembly MIPS l’operando costante è contenuto:
A. Nell’istruzione
B. In un registro dedicato
C. In una locazione di memoria
D. Nel campo funct

18. La traduzione dal Linguaggio C in Assembly MIPS dell’istruzione n = 0; con n → $s3 è:
A. addi $s3, $zero, 0
B. add $s3, $s3, 0
C. ori $s3, $s3, 0
D. li $s3, 0

19. La traduzione dal Linguaggio C in Assembly MIPS dell’istruzione val = i - k; con val → $s1, i → $s3, k → $s2 è:
A. sub $s1, $s3, $s2
B. add $s1, $s3, $s2
C. subi $s1, $s3, $s2
D. addi $s1, $s3, -$s2

20. La traduzione dal Linguaggio C in Assembly MIPS dell’istruzione m = m + k; con k → $s3, m → $s0 è:
A. add $s0, $s0, $s3
B. addi $s0, $s3, $s0
C. add $s3, $s0, $s0
D. addu $s0, $s3, $s3

21. Il numero di sequenze binarie diverse di lunghezza K è:
A. Il numero 2^K
B. Il numero K²
C. Il numero 2·K
D. Il numero K!

22. In Notazione posizionale pesata il massimo valore rappresentabile con una sequenza binaria di lunghezza M è:
A. Il valore 2^M − 1
B. Il valore 2^M
C. Il valore 2^(M−1)
D. Il valore 2^(M+1) − 1

23. La scelta dell’alfabeto binario consente di:
A. Minimizzare l’errore dovuto ad oscillazioni del valore dei segnali elettrici
B. Aumentare la velocità di esecuzione delle istruzioni
C. Ridurre il numero di bit necessari per rappresentare i dati
D. Eliminare completamente gli errori di rappresentazione

24. In Notazione posizionale pesata la cifra più significativa di una sequenza è:
A. La cifra che occupa la posizione più a sinistra
B. La cifra che ha valore numerico maggiore
C. La cifra che occupa la posizione più a destra
D. La cifra associata al peso unitario

25. In Notazione posizionale pesata una sequenza binaria con cifra meno significativa uguale a 0 rappresenta:
A. Un numero pari
B. Un numero dispari
C. Un numero negativo
D. Un numero nullo

26. In Notazione posizionale pesata la cifra più significativa di una sequenza di lunghezza K è associata al peso:
A. 2^(K−1)
B. 2^K
C. 2^(K+1)
D. 2^(K−2)

27. In Notazione posizionale pesata il massimo valore che si può rappresentare nel contenuto di un registro del processore è:
A. Il valore 2^32 − 1
B. Il valore 2^31 − 1
C. Il valore 2^32
D. Il valore 2^31

28. Per specificare l’indirizzo di un registro del processore MIPS occorre:
A. Una sequenza di 5 bit
B. Una sequenza di 6 bit
C. Una sequenza di 32 bit
D. Una sequenza di 16 bit

29. Il risultato di un calcolo determina un overflow quando:
A. Per rappresentare il risultato è necessario un numero di bit maggiore della lunghezza dei registri del processore
B. Il risultato è uguale a zero
C. Il risultato è negativo
D. Il risultato non è rappresentabile in virgola mobile

30. In Notazione posizionale pesata la sequenza binaria 11011 rappresenta il valore:
A. 27 in base 10
B. 25 in base 10
C. 26 in base 10
D. 31 in base 10

31. In Notazione posizionale pesata, l’addizione di due interi positivi si effettua:
A. Ponendo a 0 il riporto sulla cifra meno significativa e sommando i bit degli operandi e del riporto da destra verso sinistra
B. Sommando prima le cifre più significative
C. Convertendo i numeri in complemento a 2
D. Sommando separatamente parte intera e parte frazionaria

32. Nella notazione in modulo e segno, il segno del risultato dell’addizione è:
A. Quello del numero con modulo maggiore
B. Sempre positivo
C. Sempre negativo
D. Determinato dal primo operando

33. Nella Notazione in complemento a 2, il peso del bit più a sinistra in una sequenza di lunghezza K è:
A. −2^(K−1)
B. 2^(K−1)
C. −2^K
D. 2^K

34. Nella Notazione in complemento a 2, il segno del numero è determinato da:
A. Il bit più a sinistra con peso negativo
B. Il bit meno significativo
C. Il valore assoluto del numero
D. Il numero totale di bit a 1

35. Nella Notazione in complemento a 2, la somma di due interi con segni opposti viene eseguita:
A. Addizionando i due numeri
B. Sottraendo sempre il numero negativo
C. Convertendo entrambi in modulo e segno
D. Ignorando il bit di segno

36. Nella Notazione in complemento a 2, il massimo numero rappresentabile con sequenze di lunghezza M è:
A. 2^(M−1) − 1
B. 2^M − 1
C. 2^(M−1)
D. 2^M

37. Nella Notazione in complemento a 2, il minimo numero rappresentabile con sequenze di lunghezza M è:
A. −2^(M−1)
B. −(2^(M−1) − 1)
C. −2^M
D. −(2^M − 1)

38. Nella Notazione in complemento a 2, la sequenza binaria 0101 rappresenta:
A. Il valore +5
B. Il valore −5
C. Il valore +4
D. Il valore −3

39. Nella Notazione in complemento a 2, la sequenza binaria 1001 rappresenta:
A. Il valore −7
B. Il valore +9
C. Il valore −9
D. Il valore +7

40. Nella Notazione in complemento a 2, la sequenza binaria 1111 rappresenta:
A. Il valore −1
B. Il valore +15
C. Il valore −15
D. Il valore 0

41. In Notazione in complemento a 2, la rappresentazione dell’opposto del valore rappresentato da una sequenza di N bit si ottiene:
A. Complementando la sequenza bit a bit ed aggiungendo il valore 1
B. Invertendo solo il bit più significativo
C. Complementando la sequenza bit a bit senza ulteriori operazioni
D. Sottraendo il valore 1 e poi invertendo i bit

42. In Notazione in complemento a 2, la sottrazione di due operandi si esegue:
A. Addizionando al primo operando il secondo complementato bit a bit e sommato con il valore 1
B. Sottraendo direttamente i valori binari senza conversioni
C. Convertendo entrambi gli operandi in modulo e segno
D. Ignorando il bit di segno del sottraendo

43. La dichiarazione di tipo intero per una variabile in un Linguaggio ad Alto Livello indica al Compilatore che:
A. Per la variabile si deve utilizzare la Notazione in complemento a 2
B. La variabile deve essere memorizzata in virgola mobile
C. La variabile è sempre non negativa
D. La variabile occupa sempre 16 bit

44. L’overflow può verificarsi:
A. Addizionando numeri con lo stesso segno
B. Addizionando numeri con segno opposto
C. Solo durante le sottrazioni
D. Solo nelle operazioni in virgola mobile

45. In Notazione in complemento a 2, l’overflow viene segnalato quando gli ultimi due riporti cN e cN−1:
A. Sono diversi
B. Sono entrambi uguali a 0
C. Sono entrambi uguali a 1
D. Non vengono generati

46. In Notazione in complemento a 2, l’estensione del segno:
A. Aumenta la lunghezza di una sequenza senza modificarne il valore rappresentato
B. Modifica il valore rappresentato aumentando la precisione
C. Riduce la lunghezza della sequenza mantenendo il valore
D. Serve a eliminare il bit di segno

47. L’estensione del segno di una sequenza con bit più significativo uguale a 1 si effettua:
A. Ponendo a sinistra di tale bit tutte cifre uguali a 1
B. Ponendo a sinistra di tale bit tutte cifre uguali a 0
C. Invertendo tutti i bit della sequenza
D. Aggiungendo uno 0 come nuovo bit più significativo

48. Eseguendo un’addizione in Notazione in complemento a 2, se cN ha valore 0 e cN−1 ha valore 1:
A. Il risultato è sbagliato
B. Il risultato è corretto
C. Si verifica sempre underflow
D. Il risultato è zero

49. Eseguendo un’addizione in Notazione in complemento a 2, se cN ha valore 1 e cN−1 ha valore 1:
A. Il risultato è corretto
B. Il risultato è sbagliato
C. Si verifica overflow
D. Il risultato è negativo

50. Eseguendo un’addizione in Notazione in complemento a 2, i riporti cN e cN−1 che segnalano l’overflow nell’Architettura MIPS sono:
A. I riporti con indici c32 e c31
B. I riporti con indici c31 e c30
C. I riporti con indici c16 e c15
D. I riporti con indici c33 e c32

51. L’estensione del segno di una sequenza con bit più significativo uguale a 0 si effettua:
A. Ponendo a sinistra di tale bit tutte cifre uguali a 0
B. Ponendo a sinistra di tale bit tutte cifre uguali a 1
C. Complementando l’intera sequenza
D. Aggiungendo il bit di segno negativo

52. Il formato di una istruzione in linguaggio macchina è definito da:
A. Una suddivisione concettuale della sequenza binaria dell’istruzione in sottosequenze di lunghezza e posizione fissata
B. La sequenza delle micro-operazioni eseguite dal processore
C. Il numero di cicli di clock necessari all’esecuzione
D. Il tipo di dati su cui opera l’istruzione

53. La modalità di indirizzamento di una istruzione in linguaggio macchina stabilisce:
A. La regola per determinare gli indirizzi degli operandi usando i campi del formato
B. Il tipo di operazione logica da eseguire
C. Il numero di registri coinvolti
D. Il tempo di accesso alla memoria

54. Nel linguaggio macchina MIPS, i campi del formato di tipo R sono:
A. Sottosequenze di lunghezze 6, 5, 5, 5, 5, 6
B. Sottosequenze di lunghezze 6, 5, 5, 16
C. Sottosequenze di lunghezze 8, 8, 8, 8
D. Sottosequenze di lunghezze variabili

55. Nel linguaggio macchina MIPS, il campo codice operativo di una istruzione stabilisce:
A. L’operazione da eseguire ed il formato dell’istruzione
B. Il valore degli operandi
C. Il registro destinazione
D. L’indirizzo di memoria di accesso

56. Nel linguaggio macchina MIPS, il campo funct è:
A. Un campo di 6 bit del formato di tipo R che indica l’operazione aritmetico-logica
B. Un campo di 5 bit che identifica il registro destinazione
C. Un campo di 16 bit che contiene un valore immediato
D. Un campo utilizzato solo nelle istruzioni di salto

57. Nel linguaggio macchina MIPS, con l’indirizzamento tramite registro gli indirizzi degli operandi sono contenuti:
A. Nei campi rs e rt del formato di tipo R
B. Nel campo immediato del formato di tipo I
C. Nel campo opcode
D. Nel Program Counter

58. Le lunghezze dei campi dell’istruzione in linguaggio macchina MIPS che traduce add $t0, $s0, $s1 sono:
A. 6, 5, 5, 5, 5, 6
B. 6, 5, 5, 16
C. 8, 8, 8, 8
D. 5, 5, 5, 5, 12

59. Le istruzioni del linguaggio macchina MIPS con codice operativo 0 hanno:
A. Il formato di tipo R
B. Il formato di tipo I
C. Il formato di tipo J
D. Un formato variabile

60. La suddivisione in campi dell’istruzione in linguaggio macchina MIPS 00000010000100010100000000100000 in base al suo formato è data:
A. Dalle sottosequenze 000000, 10000, 10001, 01000, 00000, 100000
B. Dalle sottosequenze 000000, 10000, 01000, 10001, 00000, 100000
C. Dalle sottosequenze 100000, 00000, 01000, 10001, 10000, 000000
D. Dalle sottosequenze 000000, 1000010001, 0100000000100000

61. Nell’istruzione in linguaggio macchina MIPS con valori dei campi del formato
000000, 01000, 01001, 10000, 00000, 100010, l’indirizzo del registro che contiene il risultato è:
A. Il campo 10000
B. Il campo 01000
C. Il campo 01001
D. Il campo 00000

62. L’operatore AND ha valore 1 quando:
A. Gli operandi hanno entrambi valore 1
B. Almeno uno degli operandi ha valore 1
C. Gli operandi hanno entrambi valore 0
D. Gli operandi sono diversi

63. L’operatore OR ha valore 0 quando:
A. Gli operandi hanno entrambi valore 0
B. Gli operandi hanno entrambi valore 1
C. Almeno uno degli operandi ha valore 1
D. Gli operandi sono uguali

64. Per le istruzioni aritmetico-logiche del linguaggio macchina MIPS il campo codice operativo contiene:
A. La sequenza di 6 bit 000000
B. Una sequenza di 5 bit che identifica il registro destinazione
C. Il valore immediato dell’operando
D. Un codice diverso per ogni istruzione

65. Il formato dell’istruzione in linguaggio macchina MIPS
00000010000100010100000000100101 è:
A. Di tipo R
B. Di tipo I
C. Di tipo J
D. Di tipo pseudo-diretto

66. Nel linguaggio macchina MIPS, il campo shamt del formato di tipo R contiene:
A. Il numero di posizioni da scorrere nelle istruzioni di shift
B. Il codice operativo dell’istruzione
C. L’indirizzo del registro sorgente
D. L’offset di memoria

67. Nell’istruzione in linguaggio macchina MIPS con campi del formato
000000, 01000, 01001, 11110, 00000, 100101, gli indirizzi degli operandi sono:
A. I valori binari 01000 e 01001
B. I valori binari 11110 e 00000
C. I valori binari 01001 e 11110
D. I valori binari 00000 e 100101

68. Nel linguaggio macchina MIPS, la modalità di indirizzamento delle istruzioni and ed or è:
A. Tramite registro per entrambe
B. Immediata per entrambe
C. Pseudodiretta per entrambe
D. Relativa al Program Counter

69. La traduzione in Assembly MIPS dell’OR bit a bit con operandi nei registri $s1 e $s2 e risultato nel registro $t0 è:
A. or $t0, $s1, $s2
B. ori $t0, $s1, $s2
C. or $s1, $s2, $t0
D. and $t0, $s1, $s2

70. La traduzione in Assembly MIPS dello shift a sinistra di 4 posizioni con registro operando $s3 e registro destinazione $t0 è:
A. sll $t0, $s3, 4
B. sll $s3, $t0, 4
C. sl $t0, $s3, 4
D. shiftl $t0, $s3, 4

71. La traduzione in Assembly MIPS dell’AND bit a bit con operandi nei registri $s1 e $s2 e risultato nel registro $s5 è:
A. and $s5, $s1, $s2
B. andi $s5, $s1, $s2
C. and $s1, $s2, $s5
D. or $s5, $s1, $s2

72. Nel linguaggio macchina MIPS, i campi del formato di tipo I contengono:
A. Sequenze di lunghezza 6, 5, 5, 16
B. Sequenze di lunghezza 6, 5, 5, 5, 5, 6
C. Sequenze di lunghezza 6 e 26
D. Sequenze di lunghezza variabile

73. Nel linguaggio macchina MIPS, la suddivisione in campi dell’istruzione
00100001000010011000000000100101 con formato di tipo I è data:
A. Dalle sequenze 001000, 01000, 01001, 1000000000100101
B. Dalle sequenze 001000, 01000, 01001, 00100101
C. Dalle sequenze 001000010000, 10011000000000100101
D. Dalle sequenze 001000, 0100001001, 1000000000100101

74. Nel linguaggio macchina MIPS, il formato e la modalità di indirizzamento dell’istruzione addi sono:
A. Formato di tipo I con indirizzamento immediato
B. Formato di tipo R con indirizzamento tramite registro
C. Formato di tipo J con indirizzamento pseudodiretto
D. Formato di tipo I con indirizzamento relativo al PC

75. La traduzione in Assembly MIPS dell’assegnamento val = b - 300 con b → $s1 e val → $t0 è:
A. addi $t0, $s1, -300
B. sub $t0, $s1, 300
C. subi $t0, $s1, 300
D. add $t0, $s1, -300

76. Nel formato di tipo I, i valori del campo immediato sono compresi tra:
A. −2^15 e 2^15 − 1
B. −2^16 e 2^16 − 1
C. −2^31 e 2^31 − 1
D. 0 e 2^16 − 1

77. L’operando immediato dell’istruzione Assembly MIPS
addi $t0, $s1, 30 è rappresentato in linguaggio macchina mediante:
A. Una sequenza di 16 bit in notazione in complemento a 2
B. Una sequenza di 32 bit in notazione posizionale pesata
C. Una sequenza di 5 bit associata al registro
D. Una sequenza di 8 bit in ASCII

78. Prima dell’esecuzione di una istruzione con formato di tipo I il valore del campo immediato viene:
A. Esteso di segno a 32 bit e inviato all’ALU
B. Inviato direttamente all’ALU senza modifiche
C. Convertito in modulo e segno
D. Memorizzato in un registro temporaneo

79. La modalità di indirizzamento immediato è utilizzata con:
A. Solo il formato di tipo I
B. Solo il formato di tipo R
C. Solo il formato di tipo J
D. Tutti i formati

80. Nel linguaggio macchina MIPS, la modalità di indirizzamento immediato fornisce due operandi mediante due campi del formato di tipo I che contengono:
A. Un numero intero in complemento a 2 e l’indirizzo di un registro
B. Due indirizzi di memoria
C. Due valori immediati
D. Un indirizzo di salto e un registro

81. L’esecuzione dell’istruzione Assembly MIPS addi $s7, $t0, -35 ha l’effetto di:
A. Addizionare −35 al contenuto del registro $t0 e scrivere il risultato nel registro $s7
B. Sottrarre 35 dal contenuto del registro $s7 e scrivere il risultato in $t0
C. Sommare −35 al contenuto del Program Counter
D. Scrivere il valore −35 nel registro $t0

82. Gli indirizzi della memoria principale MIPS sono dati da:
A. Sequenze di 32 bit
B. Sequenze di 16 bit
C. Sequenze di 64 bit
D. Valori espressi in base esadecimale

83. Le dimensioni di 1 Kappa, 1 Mega, 1 Giga corrispondono:
A. A valori approssimati pari a mille, un milione e un miliardo
B. Esattamente a 2¹⁰, 2²⁰ e 2³⁰
C. A valori fissati dallo standard IEEE
D. A grandezze dipendenti dal sistema operativo

84. Il numero di locazioni della memoria principale MIPS è dato dal:
A. Valore 2³²
B. Valore 2¹⁶
C. Valore 2⁸
D. Numero di registri del processore

85. Il contenuto di una locazione della memoria principale MIPS è dato da:
A. Una sequenza di 8 bit
B. Una sequenza di 32 bit
C. Una istruzione completa
D. Un valore in complemento a 2

86. In Assembly MIPS, l’operazione di leggere la parola che inizia all’indirizzo calcolato con registro base $t1 e offset 9 e scriverla nel registro $s2 è eseguita da:
A. lw $s2, 9($t1)
B. sw $s2, 9($t1)
C. lw $t1, 9($s2)
D. load $s2, 9($t1)

87. L’istruzione Assembly MIPS lw $t5, 4($s0):
A. Legge una parola di memoria all’indirizzo $s0 + 4 e la scrive in $t5
B. Scrive il contenuto di $t5 in memoria all’indirizzo $s0 + 4
C. Legge un byte di memoria all’indirizzo $s0
D. Legge una parola di memoria all’indirizzo $t5 + 4

88. In Assembly MIPS, l’operazione di scrittura del contenuto del registro $s3 nella parola che inizia all’indirizzo $t0 + 8 è eseguita dalla:
A. sw $s3, 8($t0)
B. lw $s3, 8($t0)
C. store $s3, 8($t0)
D. sw $t0, 8($s3)

89. L’istruzione Assembly MIPS sw $t1, 4($s5):
A. Scrive il contenuto di $t1 nella parola di memoria all’indirizzo $s5 + 4
B. Legge una parola di memoria all’indirizzo $s5 + 4
C. Scrive il contenuto di $s5 nel registro $t1
D. Copia $t1 nel registro $s5

90. Per l’istruzione load word la modalità di indirizzamento tramite base e offset calcola:
A. L’indirizzo di una parola di memoria da cui leggere un dato
B. Il valore dell’offset in byte
C. Il numero di cicli di clock necessari
D. L’indirizzo del registro destinazione

91. Per l’istruzione store word la modalità di indirizzamento tramite base e offset calcola:
A. L’indirizzo di una parola di memoria in cui scrivere un dato
B. Il contenuto del registro sorgente
C. Il valore del Program Counter
D. Il codice operativo dell’istruzione

92. La traduzione in Assembly MIPS dell’assegnamento val = A[3], con val → $t0 e base dell’array in $s1, è:
A. lw $t0, 12($s1)
B. lw $t0, 3($s1)
C. sw $t0, 12($s1)
D. lw $s1, 12($t0)

93. Il valore dell’offset nell’istruzione Assembly MIPS lw $t0, 5($s3) è rappresentato in linguaggio macchina mediante:
A. I 16 bit del campo immediato del formato di tipo I
B. I 5 bit del campo rt
C. I 6 bit del codice operativo
D. I 32 bit del Program Counter

94. Nel linguaggio macchina MIPS, la modalità di indirizzamento dell’istruzione store word calcola:
A. L’indirizzo del primo byte della parola di memoria dove scrivere il dato
B. L’indirizzo dell’ultimo byte della parola
C. L’indirizzo del registro sorgente
D. L’indirizzo dell’istruzione successiva

95. La suddivisione in campi dell’istruzione load word
10001110000010010000000000000111 è data da:
A. 100011, 10000, 01001, 0000000000000111
B. 100011, 10000, 01001, 00000111
C. 100011100000, 10010000000000000111
D. 100011, 01001, 10000, 0000000000000111

96. L’indirizzo del registro base nel formato dell’istruzione store word
101011, 01000, 01111, 0000000000000001 è dato da:
A. 01000
B. 01111
C. 101011
D. 00001

97. Il registro base di un array contiene:
A. L’indirizzo del primo byte dell’elemento A[0]
B. Il numero di elementi dell’array
C. L’indirizzo dell’ultimo elemento dell’array
D. Il valore dell’indice corrente

98. L’errore “Array out of bounds” avviene quando:
A. Si utilizza un indice che accede a memoria fuori dallo spazio dell’array
B. L’array contiene più di 32 elementi
C. L’array non è inizializzato
D. L’array contiene valori negativi

99. La traduzione in Assembly MIPS dell’assegnamento A[5] = val, con val → $s2 e base dell’array in $t3, è:
A. sw $s2, 20($t3)
B. lw $s2, 20($t3)
C. sw $t3, 20($s2)
D. sw $s2, 5($t3)

100. L’indirizzo di memoria dell’elemento B[9] di un array di numeri interi è:
A. L’indirizzo base dell’array sommato all’offset 36
B. L’indirizzo base dell’array sommato all’offset 9
C. L’indirizzo base dell’array sommato all’offset 18
D. L’indirizzo dell’elemento precedente B[8]

101. La traduzione in Assembly MIPS dell’assegnamento val = A[0], con val → $t0 e base dell’array in $s1, è:
A. lw $t0, 0($s1)
B. lw $t0, 4($s1)
C. sw $t0, 0($s1)
D. lw $s1, 0($t0)

102. L’esecuzione dell’istruzione Assembly MIPS beq $t1, $t2, NOME determina:
A. Un salto all’istruzione etichettata NOME se $t1 e $t2 contengono valori uguali
B. Un salto incondizionato all’istruzione NOME
C. Un salto se $t1 e $t2 contengono valori diversi
D. Un salto all’istruzione successiva a NOME

103. Nel linguaggio Assembly MIPS il salto all’istruzione NEW se i registri $s0 e $s1 contengono valori diversi è eseguito da:
A. bne $s0, $s1, NEW
B. beq $s0, $s1, NEW
C. j NEW
D. jr NEW

104. Nel linguaggio macchina MIPS l’istruzione beq ha:
A. Formato di tipo I e indirizzamento relativo al Program Counter
B. Formato di tipo R e indirizzamento tramite registro
C. Formato di tipo J e indirizzamento pseudodiretto
D. Formato di tipo I e indirizzamento immediato

105. Il campo immediato del formato di tipo I dell’istruzione MIPS che traduce bne $t3, $t5, NOME contiene:
A. Il numero di istruzioni da saltare in complemento a 2
B. L’indirizzo assoluto dell’etichetta NOME
C. L’indirizzo del registro $t5
D. Il valore del Program Counter

106. I campi del formato dell’istruzione MIPS
00010010000010000000000000000111 che traduce beq $s0, $t0, ETICHETTA sono:
A. 000100, 10000, 01000, 0000000000000111
B. 000100, 01000, 10000, 0000000000000111
C. 000100100000, 10000000000000111
D. 10000, 01000, 000100, 0000000000000111

107. Nella modalità di indirizzamento relativo al Program Counter il contenuto del campo immediato è esteso di segno a 32 bit perché:
A. Deve essere sommato al Program Counter dall’ALU che opera su 32 bit
B. Deve essere confrontato con il contenuto di un registro
C. Rappresenta sempre un valore negativo
D. È memorizzato in memoria principale

108. Nella traduzione in linguaggio macchina MIPS dell’istruzione beq $s2, $s3, ETICHETTA gli indirizzi dei registri sono posti:
A. Nei campi di 5 bit del formato di tipo I nello stesso ordine dell’Assembly
B. Nel campo immediato dell’istruzione
C. Nel Program Counter
D. Nel campo funct

109. La modalità di indirizzamento relativo al Program Counter è associata:
A. Alle istruzioni beq e bne
B. Alle istruzioni j e jal
C. Alle istruzioni aritmetiche di tipo R
D. Alle istruzioni di caricamento lw

110. La modalità di indirizzamento relativo al Program Counter calcola l’indirizzo:
A. Sommando al Program Counter il campo immediato esteso di segno e moltiplicato per 4
B. Sommando al Program Counter il valore del registro sorgente
C. Utilizzando direttamente il campo immediato come indirizzo
D. Sommando il Program Counter al campo opcode

111. Nella modalità di indirizzamento relativo al Program Counter il campo immediato è moltiplicato per 4 perché:
A. Ogni istruzione occupa 4 byte di memoria
B. Gli indirizzi di memoria sono espressi in bit
C. Il Program Counter avanza di 4 istruzioni alla volta
D. Il campo immediato è espresso in byte

112. Nel linguaggio Assembly MIPS l’istruzione j NOME esegue:
A. Un salto incondizionato all’istruzione etichettata NOME
B. Un salto condizionato se il risultato è zero
C. Un ritorno da procedura
D. Un salto relativo al Program Counter

113. L’istruzione Assembly MIPS di salto incondizionato ha:
A. La forma sintattica j ETICHETTA
B. La forma sintattica beq ETICHETTA
C. La forma sintattica jr ETICHETTA
D. La forma sintattica jalr ETICHETTA

114. L’istruzione del linguaggio macchina MIPS che traduce j NOME ha:
A. Formato di tipo J e indirizzamento pseudodiretto
B. Formato di tipo I e indirizzamento relativo
C. Formato di tipo R e indirizzamento tramite registro
D. Formato di tipo J e indirizzamento immediato

115. I campi del formato dell’istruzione MIPS
00001011111000000000011111000011 che traduce j NOME sono:
A. 000010, 11111000000000011111000011
B. 000010, 1111100000000001, 1111000011
C. 000010111110, 0000000011111000011
D. 111110, 0000100000000011111000011

116. Il campo di 26 bit del formato di tipo J del linguaggio macchina MIPS contiene:
A. Una parte dell’indirizzo di salto incondizionato
B. L’indirizzo completo della istruzione di salto
C. Il numero di istruzioni da saltare
D. Il valore del Program Counter

117. I campi del formato J dell’istruzione MIPS che traduce j NOME contengono:
A. Sottosequenze binarie di lunghezze 6 e 26
B. Sottosequenze binarie di lunghezze 5 e 27
C. Sottosequenze binarie di lunghezze 8 e 24
D. Sottosequenze binarie di lunghezze variabili

118. Nel linguaggio macchina MIPS l’indirizzamento pseudodiretto è associato:
A. All’istruzione j ed al formato di tipo J
B. All’istruzione beq ed al formato di tipo I
C. All’istruzione jr ed al formato di tipo R
D. All’istruzione lw ed al formato di tipo I

119. Nel linguaggio macchina MIPS l’indirizzamento pseudodiretto calcola:
A. L’indirizzo dell’istruzione a cui saltare
B. L’indirizzo della istruzione successiva
C. L’indirizzo di memoria dell’operando
D. Il contenuto del Program Counter

120. L’indirizzamento pseudodiretto completa i 26 bit del formato di tipo J mediante:
A. L’aggiunta di due bit 00 a destra e dei 4 bit più significativi del Program Counter a sinistra
B. L’estensione di segno del campo a 32 bit
C. L’aggiunta di 4 bit 00 a destra
D. La sostituzione dei bit meno significativi del Program Counter

121. L’indirizzamento pseudodiretto richiede che:
A. Tutte le istruzioni del programma siano in locazioni con gli stessi 4 bit più significativi dell’indirizzo
B. Il Program Counter sia sempre multiplo di 8
C. Le istruzioni siano memorizzate in registri
D. Il campo immediato sia esteso di segno

122. L’istruzione if-else del linguaggio ad alto livello, nel linguaggio Assembly:
A. Non ha una corrispondente istruzione ed è tradotta combinando salti condizionati e incondizionati
B. È tradotta direttamente dall’istruzione beq
C. È tradotta dall’istruzione j
D. È tradotta da una singola istruzione di tipo R

123. In linguaggio Assembly la ripetizione di un insieme di istruzioni per un numero fissato di volte può essere ottenuta:
A. Mediante combinazioni di istruzioni di salto condizionato e incondizionato
B. Mediante una singola istruzione di loop
C. Utilizzando esclusivamente istruzioni aritmetiche
D. Mediante istruzioni di tipo J

124. L’istruzione for nel linguaggio Assembly:
A. Non ha una corrispondente istruzione ed è tradotta combinando salti
B. È tradotta dall’istruzione loop
C. È implementata con una sola istruzione beq
D. È una pseudoistruzione hardware

125. La traduzione della inizializzazione del ciclo for in linguaggio Assembly è posta:
A. Prima dell’insieme di istruzioni che viene ciclicamente ripetuto
B. Alla fine del corpo del ciclo
C. All’interno della condizione di salto
D. Dopo l’istruzione di salto incondizionato

126. L’istruzione while nel linguaggio Assembly:
A. Non ha una corrispondente istruzione ed è tradotta combinando salti
B. È tradotta da una singola istruzione bne
C. È una istruzione nativa del processore
D. È sempre tradotta con istruzioni di tipo J

127. La traduzione in Assembly di un ciclo while determina un ciclo infinito quando:
A. Il ciclo while nel linguaggio ad alto livello è infinito
B. L’indice del ciclo è negativo
C. Il corpo del ciclo contiene un salto
D. Il Program Counter non viene aggiornato

128. Nel linguaggio macchina per passare all’esecuzione di una procedura è necessario:
A. Porre l’indirizzo della procedura nel Program Counter e salvare l’indirizzo di ritorno
B. Copiare la procedura in memoria principale
C. Caricare i parametri nella memoria di massa
D. Azzerare il Program Counter

129. Nel linguaggio macchina l’indirizzo di ritorno dalla chiamata di una procedura è:
A. L’indirizzo dell’istruzione successiva alla jal nel programma chiamante
B. L’indirizzo della prima istruzione della procedura
C. L’indirizzo dell’ultima istruzione della procedura
D. Il valore del Program Counter iniziale

130. Nel linguaggio macchina MIPS i valori dei parametri sono passati alla procedura chiamata:
A. Scrivendoli nei registri $a0–$a3 prima della chiamata
B. Scrivendoli nello stack dopo la chiamata
C. Scrivendoli nei registri $v0–$v1
D. Scrivendoli nel Program Counter

131. Nel linguaggio macchina MIPS i valori calcolati dalla procedura chiamata sono passati al chiamante:
A. Scrivendoli nei registri $v0 e $v1
B. Scrivendoli nei registri $a0 e $a1
C. Scrivendoli nello stack automaticamente
D. Scrivendoli nel Program Counter

132. Nel linguaggio macchina MIPS l’indirizzo di ritorno al programma chiamante è salvato:
A. Nel registro $ra durante l’esecuzione di jal
B. Nel registro $sp
C. Nel Program Counter
D. Nel registro $v0

133. Nel linguaggio macchina MIPS il ritorno all’esecuzione del programma chiamante è effettuato:
A. Mediante l’istruzione jr
B. Mediante l’istruzione j
C. Mediante l’istruzione jal
D. Mediante l’istruzione beq

134. Le chiamate di procedura annidate sono gestite:
A. Utilizzando una struttura dati di tipo stack
B. Utilizzando una coda FIFO
C. Utilizzando un registro dedicato
D. Utilizzando la memoria cache

135. L’errore di call stack overflow avviene quando:
A. Si esaurisce lo spazio di memoria assegnato allo stack
B. Una procedura non restituisce valori
C. Il Program Counter non viene aggiornato
D. Si verifica un errore di overflow aritmetico

136. Nel linguaggio macchina MIPS il formato e la modalità di indirizzamento dell’istruzione jal sono:
A. Formato di tipo J e indirizzamento pseudodiretto
B. Formato di tipo I e indirizzamento immediato
C. Formato di tipo R e indirizzamento tramite registro
D. Formato di tipo J e indirizzamento relativo al PC

137. Nel linguaggio macchina MIPS il formato e la modalità di indirizzamento dell’istruzione jr sono:
A. Formato di tipo R e indirizzamento tramite registro
B. Formato di tipo J e indirizzamento pseudodiretto
C. Formato di tipo I e indirizzamento immediato
D. Formato di tipo R e indirizzamento immediato

138. L’esecuzione dell’istruzione Assembly MIPS slt $t0, $s1, $s2:
A. Pone 1 in $t0 se $s1 < $s2, altrimenti 0
B. Pone 1 in $s1 se $t0 < $s2
C. Confronta $t0 e $s1
D. Sottrae $s2 da $s1

139. La traduzione in linguaggio macchina MIPS dell’istruzione slt $s1, $t3, $t4 ha:
A. Formato di tipo R e indirizzamento tramite registro
B. Formato di tipo I e indirizzamento immediato
C. Formato di tipo J e indirizzamento pseudodiretto
D. Formato di tipo R e indirizzamento relativo al PC

140. Il tipo di dato unsigned è rappresentato da:
A. Sequenze binarie in notazione posizionale pesata
B. Sequenze binarie in complemento a 2
C. Sequenze binarie in modulo e segno
D. Sequenze binarie in virgola mobile

141. Nella rappresentazione con 32 bit del tipo di dato unsigned il bit più a sinistra è:
A. Associato al peso positivo 2³¹
B. Associato al peso negativo −2³¹
C. Il bit di segno
D. Sempre uguale a 0

142. I valori unsigned rappresentati da sequenze di 32 bit sono compresi:
A. Nell’intervallo [0, 2³² − 1]
B. Nell’intervallo [−2³¹, 2³¹ − 1]
C. Nell’intervallo [0, 2³¹ − 1]
D. Nell’intervallo [−2³², 2³² − 1]

143. La regola che segnala l’overflow per la somma di interi con segno in complemento a 2:
A. Non si applica per gli interi unsigned
B. Si applica anche agli interi unsigned
C. Vale solo per numeri negativi
D. Dipende dal valore del Program Counter

144. Le istruzioni Assembly MIPS con codici operativi addu e subu eseguono:
A. Addizione e sottrazione di operandi unsigned
B. Addizione e sottrazione con segno
C. Operazioni aritmetiche in virgola mobile
D. Operazioni logiche bit a bit

145. Per le istruzioni logiche and e or, il linguaggio Assembly:
A. Non distingue tra operandi signed e unsigned
B. Prevede versioni diverse per signed e unsigned
C. Richiede l’estensione del segno
D. Utilizza il complemento a 2

146. L’esecuzione dell’istruzione Assembly MIPS sltu $t0, $s1, $s2:
A. Pone 1 in $t0 se $s1 < $s2 in notazione senza segno
B. Pone 1 in $t0 se $s1 < $s2 in complemento a 2
C. Sottrae $s2 da $s1
D. Confronta i bit di segno dei registri

147. L’esecuzione dell’istruzione Assembly MIPS slti $s1, $t2, 35:
A. Pone 1 in $s1 se $t2 < 35, altrimenti 0
B. Pone 1 in $t2 se $s1 < 35
C. Confronta due registri
D. Esegue una sottrazione immediata

148. L’istruzione in linguaggio macchina MIPS che traduce set on less than immediate ha:
A. Formato di tipo I e indirizzamento immediato
B. Formato di tipo R e indirizzamento tramite registro
C. Formato di tipo J e indirizzamento pseudodiretto
D. Formato di tipo I e indirizzamento relativo al PC

149. Il valore della costante nell’istruzione Assembly MIPS slti $s1, $t2, -50 viene scritto:
A. In complemento a 2 nei 16 bit del campo immediato
B. In notazione posizionale pesata nei 32 bit
C. In modulo e segno nei registri
D. Nel campo funct

150. L’operando costante dell’istruzione slti $s0, $t1, -70 si ottiene:
A. Estendendo di segno a 32 bit il campo immediato
B. Estendendo con zeri il campo immediato
C. Sommando il campo immediato al Program Counter
D. Leggendolo da memoria

151. L’operando costante dell’istruzione set on less than immediate ha valore compreso:
A. Tra −2¹⁵ e 2¹⁵ − 1
B. Tra −2³¹ e 2³¹ − 1
C. Tra 0 e 2¹⁶ − 1
D. Tra −2¹⁶ e 2¹⁶ − 1

152. L’operando costante dell’istruzione ori $s0, $t2, 25 si ottiene:
A. Completando a 32 bit il campo immediato con zeri
B. Estendendo di segno il campo immediato
C. Convertendo il valore in complemento a 2
D. Sommando il valore al Program Counter

153. Le istruzioni in linguaggio macchina MIPS che traducono andi e ori:
A. Hanno formato di tipo I e indirizzamento immediato
B. Hanno formato di tipo R e indirizzamento tramite registro
C. Hanno formato di tipo J
D. Usano indirizzamento pseudodiretto

154. L’istruzione Assembly MIPS ori $s0, $t3, 9:
A. Esegue l’OR bit a bit tra $t3 e 9 esteso con zeri
B. Esegue l’OR bit a bit tra $t3 e 9 esteso di segno
C. Esegue l’AND bit a bit
D. Somma 9 al contenuto di $t3

155. Un valore che richiede più di 16 bit significativi:
A. Non può essere operando immediato di una istruzione MIPS di tipo I
B. Può sempre essere operando immediato
C. È memorizzato nel campo funct
D. È automaticamente caricato da memoria

156. I caratteri rappresentati nella codifica ASCII sono:
A. 128, di cui 95 stampabili e 33 non stampabili
B. 256, tutti stampabili
C. 64, tutti stampabili
D. 128, tutti stampabili

157. Il codice ASCII utilizza sequenze binarie:
A. Di lunghezza 7
B. Di lunghezza 8
C. Di lunghezza variabile
D. Di lunghezza 16

158. Il codice ASCII esteso utilizza sequenze binarie:
A. Di lunghezza 8
B. Di lunghezza 7
C. Di lunghezza 16
D. Di lunghezza variabile

159. I codici ASCII sono compresi:
A. Tra 0 e 127
B. Tra −128 e 127
C. Tra 0 e 255
D. Tra 32 e 126

160. Il sistema di codifica Unicode:
A. Include la codifica ASCII come sottinsieme
B. È limitato ai caratteri europei
C. Utilizza solo 8 bit per carattere
D. Non è compatibile con ASCII

161. Il sistema di codifica Unicode UTF-8 utilizza:
A. Sequenze di lunghezza variabile di byte
B. Sequenze fisse di 8 bit
C. Sequenze fisse di 16 bit
D. Sequenze fisse di 32 bit

162. Il sistema di codifica Unicode UTF-16 utilizza sequenze binarie:
A. Di lunghezza 16
B. Di lunghezza 8
C. Di lunghezza variabile
D. Di lunghezza 32

163. L’assegnamento val = 'A' con val → $s1 si traduce in Assembly MIPS:
A. ori $s1, $zero, 65
B. addi $s1, $zero, 'A'
C. lw $s1, 65($zero)
D. add $s1, $zero, $A

164. Il calcolo dell’indirizzo dell’elemento A[k] di un array di numeri interi si effettua:
A. Moltiplicando l’indice k per 4
B. Sommando direttamente k all’indirizzo base
C. Moltiplicando k per 2
D. Sommando k al Program Counter

165. La moltiplicazione per 4 dell’indice k si effettua:
A. Con uno shift logico a sinistra di 2 posizioni
B. Con una moltiplicazione hardware
C. Con uno shift a destra di 2 posizioni
D. Con una addizione ripetuta

166. Il calcolo dell’indirizzo dell’elemento A[k] di un array che implementa una stringa ASCII si effettua:
A. Sommando k al contenuto del registro base
B. Moltiplicando k per 4
C. Moltiplicando k per 2
D. Sommando k × 8 al registro base

167. Il calcolo dell’indirizzo dell’elemento A[k] di un array che implementa una stringa Unicode a 16 bit si effettua:
A. Moltiplicando k per 2 e sommando il risultato al registro base
B. Sommando direttamente k al registro base
C. Moltiplicando k per 4
D. Moltiplicando k per 16

168. Le cifre significative della rappresentazione di un numero sono:
A. Le cifre che contribuiscono al valore del numero
B. Le cifre a destra della virgola
C. Le cifre uguali a 1
D. Le cifre più a sinistra

169. Rappresentando numeri frazionari con sequenze di lunghezza fissata si può:
A. Rappresentare esattamente solo un sottoinsieme finito di numeri
B. Rappresentare esattamente tutti i numeri reali
C. Eliminare l’errore di arrotondamento
D. Evitare underflow e overflow

170. L’errore di underflow si verifica quando:
A. Il numero ha modulo minore del minimo rappresentabile
B. Il numero ha modulo maggiore del massimo rappresentabile
C. Il numero è negativo
D. Il numero è zero

171. Se il minimo modulo rappresentabile è 0,01 e il massimo è 999, l’underflow si verifica quando il valore è:
A. Esterno all’intervallo [−0,01 ; 0,01]
B. Maggiore di 999
C. Uguale a zero
D. Compreso tra 1 e 10

172. La rappresentazione troncata con errore di arrotondamento si ottiene:
A. Sostituendo le cifre meno significative con 0
B. Eliminando la parte intera
C. Complementando le cifre
D. Arrotondando sempre per eccesso

173. L’errore di arrotondamento è:
A. Minore del peso della cifra meno significativa
B. Sempre nullo
C. Sempre uguale a 1
D. Maggiore del valore rappresentato

174. La misura dell’errore di arrotondamento della rappresentazione troncata
79854,84000 del numero 79854,84219 è:
A. 0,00219
B. 0,00019
C. 0,0219
D. 0,219

175. La misura dell’errore di arrotondamento precedente è limitata superiormente da:
A. 10⁻²
B. 10⁻³
C. 10⁻¹
D. 10⁻⁴

176. Il numero 53498,03 rappresentato in virgola fissa è espresso in notazione scientifica come:
A. 5,349803 × 10⁴
B. 53,49803 × 10³
C. 0,5349803 × 10⁵
D. 534,9803 × 10²

177. In notazione polarizzata il valore del numero rappresentato si ottiene:
A. Sottraendo la costante di polarizzazione
B. Sommando la costante di polarizzazione
C. Moltiplicando per la polarizzazione
D. Ignorando l’esponente

178. Nello standard IEEE 754 le cifre significative si ottengono:
A. Considerando il bit sottinteso uguale a 1 e la mantissa come parte frazionaria
B. Considerando solo i bit della mantissa
C. Sommando esponente e mantissa
D. Ignorando il bit sottinteso

179. Nello standard IEEE 754 in singola precisione le 24 cifre binarie significative corrispondono a:
A. Circa 7 cifre decimali significative
B. Circa 10 cifre decimali significative
C. Circa 15 cifre decimali significative
D. Esattamente 24 cifre decimali

180. Nello standard IEEE 754 in doppia precisione le 53 cifre binarie significative corrispondono a:
A. Circa 15 cifre decimali significative
B. Circa 7 cifre decimali significative
C. Circa 20 cifre decimali significative
D. Esattamente 53 cifre decimali

181. Nello standard IEEE 754 il valore massimo dell’esponente polarizzato con mantissa zero rappresenta:
A. Il valore infinito
B. Il valore NaN
C. Il valore zero
D. Un numero denormalizzato

182. La Macchina di Turing e la Macchina di Von Neuman sono:
A. Computer che non vengono più venduti
B. Modelli di computer che risolvono specifici problemi matematici
C. Computer di marca diversa
D. Modelli teorici di computazione algoritmica

183. I problemi che possono essere risolti con un algoritmo sono:
A. Tutti i problemi
B. Solo i problemi con meno di un miliardo di dati
C. Solo i problemi con soluzione numerica
D. Un sottoinsieme di tutti i problemi

184. Rispetto alla Macchina di Turing la Macchina di Von Neuman risolve:
A. Un numero di problemi minore
B. Gli stessi problemi
C. Un numero di problemi maggiore
D. Solo i problemi con soluzione numerica

185. In ogni transizioni di stato della Macchina di Turing lo stato successivo dipende:
A. Dalla lunghezza della sequenza scritta sul nastro
B. Dallo stato attuale e dal simbolo letto sul nasto
C. Dal primo stato assunto dalla macchina
D. Dal numero totale degli stati

186. Il Sistema Operativo è un programma che:
A. Traduce un programma scritto in un Linguaggio ad Alto Livello in un programma in Linguaggio Macchina
B. Esegue le operazioni aritmetiche e logiche
C. Gestisce le risorse Hardware del computer assegnandole ai programmi da eseguire e l'interazione con l'utente
D. Valuta le prestazioni dell'Unità Aritmetico-Logica

187. Le componenti Hardware del computer comunicano tra loro utilizzando:
A. La Memoria
B. Canali di comunicazione detti bus
C. Il Clock in fissati intervalli di tempo
D. Il Compilatore

188. La valutazione delle prestazioni di un computer misura:
A. I costi del Software
B. I costi dell'Hardware
C. La correttezza della soluzione fornita da un programma
D. L'efficienza della esecuzione di un programma su un computer

189. Un algoritmo è:
A. Una lista anche infinita di azioni comprensibili ed eseguibili da una macchina
B. Una lista finita di azioni comprensibili ed eseguibili da una macchina
C. Un insieme di azioni comprensibili ed eseguibili da una macchina
D. Una lista di azioni senza particolari vincoli

190. I progressi della tecnologia hanno:
A. Migliorato le prestazioni ed aumentatol'insieme dei problemi algoritmicamente risolubili
B. Ridotto i costi ed aumentato l'insieme dei problemi algoritmicamente risolubili
C. Cambiato i risultati teorici relativi alla computazione algoritmica
D. Migliorato le prestazioni del computer ma non hanno cambiato l'insieme dei problemi algoritmicamente risolubili

191. Nella Macchina di Turing gli stati, le trasizioni di stato, i simboli dell'alfabeto, i caratteri della sequenza scritta sul nastro sono:
A. Insiemi infiniti nel caso di algoritmi risolutivi di problemi complessi
B. Insiemi sia finiti che infiniti
C. Insiemi comunque grandi, ma sempre finiti
D. Sempre insiemi infiniti

192. Una Architettura RISC è caratterizzata da:
A. Istruzioni in Linguaggio Macchina più semplici ed un Hardware meno complesso
B. Istruzioni in Linguaggio Macchina che si possono eseguire su un qualunque computer
C. Istruzioni in Linguaggio Macchina più numerose ed un Hardware più complesso
D. Istruzioni in Linguaggio Macchina più lente ed un Hardware più complesso

193. Una istruzione in Linguaggio Macchina del MIPS è rappresentata da:
A. Una sequenza di 32 simboli dell'alfabero inglese
B. Una sequenza di almeno 32 cifre binarie
C. Una sequenza di 32 cifre binarie
D. Una sequenza di cifre binarie di lunghezza variabile

194. L'Assembler è:
A. Un programma che traduce un programma scritto in Assembly in un programma scritto in Linguaggio Macchina
B. Un linguaggio di programmazione
C. Un programma che traduce un programma scritto in un Linguaggio ad Alto Livello in un programma scritto in Linguaggio Macchina
D. Un programma che traduce un programma scritto in Linguaggio Macchina in un programma scritto in Assembly

195. Per accedere al contenuto di un particolare registro è necessario conoscere:
A. La lunghezza di tale registro
B. Il tipo di dato scritto in tale registro
C. L'indirizzo scritto in tale registro
D. L'indirizzo di tale registro

196. Nel Linguaggio Assembly del MIPS il simbolo $ seguito da caratteri alfanumerici rappresenta:
A. Il contenuto di un registro del processore
B. Il valore dell'operando di una istruzione
C. L'indirizzo di un registro del processore
D. La sequenza di 32 bit che fornisce l'operando di una istruzione

197. In un registro del Processore MIPS si può memorizzare:
A. Una sequenza di più di 32 cifre binarie
B. Una sequenzadi 32 simboli dell'alfabero inglese
C. Una sequenza di cifre binarie di lunghezza variabile
D. Una sequenza di 32 cifre binarie

198. Un programma scritto in un Linguaggio ad Alto Livello ed uno scritto in Assembly possono essere eseguiti:
A. Il primo solo su un computer con l'Architettura corrispondente al Linguaggio ad Alto Livello il secondo su un qualunque computer
B. Entrambi solo su un computer con Architettura corrispondente all'Assembly
C. Il primo su un qualunque computer il secondo solo su un computer con Architettura corrispondente all'Assembly
D. Entrambi su un qualunque computer

199. Una istruzione Assembly corrisponde sempre a:
A. Più istruzioni in Linguaggio Macchina
B. Una sola istruzione in Linguaggio Macchina
C. Una sola istruzione in Linguaggio ad Alto Livello
D. Più istruzioni in Linguaggio ad Alto Livello

200. I registri del Processore MIPS con indirizzi da $t0 a $t9 e da $s0 a $s7 sono utilizzati per:
A. Memorizzare sequenze di 32 bit che rappresentano gli indirizzi degli operandi delle istruzioni
B. Gestire la chiamata di procedura
C. Gestire le funzioni svolte dal Software di Sistema
D. Memorizzare sequenze di 32 bit che rappresentano il valore degli operandi delle istruzioni

201. Gli indirizzi dei registri del Processore MIPS sono:
A. Sequenze binarie contenute nei registri del processore
B. I 32 numeri numeri da 1 a 32
C. I 32 numeri da 0 a 31
D. Sequenze binarie fornite da dispositivi esterni

202. La Sintassi di un Linguaggio Formale stabilisce:
A. Il significato dell'istruzione
B. Le regole per rappresentare i numeri con segno
C. Le regole per scrivere ogni istruzione del Linguaggio Formale in modo corretto
D. Le regole per eseguire l'istruzione

203. La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione max=200; con l'associazione max--> $s5 è:
A. addi $s5, $s5, 200
B. add $s5, $zero, 200
C. sub $s5, $zero, 200
D. addi $s5, $zero, 200

204. La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione a=a*2; con l'associazione a--> $s0 è:
A. addi $s0, $s0, 2
B. add $s0, $s0, $s0
C. addi $s0, $s0, $s0
D. add $s0, $s0, 2

205. La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione h=b+c; con l'associazione b-->$s5 c-->$s2 h-->
A. $t0 è:
B. add $s5, $s2, $t0
C. add $t0, $s5, $s2
D. add $s2, $s5, $t0

206. add $t0, $s5, $s0
A. Il registro destinazione nell'istruzione add $s2, $t0, $t1 è:
B. $s2
C. $t1
D. $t0

207. $t2
A. Il Codice Operativo di una istruzione aritmetica dell'Assembly stabilisce:
B. Solo l'operazione aritmetica da eseguire
C. L'operazione aritmetica da eseguire e come reperire gli operandi
D. Solo gli operandi dell'operazione aritmetica da eseguire

208. Solo dove scrivere il risultato dell'operazione dopo l'esecuzione
A. Nell'istruzione addi dell'Assembly MIPS l'operando costante è contenuto:
B. Nel registro destinazione
C. Nel registro del primo operando
D. Nell'istruzione

209. Nel registro del secondo operando
A. La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione n=0; con l'associazione n--> $s3 è:
B. addi $s3, $zero, $zero
C. addi $zero, $s3, 0
D. add $zero, $s3, 0

210. addi $s3, $zero, 0
A. La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione val=i-k; con l'associazione val--> $s1 i--> $s3 k--
B. > $s2 è:
C. sub $s1, $s2, $s3
D. sub $s2, $s3, $s1

211. sub $s3, $s2, $s1
A. sub $s1, $s3, $s2
B. La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione m=m+k; con l'associazione k--> $s3 m--> $s0 è:
C. add $s3, $s0, $s0
D. add $s0, $s0, $s0

212. addi $s3, $s0, 2
A. add $s0, $s0, $s3
B. Il numero di sequenze binarie diverse di lunghezza K è:
C. Il numero 2K-1
D. Il numero 2K-1-1

213. Il numero 2K-1
A. Il numero 2K
B. In Notazione posizionale pesata il massimo valore rappresentabile con una sequenza binaria di lunghezza M è:
C. Non limitato
D. Il valore 2M

214. Il valore 2M-1
A. Il valore 2M-1
B. La scelta dell'alfabeto binario consente di:
C. Minimizzare l'errore dovuto ad oscillazioni del valore dei segnali elettrici
D. Minimizzare le connessioni tra le componenti interne del computer

215. Effettuare calcoli più semplici
A. Aumentare il numero di valori che si possono memorizzare nei registri
B. In Notazione posizionale pesata la cifra più significativa di una sequenza è:
C. La cifra più frequente all'interno della sequenza
D. La cifra che occupa la posizione più a sinistra

216. La cifra associata al peso di valore minore
A. La cifra che occupa la posizione più a destra
B. In Notazione posizionale pesata una sequenza binaria con cifra meno significativa uguale a 0 rappresenta:
C. Un numero pari
D. Un numero divisibile per 5

217. Un numero dispari
A. Un numero multiplo di 4
B. In Notazione posizionale pesata la cifra più significativa di una sequenza di lunghezza K è associata al peso:
C. Dato dal valore 2K
D. Dato dal valore 20

218. Dato dal valore 2K-1
A. Dato dal valore 2K-1
B. In Notazione posizionale pesata il massimo valore che si può rappresentare nel contenuto di un registro del processore è:
C. Il valore 232
D. Il valore 32

219. Il valore 232-1
A. Il valore 232-1
B. Per specificare l'indirizzo di un registro del processore MIPS occorre:
C. Una sequenza di 32 bit
D. Una sequenza di 16 bit

220. Una sequenza di 8 bit
A. Una sequenza di 5 bit
B. Il risultato di un calcolo determina un overflow quando:
C. Il calcolo è troppo complesso
D. La cifra più significativa della sequenza che rappresenta il risultato ha il valore 1

221. Per rappresentare il risultato è necessario un numero di bit maggiore della lunghezza dei registri del processore
A. Il risultato è uguale a 0
B. In Notazione posizionale pesata la sequenza binaria 11011 rappresenta il valore:
C. Del numero 19 in base 10
D. Del numero 54 in base 10

222. Del numero 27 in base 10
A. Del numero 25 in base 10
B. In Notazione posizionale pesata, l'addizione di due interi positivi si effettua:
C. Ponendo a 0 il riporto trial cifra meno significativa e sommando in sequenza su ogni posizione i bit degli operandi e del riporto a partire da sinistra
D. Ponendo a 0 il riporto sulla cifra meno significativa e sommando in sequenza su ogni posizione i bit degli operandi e del riporto a partire da destra

223. Sommando in sequenza su ogni posizione i bit degli operandi e del riporto a partire da sinistra
A. Ponendo a 1 il riporto sulla cifra meno significativa e sommando in sequenza su ogni posizione i bit degli operandi e del riporto a partire da destra
B. Nella notazione in modulo e segno, il segno del risultato dell'addizione è:
C. Sempre positivo
D. Quello del primo numero

224. Quello del numero con modulo maggiore
A. Quello del numero con modulo minore
B. Nella Notazione in complemento a 2, il peso del bit più a sinistra in una sequenza di lunghezza K è:
C. Il valore -2K -1
D. Il valore -2K-1

225. Il valore -2K
A. Il valore +2K -1
B. Nella Notazione in complemento a 2, il segno del numero è determinato da:
C. Il bit più a destra con il relativo peso negativo
D. Il bit più a sinistra con il relativo peso negativo

226. Il bit della cifra meno significativa con il relativo peso negativo
A. Il bit più a sinistra non associato ad un peso
B. Nella Notazione in complemento a 2, la somma di due interi con segni opposti viene eseguita:
C. Sottraendo il numero di modulo minore dal numero di modulo maggiore
D. Addizionando al primo l'opposto del secondo

227. Sottraendo dal primo l'opposto del secondo
A. Addizionando i due numeri
B. Nella Notazione in complemento a 2, il massimo numero rappresentabile con sequenze di lunghezza M è
C. Il valore 2M
D. Il valore 2M -1 -1

228. Il valore 2M -1
A. Il valore 2M -1
B. Nella Notazione in complemento a 2, il minimo numero rappresentabile con sequenze di lunghezza M è:
C. Il valore -2M -1
D. Il valore -2M

229. Il valore -2M -1
A. Il valore -2M -1 -1
B. Nella Notazione in complemento a 2, la sequenza binaria 0101 rappresenta:
C. Il valore +5
D. Il valore +3

230. Il valore -5
A. Il valore -3
B. Nella Notazione in complemento a 2, la sequenza binaria 1001 rappresenta:
C. Il valore +7
D. Il valore -5

231. Il valore -7
A. Il valore +5
B. Nella Notazione in complemento a 2, la sequenza binaria 1111 rappresenta:
C. Il valore +15
D. Il valore -1

232. Il valore -7
A. Il valore +7
B. In Notazione in complemento a 2, la rappresentazione dell'opposto del valore rappresentato da una sequenza di N bit si ottiene:
C. Complementando la sequenza bit a bit ed aggiungendo il valore -2N
D. Complementando la sequenza bit a bit ed aggiungendo il valore 1

233. Cambiando il bit più significativo da 0 in 1 e da 1 in 0
A. Aggiungendo il valore 1 alla sequenza
B. In Notazione in complemento a 2, la sottrazione di due operandi si esegue:
C. Addizionando al primo operando il secondo complementato bit a bit
D. Sottraendo dal primo operando il secondo

234. Addizionando al primo operando il secondo complementato bit a bit e sommato con il valore 1
A. Sottraendo l'operando con modulo minore da quello con modulo maggiore
B. La dichiarazione di tipo intero per una variabile in un Linguaggio ad Alto Livello indica al Compilatore che:
C. Per la variabile si deve utilizzare la Notazione posizionale pesata
D. Per la variabile si deve utilizzare la Notazione con segno separato dal modulo

235. Per la variabile si deve utilizzare la Notazione in complemento a 2
A. La variabile ha segno positivo
B. L'overflow può verificarsi:
C. Addizionando numeri con lo stesso segno
D. Addizionando numeri con segni diversi

236. Mai con numeri negativi
A. Mai addizionando numeri con lo stesso segno
B. In Notazione in complemento a 2, l'overflow viene segnalato quando gli ultimi due riporti c<sub>N</sub> e c<sub>N-1</sub>:
C. Sono uguali
D. Hanno entrambi valore 0

237. Sono diversi
A. Hanno entrambi valore 1
B. In Notazione in complemento a 2, l'estensione del segno:
C. Trasforma un numero positivo in negativo e viceversa
D. Aumenta la lunghezza di una sequenza aggiungendo cifre uguali a 0 a sinistra della cifra più significativa

238. Aumenta la lunghezza di una sequenza aggiungendo cifre uguali a 1 a sinistra della cifra più significativa
A. Aumenta la lunghezza di una sequenza senza modificarne il valore rappresentato
B. L'estensione del segno di una sequenza con bit più significativo uguale a 1 si effettua:
C. Ponendo a sinistra di tale bit tutte cifre uguali a 1
D. Cambiando in 0 il valore di tale bit

239. Ponendo a sinistra di tale bit tutte cifre uguali a 0
A. Complementando la sequenza bit a bit ed aggiungendo 1
B. Eseguendo un'addizione in Notazione in complemento a 2, se c<sub>N</sub> ha valore 0 e c<sub>N-1</sub> ha valore 1:
C. Il risultato è corretto
D. Il risultato è sbagliato

240. Il risultato ha solo il segno corretto
A. Il risultato ha solo il modulo corretto
B. Eseguendo un'addizione in Notazione in complemento a 2, se c<sub>N</sub> ha valore 1 e c<sub>N-1</sub> ha valore 1:
C. Il risultato è sbagliato
D. Il risultato ha solo il segno corretto

241. Il risultato ha solo il modulo corretto
A. Il risultato è corretto
B. Eseguendo un'addizione in Notazione in complemento a 2, i riporti c<sub>N</sub> e c<sub>N-1</sub> che segnalano l'Overflow nell'Architettura MIPS sono:
C. i riporti con indici c2 e c1
D. I riporti con indici c31 e c30

242. I riporti con indici c33 e c32
A. I riporti con indici c32 e c31
B. L'estensione del segno di una sequenza con bit più significativo uguale a 0 si effettua:
C. Cambiando in 1 il valore di tale bit
D. Ponendo a sinistra di tale bit tutte cifre uguali a 1

243. Complementando la sequenza bit a bit ed aggiungendo 1
A. Ponendo a sinistra di tale bit tutte cifre uguali a 0
B. Il Formato di una istruzione in Linguaggio Macchina è definito da:
C. Una regola per il calcolo degli indirizzi degli operandi dell'istruzione
D. Una suddivisione fisica della sequenza binaria che rappresenta l'istruzione in sottosequenze di lunghezza e posizione fissata

244. Una suddivisione concettuale della sequenza binaria che rappresenta l'istruzione in sottosequenze di lunghezza e posizione fissata
A. Una regola che stabilisce la Notazione degli operandi dell'istruzione
B. La Modalità di Indirizzamento di una istruzione in Linguaggio Macchina stabilisce:
C. La regola per suddividere in campi la sequenza binaria che rappresenta l'istruzione
D. La regola per determinare gli indirizzi degli operandi utilizzando il contenuto dei campi stabiliti dal Formato

245. La Notazione da utilizzare per la rappresentazione degli operandi dell'istruzione
A. La modalità di accesso in Memoria in lettura o in scrittura
B. Nel Linguaggio Macchina MIPS, i campi del Formato di Tipo R sono:
C. Sottosequenze della sequenza binaria che rappresenta l'istruzione di lunghezze 8, 6, 6, 6, 6, 6
D. Sottosequenze della sequenza binaria che rappresenta l'istruzione di lunghezze 6, 5, 5, 16

246. Sottosequenze della sequenza binaria che rappresenta l'istruzione di lunghezze 5, 5, 5, 5, 6, 6
A. Sottosequenze della sequenza binaria che rappresenta l'istruzione di lunghezze 6, 5, 5, 5, 5, 6
B. Nel Linguaggio Macchina MIPS, il campo Codice Operativo di una istruzione stabilisce:
C. La Notazione da adottare per gli operandi
D. L'indirizzo dove memorizzare il risultato dell'esecuzione dell'istruzione

247. L'operazione da eseguire ed il Formato dell'istruzione
A. Se l'istruzione è una addizione oppure una sottrazione
B. Nel Linguaggio Macchina MIPS, il campo funct è:
C. Un campo di 5 bit del Formato di Tipo R che indica l'indirizzo del registro che contiene il primo operando
D. Un campo di 6 bit del Formato di Tipo R che indica l'operazione Aritmetico-Logica da eseguire

248. Un campo di 6 bit del Formato di Tipo R che indica la modalità di indirizzamento dell'istruzione
A. Un campo di 5 bit del Formato di Tipo R che indica l'indirizzo del risultato della funzione eseguita dall'istruzione
B. Nel Linguaggio Macchina MIPS, con l'Indirizzamento tramite registro gli indirizzi degli operandi sono contenuti:
C. Nei campi rt e shamt del Formato di Tipo R
D. Nei campi rd e funct del Formato di Tipo R

249. Nei campi rs e rt del Formato di Tipo I
A. Nei campi rs e rt del Formato di Tipo R
B. Le lunghezze dei campi dell'istruzione in Linguaggio Macchina MIPS che traduce l'istruzione Assembly add $t0,
C. $s0, $s1 sono:
D. I valori 6, 5, 5, 16

250. I valori 6, 5, 5, 5, 5, 6
A. I valori 7, 5, 5, 5, 5, 5
B. I valori 5, 5, 5, 5, 6, 6
C. Le istruzioni del Linguaggio Macchina MIPS con Codice operativo 0 hanno:
D. Il Formato di Tipo I

251. Il Formato di Tipo S
A. Il Formato di Tipo R
B. Il Formato di Tipo J
C. La suddivisione in campi dell'istruzione in Linguaggio Macchina MIPS 00000010000100010100000000100000 in base al suo Formato è data:
D. Dalle sottosequenze 0000001, 000010001, 010000000, 0100000

252. Dalle sottosequenze 0000001, 00001, 00010, 10000, 00001, 00000
A. Dalle sottosequenze 000000, 10000, 10001, 01000, 00000, 100000
B. Dalle sottosequenze 000000, 10000, 10001, 0100000000100000
C. Nell'istruzione in Linguaggio Macchina MIPS con valori dei campi del Formato dati da 000000, 01000, 01001, 10000, 00000, 100010 l'indirizzo del registro che contiene il risultato è:
D. Il campo 01000

253. Il campo 01001
A. Il campo 100010
B. Il campo 10000
C. L'operatore AND ha valore 1 quando:
D. Un solo operando ha valore 1

254. Sempre
A. Gli operandi hanno entrambi valore 1
B. Almeno un operando ha valore 1
C. L'operatore OR ha valore 0 quando:
D. Gli operandi hanno entrambi valore 0

255. Mai
A. Un solo operando ha valore 0
B. Almeno un operando ha valore 0
C. Per le istruzioni Aritmetico-Logiche del Linguaggio Macchina MIPS il campo Codice Operativo contiene:
D. La sequenza di 5 bit 00000

256. La sequenza di 6 bit 100000
A. La sequenza di 6 bit 000000
B. La sequenza di 5 bit 00001
C. Il Formato dell'istruzione in Linguaggio Macchina MIPS 00000010000100010100000000100101 è:
D. Di Tipo I

257. Di Tipo K
A. Di Tipo J
B. Di Tipo R
C. Nel Linguaggio Macchina MIPS, il campo shamt del Formato di Tipo R contiene:
D. L'indicazione di shift a sinistra o shift a destra

258. L'indirizzo del registro dell'operando
A. Il codice della funzione shift
B. Il numero di posizioni da scorrere nelle istruzioni di shift, altrimenti 0
C. Nell'istruzione in Linguaggio Macchina MIPS con campi del Formato dati da 000000, 01000, 01001, 11110, 00000, 100101 gli indirizzi degli operandi sono:
D. I valori binari 000000, 01000

259. I valori binari 01001, 11110
A. I valori binari 01000, 01001
B. I valori binari 10000, 100101
C. Nel Linguaggio Macchina MIPS, la Modalità di Indirizzamento delle istruzioni and ed or è:
D. Immediato per entrambe

260. Tramite registro per entrambe
A. Di Tipo R per entrambe
B. Di Tipo I per entrambe
C. La traduzione in Assembly MIPS dell'OR bit a bit con operandi nei registri $s1 e $s2 e risultato nel registro $t0 è:
D. L'istruzione or $s1, $s2, $t0

261. L'istruzione or t0, s1, s2
A. L'istruzione or $t0, $s1, $s2
B. L'istruzione or $s1, $t0, $s2
C. La traduzione in Assembly MIPS dello Shift a sinistra di 4 posizioni con registro operando $s3 e registro destinazione $t0 è:
D. L'istruzione sll $s3, $t0, 4

262. L'istruzione shift $t0 , $s3, 4
A. L'istruzione sll $t0, $s3, 4
B. L'istruzione shift $s3, $t0, 4
C. La traduzione in Assembly MIPS dell'AND bit a bit con operandi nei registri $s1 e $s2 e risultato nel registro $s5 è:
D. L'istruzione and $s1, $s5, $s2

263. L'istruzione and $s1, $s2, $s5
A. L'istruzione and $s2, $s5, $s1
B. L'istruzione and $s5, $s1, $s2
C. Nel Linguaggio Macchina MIPS, i campi del Formato di Tipo I contengono:
D. Sequenze di lunghezza 6, 5, 5, 5, 5, 6

264. Sequenze di lunghezza 6, 5, 5, 16
A. Sequenze di lunghezza 6, 16, 5, 5
B. Sequenze di lunghezza 6, 26
C. Nel Linguaggio Macchina MIPS, la suddivisione in campi dell'istruzione 00100001000010011000000000100101 con Formato di Tipo I è data:
D. Dalle sequenze 0010000100001001, 10000, 00000, 100101

265. Dalle sequenze 001000, 01000, 01001, 10000, 00000, 100101
A. Dalle sequenze 001000, 01000, 010011000000000, 100101
B. Dalle sequenze 001000, 01000, 01001, 1000000000100101
C. Nel Linguaggio Macchina MIPS, il Formato e la Modalità di Indirizzamento dell'istruzione addi sono:
D. Formato di Tipo R con Indirizzamento immediato

266. Formato di Tipo I con Indirizzamento immediato
A. Formato di Tipo I con Indirizzamento tramite registro
B. Formato di Tipo I sia con Indirizzamento tramite registro sia con Indirizzamento immediato
C. La traduzione in Assembly MIPS dell'assegnamento val = b - 300 con l'associazione tra variabi e indirizzi di registri b-->$s1 e val-->$t0 è:
D. L'istruzione sub $t0, $s1, 300

267. L'istruzione addi $t0, $s1, -300
A. L'istruzione addi $s1, $t0, -300
B. L'istruzione sub $s1, $t0, 300
C. Nel Formato di Tipo I, i valori del campo immediato sono compresi tra:
D. Il minimo -216 ed il massimo 216

268. Il minimo -215 ed il massimo 215
A. Il minimo 0 ed il massimo 216-1
B. Il minimo -215 ed il massimo 215-1
C. L'operando immediato dell'istruzione Assembly MIPS addi $t0, $s1, 30 è rappresentato in Linguaggio Macchina mediante:
D. Una sequenza di 16 bit in Notazione posizionale pesata

269. Una sequenza di 16 bit in Notazione modulo e segno
A. Una sequenza di 16 bit in Notazione in complemento a 2
B. Una sequenza di 16 bit in Notazione posizionale pesata senza segno
C. Prima della esecuzione di una istruzione con Formato di Tipo I il valore del campo immediato viene:
D. Inviato all'ALU aggiungendo 16 bit uguali a 0 a sinistra della sequenza contenuta nel campo

270. Inviato all'ALU aggiungendo 16 bit uguali a 0 a destra della sequenza contenuta nel campo
A. Inviato all'ALU aggiungendo 16 bit mediante estensione del segno alla sequenza contenuta nel campo
B. Copiato in un registro di 32 bit
C. La Modalità di Indirizzamento immediato è utilizzata con:
D. Il formato di Tipo R e il Formato di Tipo I

271. Solo il Formato di Tipo I
A. Solo il Formato di Tipo R
B. Il formato di Tipo J
C. Nel Linguaggio Macchina MIPS, la Modalità di Indirizzamento immediato fornisce due operandi mediante due campi del Formato di Tipo I che contengono:
D. Gli indirizzi dei registri che contengono i due operandi

272. Due numeri interi in Notazione in complemento a 2 che costituiscono i due operandi
A. I valori Codice Operativo e funzione
B. Un numero intero in Notazione in complemento a 2 che costituisce un operando e l'indirizzo di un registro che contiene l'altro operando
C. L'esecuzione dell'istruzione Assembly MIPS addi $s7, $t0, -35 ha l'effetto di:
D. Addizionare -35 al contenuto del registro di indirizzo $s7 e scrivere il risultato come contenuto del registro di indirizzo $t0

273. Addizionare i contenuti dei registri di indirizzi $s7 e $t0 a -35 e scrivere il risultato come contenuto del registro di indirizzo $s7
A. Addizionare -35 al contenuto del registro di indirizzo $t0 e scrivere il risultato come contenuto del registro di indirizzo $s7
B. Copiare -35 nel registro di indirizzo $t0 e addizionare al contenuto del registro di indirizzo $s7
C. Gli indirizzi della Memoria principale MIPS sono dati da:
D. Sequenze di 32 bit

274. Sequenze di 5 bit
A. Sequenze di 8 bit
B. Sequenze di 64 bit
C. Le dimensioni di 1 Kappa, 1 Mega, 1 Giga corrisponsono:
D. Ai valori 1 Kappa = circa un Milione, 1 Mega = circa un Miliardo, 1 Giga = circa Mille Miliardi

275. Ai valori 1 Kappa = circa Cento, 1 Mega = circa Mille, 1 Giga = circa un Milione
A. Ai valori 1 Kappa = circa Mille, 1 Mega = circa un Milione, 1 Giga = circa un Miliardo
B. Ai valori 1 Kappa = circa Mille, 1 Mega = circa 10 Milioni, 1 Giga = circa 10 Miliardi
C. Il numero di locazioni della Memoria principale MIPS è dato dal:
D. Valore 25

276. Valore 232-1
A. Valore 232
B. Valore 231-1
C. Il contenuto di una locazioni della Memoria principale MIPS è dato da:
D. Una sequenza di 64 bit

277. Una sequenza di 32 bit
A. Una sequenza di 5 bit
B. Una sequenza di 8 bit
C. In Assembly MIPS, l'operazione di leggere la parola che inizia all'indirizzo di Memoria calcolato tramite il registro Base di indirizzo $t1 e l'Offset 9 e scriverla nel registro di indirizzo $s2 è eseguita dalla:
D. Istruzione sw $t1, 9 ($s2)

278. Istruzione lw $t1, 9 ($s2)
A. Istruzione sw $s2, 9 ($t1)
B. Istruzione lw $s2, 9 ($t1)
C. L'istruzone Assembly MIPS lw $t5, 4($s0):
D. Legge la parola di Memoria che inizia dall'indirizzo dato dalla somma del contenuto del registro Base di indirizzo $t5 più l'Offset 4, e la scrive come contenuto del registro di indirizzo $s0

279. Legge la parola di Memoria che inizia dall'indirizzo dato dalla somma del contenuto del registro Base di indirizzo $s0 più l'Offset 4, e la scrive come contenuto del registro di indirizzo $t5
A. Scrive il contenuto del registro di indirizzo $t5 nella parola di Memoria che inizia dall'indirizzo dato dalla somma del contenuto del registro base di indirizzo $s0 più l'Offset 4
B. Scrive il contenuto del registro di indirizzo $s0 nella parola di Memoria che inizia dall'indirizzo dato dalla somma del contenuto del registro base di indirizzo $t5 più l'Offset 4
C. In Assembly MIPS, l'operazione di scrittura del contenuto del registro di indirizzo $s3 nella parola che inizia all'indirizzo di Memoria calcolato tramite il registro Base di indirizzo $t0 e l'Offset 8 è eseguita dalla:
D. Istruzione lw $s3, 8 ($t0)

280. Istruzione sw $t0, 8 ($s3)
A. Istruzione sw $s3, 8 ($t0)
B. Istruzione lw $t0, 8 ($s3)
C. L'istruzone Assembly MIPS sw $t1, 4($s5):
D. Legge la parola di Memoria che inizia dall'indirizzo dato dal contenuto del registro Base di indirizzo $s5 più l'Offset 4 e la scrive come contenuto del registro di indirizzo $t1

281. Scrive il contenuto del registro di indirizzo $s5 nella parola di Memoria che inizia dall'indirizzo dato dal contenuto del registro Base di indirizzo $t1 più l'Offset 4
A. Scrive il contenuto del registro di indirizzo $t1 nella parola di Memoria che inizia dall'indirizzo dato dal contenuto del registro Base di indirizzo $s5 più l'Offset 4
B. Legge la parola di Memoria che inizia dall'indirizzo dato dal contenuto del registro Base di indirizzo $t1 più l'Offset 4 e la scrive come contenuto del registro di indirizzo $s5
C. Per l'istruzione load word la modalità di indirizzamento tramite Base e Offset calcola:
D. L'indirizzo di una parola di Memoria da cui leggere un dato

282. L'indirizzo di un registro del processore da cui leggere un dato
A. L'indirizzo di una locazione di Memoria in cui scrivere un dato
B. L'indirizzo di un registro del processore in cui scrivere un dato
C. Per l'istruzione store word la modalità di indirizzamento tramite Base e Offset calcola:
D. L'indirizzo di un registro del processore in cui scrivere un dato

283. L'indirizzo di un registro del processore da cui leggere un dato
A. L'indirizzo di una locazione di Memoria da cui leggere un dato
B. L'indirizzo di una parola di Memoria in cui scrivere un dato
C. La traduzione in Assembly MIPS dell'assegnamento val = A[3], associando a val il registro di indirizzo $t0, ed assumendo che l'indirizzo del registro Base dell'Array di numeri interi è $s1, è data da:
D. L'istruzione sw $s1, 12 ($t0)

284. L'istruzione sw $t0, 12 ($s1)
A. L'istruzione lw $s1, 12 ($t0)
B. L'istruzione lw $t0, 12 ($s1)
C. Il valore dell'Offset nell'istruzione Assembly MIPS lw $t0, 5($s3) è rappresentato nel Formato corrispondente in Linguaggio Macchina mediante:
D. I 5 bit del campo rt del Formato di Tipo R

285. I 16 bit del campo immediato del Formato di Tipo I
A. I 6 bit del campo Funzione del Formato di Tipo R
B. I 5 bit del campo rs del Formato di Tipo I
C. Nel Linguaggio Macchina MIPS, la Modalità di Indirizzamento dell'istruzione store word calcola:
D. L'indirizzo del primo Byte della parola di Memoria dove leggere il dato da scrivere in un registro

286. L'indirizzo del registro che contiene l'operando da scrivere in Memoria
A. L'indirizzo del registro dove scrivere una copia dell'operando letto dalla Memoria
B. L'indirizzo del primo Byte della parola di Memoria dove scrivere il dato letto da un registro
C. La suddivisione in campi del Formato dell'istruzione load word 10001110000010010000000000000111 in Linguaggio Macchina MIPS è data da:
D. Le 6 sottosequenze 100011, 10000, 01001, 00000, 00000, 000111

287. Le 4 sottosequenze 100011, 10000, 01001, 0000000000000111
A. Le 4 sottosequenze 100011, 1000001001000000, 00000, 00111
B. Le 3 sottosequenze 100011, 10000, 010010000000000000111
C. L'indirizzo del registro Base nel Formato dell'istruzione in Linguaggio Macchina store word 101011, 01000, 01111, 0000000000000001 è dato da:
D. La sottosequenza 0000000000000001

288. La sottosequenza 01111
A. La sottosequenza 101011
B. La sottosequenza 01000
C. Il registro Base di un Array contiene:
D. L'indirizzo del primo Byte della parola di Memoria in cui è memorizzato l'elemento A[0]

289. Il valore dell'elemento A[0]
A. L'indirizzo di Memoria in cui è memorizzato l'elemento A[1]
B. Il valore dell'elemento A[1]
C. L'errore "Array out of bounds" avviene quando:
D. Si accede all'ultimo elemento dell'Array

290. Si dichiara una dimensione di Array maggiore dello spazio di Memoria disponibile
A. Si utilizza un valore dell'indice dell'Array che determina un accesso a locazioni di Memoria fuori dallo spazio destinato a contenere gli elementi dell’Array
B. Il valore di un elemento in un Array di interi non è rappresentabilie con 32 bit
C. La traduzione in Assembly MIPS dell'assegnamento A[5] = val, associando a val il registro di indirizzo $s2 ed assumendo che l'indirizzo del registro Base dell'Array di numeri interi è $t3, è data da:
D. L'istruzione lw $s2, 20 ($t3)

291. L'istruzione sw $s2, 20 ($t3)
A. L'istruzione sw $t3, 20 ($s2)
B. L'istruzione lw $t3, 20 ($s2)
C. L'indirizzo di Memoria dell'elemento B[9] di un Array di numeri interi è dato da:
D. L'indirizzo dell'elemento B[0] sommato all'Offset 9

292. L'indirizzo del primo Byte dell'elemento B[9] ottenuto sommando l'Offset 9 al contenuto del registro Base dell'Array
A. L'indirizzo del primo Byte dell'elemento B[9] ottenuto sommando l'Offset 36 al contenuto del registro Base dell'Array
B. L'indirizzo dell'elemento B[1] sommato all'Offset 9
C. La traduzione in Assembly MIPS dell'assegnamento val = A[0], associando a val il registro di indirizzo $t0, ed assumendo che l'indirizzo del registro Base dell'Array di numeri interi è $s1, è data da:
D. L'istruzione sw $s1, 0 ($t0)

293. L'istruzione sw $t0, 0 ($s1)
A. L'istruzione lw $t0, 0 ($s1)
B. L'istruzione lw $s1, 0 ($t0)
C. L'esecuzione dell'istruzione Assembly MIPS beq $t1, $t2, NOME determina:
D. La scrittura nei registri di indirizzi $t1 e $t2 del contenuto della locazione Memoria che corrisponde all'etichetta NOME

294. Un salto all'esecuzione dell'istruzione con etichetta NOME se i contenuti dei registri con indirizzi $t1 e $t2 sono DIVERSI
A. Un salto all'esecuzione dell'istruzione con etichetta NOME se i contenuti dei registri con indirizzi $t1 e $t2 sono UGUALI
B. La scrittura nel registro di indirizzo $t1 del contenuto del registro $t2, ed il salto all'istruzione con etichetta NOME
C. Nel Linguaggio Assembly MIPS il salto ad una istruzione con etichetta NEW se il valore dei registri con indirizzi $s0,
D. $s1 sono DIVERSI è eseguito dalla:

295. Istruzione jump $s0, $s1, NEW
A. Istruzione bne $s0, $s1, NEW
B. Istruzione beq $s0, $s1, NEW
C. Istruzione jr $s1, $s0, NEW
D. Nel Linguaggio Macchina MIPS l'istruzione beq ha:

296. Formato di Tipo J e Indirizzamento relativo al Program Counter
A. Formato di Tipo I e Indirizzamento immediato
B. Formato di Tipo I e Indirizzamento relativo al Program Counter
C. Formato di Tipo J e Indirizzamento immediato
D. Il campo immediato del Formato di Tipo I dell'istruzione in Linguaggio Macchina MIPS che traduce l'istruzione Assembly bne $t3, $t5, NOME contiene:

297. La sequenza binaria che rappresenta l'etichetta NOME
A. Il numero di istruzioni da saltare in Notazione binaria
B. Il valore da scrivere nel Program Counter
C. Il numero di istruzioni da saltare in Notazione in complemento a 2
D. I campi del Formato dell'istruzione in Linguaggio Macchina MIPS 00010010000010000000000000000111 che traduce l'istruzione Assembly beq $s0, $t0, ETICHETTA sono dati dalle:

298. Sottosequenze 000100, 1000001000000000, 00000, 00111 rispettivamente di lunghezza 6, 16, 5, 5
A. Sottosequenze 000100, 10000010000000000000000111 rispettivamente di lunghezza 6, 26
B. Sottosequenze 000100, 10000, 01000, 00000, 00000, 000111 rispettivamente di lunghezza 6, 5, 5, 5, 5, 6
C. Sottosequenze 000100, 10000, 01000, 0000000000000111 rispettivamente di lunghezza 6, 5, 5, 16
D. Nella Modalità di Indirizzamento relativo al Program Counter il contenuto del campo immediato è esteso di segno a 32 bit perchè:

299. Il contenuto del campo immediato viene copiato in 4 Byte di Memoria che corrispondono a 32 bit
A. Il contenuto del campo immediato viene copiato in un registro e i registri del processore MIPS contengono 32 bit
B. Il contenuto del campo immediato moltiplicato per 4 è addizionato al valore del Program Counter dall'ALU che richiede operandi a 32 bit
C. Il contenuto del campo immediato viene confrontato con il contenuto del Program Counter che contiene 32 bit
D. Nella traduzione in Linguaggio Macchina MIPS gli indirizzi dei registri che figurano nell'istruzione Assembly beq

300. $s2, $s3, ETICHETTA sono posti:
A. Nei primi due campi di 5 bit del Formato di Tipo R nello stesso ordine che presentano nell'istruzione Assembly
B. Nei primi due campi di 5 bit del Formato di Tipo R invertendo l'ordine che presentano nell'istruzione Assembly
C. Nei campi di 5 bit del Formato di Tipo I nello stesso ordine che presentano nell'istruzione Assembly
D. Nei campi di 5 bit del Formato di Tipo I invertendo l'ordine che presentano nell'istruzione Assembly

301. La Modalità di Indirizzamento relativo al Program Counter è associata:
A. All'istruzione jump
B. Alle istruzioni beq e bne
C. All'istruzione sw
D. All'istruzione jal

302. La Modalità di Indirizzamento relativo al Program Counter calcola l'indirizzo:
A. Della istruzione da leggere in memoria, addizionando al contenuto del Program Counter il contenuto del registro Base
B. Della istruzione a cui saltare, addizionando al contenuto del Program Counter il valore del registro Base
C. Della istruzione a cui saltare, addizionando al contenuto del Program Counter il valore del campo immediato esteso di segno
D. Della istruzione a cui saltare, addizionando al contenuto del Program Counter il valore del campo immediato esteso di segno e moltiplicato per 4

303. Nella Modalità di Indirizzamento relativo al Program Counter il contenuto del campo immediato è moltiplicato per 4 perchè:
A. Rappresenta il numero di istruzioni da saltare e ogni istruzione occupa 4 Byte di Memoria
B. Rappresenta il contenuto di un registro e ogni registro è costituito da 4 Byte
C. L'estensione del segno estende il campo immediato a 32 bit che corrispondono a 4 Byte
D. Il Program Counter è costitutito da 32 bit che corrispondono a 4 Byte

304. Nel Linguaggio Assembly MIPS l'istruzione j NOME esegue:
A. Il salto all'istruzione del programma preceduta dall'etichetta NOME se il contenuto di due registri è uguale
B. Il ritorno al programma principale dopo l'esecuzione della procedura NOME
C. Il salto alla esecuzione della procedura NOME
D. Il salto incondizionato all'istruzione del programma preceduta dall'etichetta NOME

305. L'istruzione Assembly MIPS di salto incondizionato ha:
A. La forma sintattica j ETICHETTA
B. La forma sintattica jump ETICHETTA
C. La forma sintattica branch ETICHETTA
D. La forma sintattica b ETICHETTA

306. L'istruzione del Linguaggio Macchina MIPS che traduce l'istruzione Assembly j NOME ha:
A. Formato di Tipo J e Indirizzamento relativo al Program Counter
B. Formato di Tipo J e Indirizzamento pseudodiretto
C. Formato di Tipo I e Indirizzamento immediato
D. Formato di Tipo I e Indirizzamento relativo al Program Counter

307. I campi del Formato dell'istruzione in Linguaggio Macchina MIPS 00001011111000000000011111000011 che traduce l'istruzione Assembly j NOME sono dati dalle:
A. Sottosequenze 000010, 11111, 00000, 00000, 11111, 000011 di lunghezze 6, 5, 5, 5, 5, 6
B. Sottosequenze 000010, 11111, 00000, 0000011111000011 di lunghezze 6, 5, 5, 16
C. Sottosequenze 000010, 11111000000000011111000011 di lunghezze 6, 26
D. Sottosequenze 000010, 1111100000000001, 11110, 00011 di lunghezze 6, 16, 5, 5

308. Il campo di 26 bit del Formato di Tipo J del Linguaggio Macchina MIPS contiene:
A. L'indirizzo di salto incondizionato dell'istruzione Assembly j
B. Una parte dell'indirizzo di salto incondizionato dell'istruzione Assembly j
C. Un operando immediato da aggiungere al contenuto di un registro dell'istruzione Assembly addi
D. L'indirizzo di Memoria da cui prelevare un operando dell'istruzione Assembly lw

309. I campi del Formato J dell'istruzione del Linguaggio Macchina MIPS che traduce l'istruzione Assembly j NOME contengono:
A. Sottosequenze binarie di lunghezze 6, 5, 5, 16
B. Sottosequenze binarie di lunghezze 6, 16, 5, 5
C. Sottosequenze binarie di lunghezze 6, 5, 5, 5, 5, 6
D. Sottosequenze binarie di lunghezze 6, 26

310. Nel Linguaggio Macchina MIPS l'Indirizzamento pseudodiretto è associato:
A. All'istruzione j ed al Formato di Tipo J
B. All'istruzione j ed al Formato di Tipo I immediato
C. Alle istruzioni beq e bne ed al Formato di Tipo I immediato
D. Alle istruzioni lw e sw ed al Formato di Tipo I immediato

311. Nel Linguaggio Macchina MIPS l'Indirizzamento pseudodiretto calcola:
A. L'indirizzo di Memoria da cui leggere un operando
B. L'indirizzo dell'istruzione a cui saltare se i contenuti di due registri sono uguali
C. L'indirizzo di Memoria in cui scrivere il risultato di una operazione
D. L'indirizzo dell'istruzione a cui saltare

312. L'Indirizzamento pseudodiretto completa i 26 bit nel campo del formato di Tipo J mediante:
A. L'estensione del segno a 32 bit
B. L'estensione del segno a 32 bit e la moltiplicazione per 4
C. L'aggiunta dei bit più significativi del Program Counter a sinistra
D. L'aggiunta di due bit 00 a destra, e dei 4 bit più significativi del Program Counter a sinistra

313. L'Indirizzamento pseudodiretto richiede che:
A. L'aggiunta dell'Offset al registro Base non determini l'errore di overflow
B. Tutte le istruzioni del programma siano memorizzate in locazioni di Memoria i cui indirizzi hanno i 4 bit più significativi che non cambiano
C. Sia verificata la condizione di uguaglianza del contenuto di due registri
D. L'accesso in Memoria avvenga in scrittura

314. L'istruzione IF_ELSE del Linduaggio ad Alto Livello, nel Linguaggio Assembly:
A. Viene tradotta come una chiamata di procedura che permette l’esecuzione condizionale di due istruzioni in alternativa, a seconda del valore di verità di una espressione logica
B. Viene tradotta da una analoga istruzione if-else che permette l’esecuzione condizionale di due istruzioni in alternativa, a seconda del valore di verità di una espressione logica
C. Non ha una corrispondente istruzione e viene tradotta combinando istruzioni di salto condizionato ed incondizionato
D. Non ha una corrispondente istruzione e viene sempre tradotta combinando istruzioni di accesso alla Memoria principale

315. In Linguaggio Assembly la ripetizione di un insieme di istruzioni per un numero fissato di volte può essere ottenuta:
A. Mediante una specifica istruzione Assembly che corrisponde all'istruzione FOR
B. Solo scrivendo un numero di copie delle istruzioni da ripetere pari al fissato numero di ripetizioni
C. Mediante combinazioni delle istruzioni di salto condizionato e incondizionato
D. Mediante ripetute chiamate di procedura

316. L'istruzione FOR nel Linguaggio Assembly:
A. Viene tradotta da una analoga istruzione FOR che permette l’esecuzione ripetuta di istruzioni fino a quando il valore di verità di una espressione logica è vero
B. Non ha una corrispondente istruzione e viene tradotta combinando istruzioni di salto condizionato ed incondizionato
C. Viene tradotta come una chiamata di procedura che permette l’esecuzione ripetuta di istruzioni fino a quando il valore di verità di una espressione logica è vero
D. Viene tradotta scrivendo un numero di copie delle istruzioni da ripetere pari al numero di ripetizioni

317. La traduzione della inizializzazione del ciclo FOR in Linguaggio Assembly è posta:
A. Prima dell'insieme di istruzioni che viene ciclicamente ripetuto
B. All'interno dell'insieme di istruzioni che viene ciclicamente ripetuto
C. All'interno dell'istruzione Assembly che corrisponde a FOR
D. All'uscita del ciclo FOR

318. L'istruzione WHILE nel Linguaggio Assembly:
A. Viene tradotta da una analoga istruzione WHILE che permette l’esecuzione ripetuta di istruzioni fino a quando il valore di verità di una espressione logica è vero
B. Viene tradotta scrivendo un numero di copie delle istruzioni da ripetere pari al numero di ripetizioni
C. Viene tradotta come una chiamata di procedura che permette l’esecuzione ripetuta di istruzioni fino a quando il valore di verità di una espressione logica è vero
D. Non ha una corrispondente istruzione e viene tradotta combinando istruzioni di salto condizionato ed incondizionato

319. La traduzione in Assembly di un ciclo WHILE di un programma in Linguaggio ad Alto Livello determina un ciclo infinito:
A. Quando la condizione logica di controllo del ciclo risulta falsa
B. Mai perché l'istruzione Assembly che corrisponde al WHILE esegue solo un numero finito di cicli
C. Quando manca l'inizializzazione della variabile di controllo del ciclo
D. Quando il WHILE del programma in Linguaggio ad Alto Livello determina un ciclo infinito

320. Nel Linguaggio Macchina per passare alla esecuzione di una procedura è necessario:
A. Scrivere il nome della procedura in Memoria seguito dall'elenco dei relativi parametri con una istruzione load word
B. Scrivere in una istruzione il nome della procedura seguito dall'elenco dei relativi parametri
C. Scrivere il nome della procedura in un registro del processore seguito dall'elenco dei relativi parametri con una istruzione store word
D. Porre l'indirizzo della prima istruzione della procedura nel Program Counter, e salvare l'indirizzo di ritorno all'esecuzione del programma chiamante con una istruzione di salto

321. Nel Linguaggio Macchina l'indirizzo di ritorno dalla chiamata di una procedura è:
A. L'indirizzo dell'ultima istruzione della procedura chiamata
B. L'indirizzo della istruzione del programma chiamante che precede l'istruzione jal di salto alla esecuzione della procedura
C. L'indirizzo della istruzione del programma chiamante successiva alla istruzione jal di salto alla esecuzione della procedura
D. L'indirizzo della prima istruzione della procedura chiamata

322. Nel Linguaggio Macchina MIPS i valori dei parametri vengono passati alla procedura chiamata:
A. Nella esecuzione del programma chiamante scrivendoli nei registri $a0, $a1, $a2, $a3 prima di effettuare il salto alla esecuzione della procedura
B. Nella esecuzione del programma chiamante scrivendoli nei registri $v0, $v1 prima di effettuare il salto alla esecuzione della procedura
C. Nella esecuzione del programma chiamante scrivendoli nel registro $ra prima di effettuare il salto alla esecuzione della procedura
D. Nella esecuzione del programma chiamante scrivendoli nei registri $t e $s durante l'esecuzione della procedura

323. Nel Linguaggio Macchina MIPS i valori calcolati dalla procedura chiamata vengono passati al programma chiamante:
A. Nella esecuzione della procedura scrivendoli nel registro $ra prima di effettuare il salto di ritorno al programma chiamante
B. Nella esecuzione della procedura scrivendoli nei registri $a0, $a1, $a2, $a3 durante l'esecuzione della procedura
C. Nella esecuzione della procedura scrivendoli nei registri $v0, $v1 durante l'esecuzione della procedura
D. Nella esecuzione della procedura scrivendoli nei registri $t e $s durante l'esecuzione della procedura

324. Nel Linguaggio Macchina MIPS l'indirizzo di ritorno al programma chiamante è salvato:
A. Nella esecuzione della procedura scrivendolo nel registro $v0 prima di effettuare il salto di ritorno alla esecuzione del programma chiamante
B. Nella esecuzione del programma chiamante scrivendolo nel registro $a0, prima di effettuare il salto alla esecuzione
C. della procedura
D. Nel registro riservato $ra nella esecuzione della istruzione jal che effettua il salto alla procedura

325. Nella esecuzione del programma chiamante scrivendolo in uno dei registri $t e $s, prima di effettuare il salto alla esecuzione della procedura
A. Nel Linguaggio Macchina MIPS il ritorno alla esecuzione del programma chiamante è effettuato:
B. Da una istruzione contenuta nel call-stack
C. Mediante l'esecuzione della istruzione jal che alla fine della procedura effettua il salto di ritorno al programma chiamante
D. Mediante l'esecuzione della istruzione j che alla fine della procedura effettua il salto di ritorno al programma chiamante

326. Mediante l'esecuzione della istruzione jr che alla fine della procedura effettua il salto di ritorno al programma chiamante
A. Le chiamate di procedura annidate sono gestite:
B. Dal Compilatore
C. Utilizzando una struttura dati di Tipo Array, ponendo le informazioni relative ad ogni procedura negli elementi dell'Array
D. Utilizzando i registri del processore

327. Utilizzando una struttura dati di Tipo stack, scrivendo le informazioni relative ad ogni procedura in un segmento, detto frame, delle locazioni di Memoria assegnate allo stack
A. L'errore di call stack overflow avviene quando:
B. Il numero delle chiamate di procedura effettuate non può essere rappresentato con 32 bit
C. Si esaurisce lo spazio di Memoria assegnato alla struttura dati call stack
D. Una procedura chiamata calcola un valore che non può essere rappresentato con 32 bit nel call stack

328. Il numero dei parametri della procedura non può essere rappresentato con 5 bit nel call stack
A. Nel Linguaggio macchina MIPS il Formato e la Modalità di Indirizzamento dell'istruzione jal sono:
B. Formato di Tipo I e Indirizzamento relativo al Program Counter
C. Formato di Tipo R e Indirizzamento immediato
D. Formato di Tipo J e Indirizzamento pseudodiretto

329. Formato di Tipo J e Indirizzamento tramite registro
A. Nel Linguaggio macchina MIPS il Formato e la Modalità di Indirizzamento dell'istruzione jr sono:
B. Formato di Tipo R e Indirizzamento immediato
C. Formato di Tipo J e Indirizzamento pseudodiretto
D. Formato di Tipo R e Indirizzamento tramite registro

330. Formato di Tipo I e Indirizzamento relativo al Program Counter
A. L'esecuzione dell'istruzione Assembly MIPS slt $t0, $s1, $s2:
B. Pone nel registro $t0 il più piccolo dei valori contenuti nei registri $s1 e $s2
C. Salta all'indirizzo contenuto nel registro $t0 se il valore contenuto nel registro $s1 è minore del valore contenuto nel registro $s2, altrimenti continua in sequenza
D. Pone nel registro $t0 il valore 1 se, in Notazione in complemento a 2, il valore contenuto nel registro $s1 è minore del valore contenuto nel registro $s2 , altrimenti pone 0

331. Pone nel registro $t0 il più grande dei valori contenuti nei registri $s1 e $s2
A. La traduzione in Linguaggio Macchina MIPS dell'istruzione slt $s1, $t3, $t4 ha:
B. Formato di Tipo R e Indirizzamento tramite registro
C. Formato di Tipo R e Indirizzamento immediato
D. Formato di Tipo I e Indirizzamento relativo al Program Counter

332. Formato di Tipo J e Indirizzamento pseudodiretto
A. Il Tipo di dato unsigned è rappresentato da:
B. Sequenze binarie nella Notazione in complemento a 2
C. Sequenze binarie nella Notazione posizionale pesata
D. Sequenze binarie nella Notazione in modulo e segno

333. Sequenze binarie nella Notazione in virgola mobile
A. Nella rappresentazione con 32 bit del Tipo di dato unsigned il bit più a sinistra è:
B. Associato al peso negativo -231
C. Associato al peso positivo 231
D. Il bit di segno separato dal modulo

334. Sempre uguale a 0
A. I valori unsigned rappresentati da sequenze di 32 bit sono compresi:
B. Nell'intervallo [-128, 127]
C. Nell'intervallo [-231, 231-1]
D. Nell'intervallo [0, 232-1 ]

335. Nell'intervallo [0, 127 ]
A. La regola che segnala l'Overflow per la somma di interi con segno nella Notazione in Complemento a 2 in base agli ultimi due riporti calcolati:
B. Si applica anche per gli interi unsigned
C. Si applica solo per gli interi positivi unsigned
D. Si applica solo per gli interi negativi unsigned

336. Non si applica per gli interi unsigned
A. Le istruzioni Assembly MIPS con Codici Operativi addu e subu eseguono:
B. Addizione e sottrazione di operandi unsigned contenuti in due registri del processore
C. Addizione e sottrazione di operandi con segno contenuti in due registri del processore
D. Addizione e sottrazione di operandi unsigned contenuti in Memoria

337. Addizione e sottrazione di operandi con segno contenuti in Memoria
A. Per le istruzione Logiche and, or il Linguaggio Assembly:
B. Ha le corrispondenti istruzioni per operandi unsigned andu, oru
C. Ha la corrispondente istruzione andu per operandi unsigned solo per l'operatore AND
D. Non ha le corrispondenti istruzioni per operandi unsigned perché le operazioni sono eseguite bit a bit

338. Ha la corrispondente istruzione oru per operandi unsigned solo per l'operatore OR
A. L'esecuzione dell'istruzione Assembly MIPS sltu $t0, $s1, $s2:
B. Pone nel registro $t0 il valore 1 se, in Notazione posizionale pesata senza segno, il valore contenuto nel registro $s1 è minore del valore contenuto nel registro $s2 , altrimenti pone 0
C. Salta all'indirizzo contenuto nel registro $t0 se il valore unsigned contenuto nel registro $s1 è minore del valore unsigned contenuto nel registro $s2, altrimenti continua in sequenza
D. Pone nel registro $t0 il più piccolo dei valori unsigned contenuti nei registri $s1 e $s2

339. Pone nel registro $t0 il più grande dei valori unsigned contenuti nei registri $s1 e $s2
A. L'esecuzione dell'istruzione Assembly MIPS slti $s1, $t2, 35:
B. Sottrae al contenuto del registro di indirizzo $t2 il valore costante 35, e pone il risultato in $s1
C. Stabilisce se il contenuto del registro di indirizzo $t2 è minore del valore costante 35, e pone in $s1 il valore 1 se la relazione è vera altrimenti pone 0
D. Stabilisce se il contenuto del registro di indirizzo $s1 è minore del valore costante 35, e pone in $t2 il valore 1 se la relazione è vera altrimenti pone 0

340. Stabilisce se il contenuto del registro di indirizzo $t2 è minore del valore costante 35, e pone in $s1 il contenuto di
A. $t2 se la relazione è vera altrimenti pone 35
B. L'istruzione in Linguaggio Macchina MIPS che traduce set on less then immediato ha:
C. Formato di Tipo I e Indirizzamento pseudodiretto
D. Formato di Tipo I e Indirizzamento tramite Base e Offset

341. Formato di Tipo R e Indirizzamento immediato
A. Formato di Tipo I e Indirizzamento immediato
B. Il valore della costante presente nell'istruzione Assembly MIPS slti $s1, $t2, -50 viene scritto:
C. In Notazione in modulo e segno nei 16 bit del campo immediato del formato di Tipo I
D. In Notazione in complemento a 2 nei 16 bit del campo immediato del formato di Tipo I

342. In Notazione posizionale pesata nei 16 bit del campo immediato del formato di Tipo I
A. Nel registro destinazione del formato di Tipo I
B. L'operando costante dell'istruzione slti $s0, $t1, -70 si ottiene:
C. Effettuando l'estensione del segno a 32 bit della sequenza di 16 bit nel campo immediato che rappresenta il valore costante
D. Completando a 32 bit la sequenza di 16 bit nel campo immediato, che rappresenta il valore costante, aggiungendo sempre bit tutti uguali a 0

343. Leggendo il valore contenuto nel registro $t1
A. Leggendo il valore contenuto nel registro $s0
B. L'operando costante dell'istruzione set on less then immediato ha un valore compreso:
C. Tra il minimo 0 ed il massimo 232-1
D. Tra il minimo negativo -231 ed il massimo positivo 231-1

344. Tra il minimo 0 ed il massimo 216-1
A. Tra il minimo negativo -215 ed il massimo positivo 215-1
B. L'operando costante dell'istruzione ori $s0, $t2, 25 si ottiene:
C. Leggendo il valore contenuto nel registro $t1
D. Effettuando l'estensione del segno a 32 bit della sequenza di 16 bit nel campo immediato che rappresenta il valore costante

345. Completando a 32 bit la sequenza di 16 bit nel campo immediato, che rappresenta il valore costante, con bit tutti uguali a 0
A. Leggendo il valore contenuto nel registro $s0
B. Le istruzioni in Linguaggio Macchina MIPS che traducono le istruzioni logiche andi e ori:
C. Hanno Formato di Tipo R e Indirizzamento immediato
D. Hanno Formato di Tipo I e Indirizzamento tramite Base e Offset

346. Hanno Formato di Tipo I e Indirizzamento immediato
A. Hanno Formato di Tipo I e Indirizzamento pseudodiretto
B. L'istruzione Assembly MIPS ori $s0, $t3, 9 effettua:
C. L'OR bit a bit tra il valore contenuto nel registro $s0 e il valore 9 rappresentato nei 16 bit del campo immediato completato a 32 bit aggiungendo tutti bit uguali a 0, il risultato è posto in $t3
D. L'OR bit a bit tra il valore contenuto nel registro $t3 e il valore 9 rappresentato nei 16 bit del campo immediato completato a 32 bit aggiungendo tutti bit uguali a 0, il risultato è posto in $s0

347. Il confronto tra il valore contenuto nel registro $t3 e il valore 9 rappresentato nei 16 bit del campo immediato, e pone in $s0 il valore minore
A. Il confronto tra il valore contenuto nel registro $t3 e il valore 9 rappresentato nei 16 bit del campo immediato, e pone in $s0 il valore maggiore
B. Un valore la cui rappresentazione richiede più di 16 bit significativi:
C. Può essere l'operando immediato di una istruzione Assembly MIPS con Formato di Tipo I solo se è un numero positivo
D. Non può essere l'operando immediato di una istruzione Assembly MIPS con Formato di Tipo I

348. Può essere l'operando immediato di una istruzione Assembly MIPS con Formato di Tipo I utilizzando la Notazione in modulo e segno
A. Può essere l'operando immediato di una istruzione Assembly MIPS con Formato di Tipo I solo per le istruzioni con operandi unsigned
B. I caratteri rappresentati nella codifica ASCII sono:
C. In totale 64 caratteri stampabili
D. In totale 52 costituiti da 26 simboli dell'alfabeto inglese minuscolo e maiuscolo

349. In totale 32 costituiti dai 26 caratteri dell'alfabeto inglese minuscolo e 6 simboli di punteggiatura
A. In totale 128 costituiti da 95 caratteri stampabili e 33 simboli non stampabili
B. Il codice ASCII utilizza sequenze binarie:
C. Di lunghezza 16
D. Di lunghezza 32

350. Di lunghezza 7
A. Di lunghezza 8
B. Il codice ASCII esteso utilizza sequenze binarie:
C. Di lunghezza 16
D. Di lunghezza 8

351. Di lunghezza 32
A. Di lunghezza 7
B. I codici ASCII sono compresi tra:
C. Il minimo -64 e il massimo 63
D. Il minimo 0 e il massimo 63

352. Il minimo -128 e il massimo 127
A. Il minimo 0 e il massimo 127
B. Il sistema di codifica Unicode:
C. Include solo i codici ASCII dei caratteri stampabili
D. Non include la codifica ASCII

353. Include solo i codici ASCII dei caratteri non stampabili
A. Include la codifica ASCII come sottinsieme
B. Il sistema di codifica Unicode UTF-8 utilizza:
C. Sequenze composte da un numero variabile di Byte per codificare i caratteri
D. Solo sequenze di un Byte per rappresentare i caratteri

354. Sempre sequenze di 32 bit per rappresentare i caratteri
A. Codici sia negativi che positivi per rapresentare i caratteri
B. Il sistema di codifica Unicode UTF-16 utilizza sequenze binarie:
C. Di lunghezza 32
D. Di lunghezza 8

355. Di lunghezza 16
A. Di lunghezza 7
B. L'assegnamento val='A' con val corrispondente al registro $s1 si traduce in Assembly MIPS:
C. Con l'istruzione add $s1, $zero, 'A'
D. Con l'istruzione ori $s1, $zero, 65

356. Con l'istruzione ori $s1, $zero, 'A'
A. Con l'istruzione ori $zero, $s1, 65
B. L'operazione effettuata dall'esecuzione dell'istruzione lb $t0, 30($s1) è:
C. Scrivere la sequenza di 8 bit in una locazione di Memoria dopo averla letta negli 8 bit meno significativi del registro
D. $t0

357. Leggere la sequenza di 8 bit contenuti in una locazione di Memoria e scriverla negli 8 bit meno significativi del registro $t0 di 32 bit, con estensione del segno a 32 bit
A. Leggere la sequenza di 16 bit contenuti in due locazioni successive di Memoria e scriverla nei 16 bit meno significativi del registro $t0 di 32 bit, ponendo a 0 il valore dei rimanenti bit
B. Scrivere 16 bit in due locazioni successive di Memoria dopo averli letti dai 16 bit meno significativi del registro $t0
C. L'operazione effettuata dall'esecuzione dell'istruzione lhu $t0, 30($s1) è:
D. Leggere la sequenza di 16 bit contenuti in due locazioni successive di Memoria e scriverla nei 16 bit meno significativi del registro $t0 di 32 bit, ponendo a 0 il valore dei rimanenti bit

358. Scrivere la sequenza di 16 bit in due locazioni successive di Memoria dopo averla letta nei 16 bit meno significativi del registro $t0
A. Leggere la sequenza di 8 bit contenuti in una locazione di Memoria e scriverla negli 8 bit meno significativi del registro $t0 di 32 bit, con estensione del segno a 32 bit
B. Scrivere la sequenza di 8 bit in una locazione di Memoria dopo averla letta negli 8 bit meno significativi del registro
C. $t0
D. L'operazione effettuata dall'esecuzione dell'istruzione sb $t0, 30($s1) è:

359. Leggere la sequenza di 8 bit contenuti in una locazione di Memoria e scriverla negli 8 bit meno significativi del registro $t0 di 32 bit, con estensione del segno a 32 bit
A. Scrivere la sequenza di 8 bit in una locazione di Memoria dopo averla letta negli 8 bit meno significativi del registro
B. $t0
C. Leggere la sequenza di 16 bit contenuti in due locazioni successive di Memoria e scriverla nei 16 bit meno significativi del registro $t0 di 32 bit, ponendo a 0 il valore dei rimanenti bit
D. Scrivere 16 bit in due locazioni successive di Memoria dopo averli letti dai 16 bit meno significativi del registro $t0

360. L'operazione effettuata dall'esecuzione dell'istruzione sh $t0, 30($s1) è:
A. Scrivere la sequenza di 8 bit in una locazione di Memoria dopo averla letta negli 8 bit meno significativi del registro
B. $t0
C. Leggere la sequenza di 16 bit contenuti in due locazioni successive di Memoria e scriverla nei 16 bit meno significativi del registro $t0 di 32 bit, ponendo a 0 il valore dei rimanenti bit
D. Leggere la sequenza di 8 bit contenuti in una locazione di Memoria e scriverla negli 8 bit meno significativi del registro $t0 di 32 bit, con estensione del segno a 32 bit

361. Scrivere la sequenza di 16 bit in due locazioni successive di Memoria dopo averla letta nei 16 bit meno significativi del registro $t0
A. La traduzione in Linguaggio Macchina dell'istruzione lbu utilizza:
B. Il Formato di Tipo I e l'Indirizzamento tramite relativo al Program Counter
C. Il Formato di Tipo R e l'Indirizzamento Immediato
D. Il Formato di Tipo I e l'Indirizzamento immediato

362. Il Formato di Tipo I e l'Indirizzamento tramite Base e Offset
A. La traduzione in Linguaggio Macchina dell'istruzione sh utilizza:
B. Il Formato di Tipo R e l'Indirizzamento Immediato
C. Il Formato di Tipo I e l'Indirizzamento tramite Base e Offset
D. Il Formato di Tipo I e l'Indirizzamento immediato

363. Il Formato di Tipo I e l'Indirizzamento tramite relativo al Program Counter
A. La Modalità di Indirizzamento di lh fornisce:
B. L'idirizzo della prima delle due locazini di Memoria in cui scrivere il dato rappresentato da 16 bit
C. L'idirizzo della locazine di Memoria da cui leggere il dato rappresentato da 8 bit
D. L'idirizzo della prima delle due locazini di Memoria da cui leggere il dato rappresentato da 16 bit

364. L'idirizzo della locazine di Memoria in cui scrivere il dato rappresentato da 8 bit
A. La Modalità di Indirizzamento di sb fornisce:
B. L'idirizzo della locazine di Memoria da cui leggere il dato rappresentato da 8 bit
C. L'idirizzo della prima delle due locazini di Memoria in cui scrivere il dato rappresentato da 16 bit
D. L'idirizzo della locazine di Memoria in cui scrivere il dato rappresentato da 8 bit

365. L'idirizzo della prima delle due locazini di Memoria da cui leggere il dato rappresentato da 16 bit
A. Le istruzioni lhu, sh possono essere utilizzate:
B. Per il trasferimento di caratteri Unicode a 16 bit e di valori dichiarati short
C. Per il trasferimento di caratteri ASCII
D. Per il trasferimento di valori dichiarati int

366. Per il trasferimento di valori dichiarati long
A. Le istruzioni lbu, sb possono essere utilizzate:
B. Per il trasferimento di valori dichiarati int
C. Per il trasferimento di caratteri Unicode a 16 bit e di valori dichiarati short
D. Per il trasferimento di caratteri ASCII a 7 e 8 bit e di valori dichiarati byte

367. Per il trasferimento di valori dichiarati long
A. La traduzione in Assembly MIPS dell'assegnamento val = A[6] con $s3 registro Base dell'Array di INTERI A[] e assegnado il registro $t0 alla variabile val è data:
B. Dell'istruzione sw $t0, 24 ($s3)
C. Dell'istruzione lw $t0, 6 ($s3)
D. Dell'istruzione lw $s3, 24 ($t0)

368. Dell'istruzione lw $t0, 24 ($s3)
A. La traduzione in Assembly MIPS dell'assegnamento A[3] = val con $s3 registro Base dell'Array di INTERI A[] e assegnado il registro $t0 alla variabile val è data:
B. Dell'istruzione sw $s3, 24 ($t0)
C. Dell'istruzione lw $t0, 24 ($s3)
D. Dell'istruzione sw $t0, 12 ($s3)

369. Dell'istruzione sw $t0, 3 ($s3)
A. La traduzione in Assembly MIPS dell'assegnamento val = testo[9] con $t1 registro Base dell'Array di caratteri ASCII testo[] e assegnado il registro $s5 alla variabile val è data:
B. Dell'istruzione lbu $t1, 9 ($s5)
C. Dell'istruzione sb $s5, 9 ($t1)
D. Dell'istruzione lbu $s5, 9 ($t1)

370. Dell'istruzione lbu $s5, 36 ($t1)
A. La traduzione in Assembly MIPS dell'assegnamento testo[9] = val con $t1 registro Base dell'Array di caratteri ASCII testo[] e assegnado il registro $s5 alla variabile val è data:
B. Dell'istruzione lbu $s5, 9 ($t1)
C. Dell'istruzione sb $t1, 9 ($s5)
D. Dell'istruzione sb $s5, 9 ($t1)

371. Dell'istruzione sb $s5, 36 ($t1)
A. La traduzione in Assembly MIPS dell'assegnamento val = A[8] con $t4 registro Base dell'Array di caratteri Unicode a 16 bit A[] e assegnado il registro $s2 alla variabile val è data:
B. Dall'istruzione lbu $s2, 8 ($t4)
C. Dall'istruzione sh $s2, 16 ($t4)
D. Dall'istruzione sw $t4, 32 ($s2)

372. Dall'istruzione lhu $s2, 16 ($t4)
A. La traduzione in Assembly MIPS dell'assegnamento A[8] = val con $t4 registro Base dell'Array di caratteri Unicode a 16 bit A[] e assegnado il registro $s2 alla variabile val è data:
B. Dall'istruzione lbu $s2, 8 ($t4)
C. Dall'istruzione sh $s2, 16 ($t4)
D. Dall'istruzione sw $t4, 32 ($s2)

373. Dall'istruzione lhu $s2, 16 ($t4)
A. Il calcolo dell'indirizzo dell'elemento A[k] di un Array di numeri INTERI si effettua:
B. Moltiplicando l'indice k per 4 e addizionando il valore ottenuto al contenuto del registro Base dell'Array
C. Addizionando il valore dell'indice k al contenuto del registro Base dell'Array
D. Moltiplicando l'indice k per 2 e addizionando il valore ottenuto al contenuto del registro Base dell'Array

374. Moltiplicando l'indice k per 4
A. La moltiplicazione per 4 dell'indice k si effettua:
B. Mediante l'istruzione sll di shift logico a sinistra indicando uno shift di 4 posizioni
C. Mediante l'istruzione sld di shift logico a destra indicando uno shift di 2 posizioni
D. Mediante l'istruzione sll di shift logico a sinistra indicando uno shift di 2 posizioni

375. Mediante l'istruzione sld di shift logico a destra indicando uno shift di 4 posizioni
A. Il calcolo dell'indirizzo dell'elemento A[k] di un Array che implementa una stringa di CARATTERI ASCII si effettua:
B. Addizionando il valore dell'indice k al contenuto del registro Base dell'Array
C. Moltiplicando l'indice k per 2 e addizionando il valore ottenuto al contenuto del registro Base dell'Array
D. Moltiplicando per 2 il contenuto del registro Base dell'Array

376. Moltiplicando l'indice k per 4 e addizionando il valore ottenuto al contenuto del registro Base dell'Array
A. Il calcolo dell'indirizzo dell'elemento A[k] di un Array che implementa una stringa di CARATTERI Unicode a 16 bit si effettua:
B. Moltiplicando l'indice k per 4 e addizionando il valore ottenuto al contenuto del registro Base dell'Array
C. Moltiplicando l'indice k per 2
D. Addizionando il valore dell'indice k al contenuto del registro Base dell'Array

377. Moltiplicando l'indice k per 2 e addizionando il valore ottenuto al contenuto del registro Base dell'Array
A. Le cifre significative della rappresentazione di un numero sono:
B. Le cifre che occupano le posizioni più a sinistra e più a destra
C. Le cifre a destra della virgola
D. Le cifre a sinistra della virgola

378. Le cifre che contribuiscono alla determinazione del valore del numero
A. Rappresentando i numeri frazionari con sequenze di lunghezza fissata si può:
B. Rappresentare con esattezza tutti i numeri compresi tra il minimo ed il massimo rappresentabili
C. Rappresentare con esattezza un sottoinsieme finito di numeri nell'intervallo compreso tra il minimo ed il massimo rappresentabili, e con errore di arrotondamento i rimanenti infiniti numeri in tale intervallo
D. Rappresentare con esattezza solo i numeri interi compresi tra il minimo ed il massimo rappresentabili

379. Rappresentare con esattezza solo i numeri razionali compressi tra il minimo ed il massimo rappresentabili, e con errore di arrotondamento gli irrazionali
A. L'errore di underflow si verifica quando:
B. Il numero da rappresentare ha modulo minore del massimo modulo rappresentabile
C. Il numero da rappresentare ha modulo maggiore del minimo modulo rappresentabile
D. Il numero da rappresentare ha modulo minore del minimo modulo rappresentabile

380. Il numero da rappresentare ha modulo maggiore del massimo modulo rappresentabile
A. Se il minimo modulo rappresentabile è 0.01 ed il massimo è 999 l'errore di underflow si verifica quando il valore da rappresentare è:
B. Esterno all'intervallo [-999 , 999]
C. Esterno all'intervallo [-0.01 , 0.01]
D. Compreso nell'intervallo (-999 , 999)

381. Compreso nell'intervallo (-0.01 , 0.01)
A. La rappresentazione troncata con errore di arrotondamento di un numero frazionario si ottiene:
B. Sempre eliminando la parte frazionaria del numero
C. Sostituendo cifre meno significative del numero con il valore 0
D. Sempre eliminando la parte intera del numero

382. Sempre considerando solo una cifra dopo la virgola
A. L'errore di arrotondamento è:
B. Minore del valore del peso associato alla cifra meno significativa della rappresentazione troncata
C. Maggiore del valore del peso associato alla cifra meno significativa della rappresentazione troncata
D. Uguale ad uno

383. Minore di 0.001
A. La misura dell'errore di arrotondamento della rappresentazione troncata 79854,84000 del numero 79854,84219 è data:
B. Dal valore 1
C. Dal valore 0,84
D. Dal valore 0,85219

384. Dal valore 0,00219
A. La misura dell'errore di arrotondamento della rappresentazione troncata 79854,84000 del numero 79854,84219 è limitata superiormente:
B. Dal valore 10-1 = 0,1
C. Dal valore 10-3= 0,001
D. Dal valore 10-2 = 0,01

385. Dal valore 105 = 0.00001
A. Il numero in Base 10 rappresentato in virgola fissa dalla sequenza 53498,03 è rappresentato in Notazione scientifica in virgola mobile:
B. Dalla sequenza 5349803E-2
C. Dalla sequenza 5,349803E+4
D. Dalla sequenza 0,5349803E+5

386. Dalla sequenza 0,05349803E+6
A. In Notazione polarizzata il valore del numero rappresentato dalla sequenza binaria si ottiene:Calcolando il valore in modulo e segno
B. Sottraendo la costante di polarizzazione dal valore della sequenza binaria calcolato in Notazione posizionale pesata
C. Addizionando la costante di polarizzazione al valore della sequenza binaria calcolata in Notazione posizionale pesata
D. Sottraendo la costante di polarizzazione al valore della sequenza binaria calcolato in Notazione in complemento a 2

387. Nello standard IEEE 754 le cifre significative del numero rapresentato si ottengono:
A. Considerando la sequenza binaria contenuta nel campo mantissa come parte intera, e 0 come parte frazionaria
B. Considerando 0 come parte intera, e la sequenza binaria contenuta nel campo mantissa come parte frazionaria
C. In base alla sequenza binaria contenuta nel campo esponente
D. Considerando un bit sottinteso uguale a 1 come parte intera, e la sequenza binaria contenuta nel campo mantissa come parte frazionaria

388. Nello standard IEEE 754 precisione SINGOLA le 24 cifre binarie significative corrispondono:
A. A 12 cifre decimali significative
B. A 15 cifre decimali significative
C. A 7 cifre decimali significative
D. A 11 cifre decimali significative

389. La notazione in doppia precisione consente:
A. Di eliminare l'errore di underflow e di estendere l'intervallo del minimo e massimo modulo rappresentabile
B. Di eliminare l'errore di arrotondamento e di estendere l'intervallo del minimo e massimo modulo rappresentabile
C. Di estendere l'intervallo del minimo e massimo modulo rappresentabile aumentando l'esponente, e di ridurre l'errore di arrotondamento aumentando il numero di cifre significative
D. Di rappresentare tutte le cifre significative del numero

390. Nello standard IEEE 754 precisione DOPPIA le 53 cifre binarie significative corrispondono:
A. A 11 cifre decimali significative
B. A 7 cifre decimali significative
C. A 23 cifre decimali significative
D. A 15 cifre decimali significative

391. Quando si verifica l'errore di underflow:
A. Il valore del numero viene approssimato con il valore massimo rappresentabile
B. Il valore del numero viene approssimato con il numero 0
C. Il valore del numero viene approssimato con il numero -1
D. Il valore del numero viene approssimato con il numero +1

392. Nello standard IEEE 754 precisione SINGOLA il massimo modulo rappresentabile è:
A. Circa 232
B. Circa 2 miliardi
C. Circa 4 miliardi
D. Circa 3.4x1038

393. Nello standard IEEE 754 precisione DOPPIA il massimo modulo rappresentabile è:
A. Circa 4 miliardi
B. Circa 2 miliardi
C. Circa 1.7x10308
D. Circa 264

394. Le istruzioni aritmetiche Assembly MIPS per operandi rappresentati in virgola mobile hanno codice operativo:
A. Con un numero doppio di simboli per la doppia precisione
B. Uguale alle istruzioni con operandi interi
C. Con suffisso .s per la singola precisione e .d per la doppia precisione
D. Con prefisso .s per la singola precisione e .d per la doppia precisione

395. Le istruzioni Assembly MIPS per operandi rappresentati in virgola mobile utilizzano:
A. Solo i registri $s
B. Gli stessi registri delle istruzioni con operandi interi
C. I registri riservati $a e $v
D. I 32 registri aggiuntivi indicati con le lettere $f

396. I numeri dichiarati float con più di 7 cifre decimali significative sono rappresentati:
A. Con 32 bit in notazione in complemento a 2
B. Con 32 bit nello standard IEEE 754 singola precisione con errore di arrotondamento
C. Con 64 bit nello standard IEEE 754 doppia precisione con errore di arrotondamento
D. Con 32 bit nello standard IEEE 754 singola precisione sempre in maniera esatta

397. I numeri dichiarati double con più di 15 cifre decimali significative sono rappresentati:
A. Con 64 bit nello standard IEEE 754 doppia precisione sempre in maniera esatta
B. Con 64 bit nello standard IEEE 754 doppia precisione con errore di arrotondamento
C. Con 32 bit nello standard IEEE 754 singola precisione con errore di arrotondamento
D. Con 64 bit in notazione in complemento a 2

398. Nello standard IEEE 754 il valore MASSIMO dell'esponente polarizzato con mantissa 0 è riservato a rappresentare:
A. L'uso della notazione in complemento a 2
B. Il valore 0
C. Il valore infinito, che segnala la situazione anomale di un valore non rappresentabile per errore di overflow
D. Il minimo modulo rappresentabile

399. Nello standard IEEE 754 il valore MASSIMO dell'esponente polarizzato con mantissa diversa da 0 è riservato a rappresentare:
A. Il valore NaN (not a number) che segnala la situazione anomale di un calcolo non ammissibile come la divisione per zero
B. L'uso della notazione in complemento a 2
C. Il massimo modulo rappresentabile
D. Il valore 0

400. Nello standard IEEE 754 il numero 0 è rappresentato da una sequenza:
A. Con bit tutti uguali a 1
B. Con mantissa 0 ed esponente 0
C. Con mantissa 0 ed esponente dato dalla sequenza di tutti bit uguali ad 1
D. Con esponente 0 e mantissa data dalla sequenza di tutti bit uguali ad 1

401. Nello standard IEEE 754 il valore 0 dell'esponente polarizzato con mantissa diversa da 0 è riservato a rappresentare:
A. L'uso della notazione dei numeri denormalizzati che restringe l'intervallo dei numeri per i quali si ha l'errore di underflow
B. L'uso della notazione in complemento a 2
C. Il valore 0
D. Il massimo modulo rappresentabile

402. La conversione di una sequenza binaria nella corrispondente rappresentazione ottale si può effettuare direttamente:
A. Calcolando il valore della sequenza binaria utilizzando come pesi potenze della base 8
B. Suddividendo la sequenza binaria in gruppi di 4 simboli a partire da destra (cifre meno significative), e sostituendo ad ogni gruppo il corrispondente simbolo della base 16
C. Suddividendo la sequenza binaria in gruppi di 3 simboli a partire da destra (cifre meno significative), e sostituendo ad ogni gruppo il corrispondente simbolo della base 8
D. Calcolando il valore in base 10 e determinando la sequenza corrispondente in base 8

403. La conversione di una sequenza binaria nella corrispondente rappresentazione esadecimale si può effettuare direttamente:
A. Suddividendo la sequenza binaria in gruppi di 3 simboli a partire da destra (cifre meno significative), e sostituendo ad ogni gruppo il corrispondente simbolo della base 8
B. Suddividendo la sequenza binaria in gruppi di 4 simboli a partire da destra (cifre meno significative), e sostituendo ad ogni gruppo il corrispondente simbolo della base 16
C. Calcolando il valore della sequenza binaria utilizzando come pesi potenze della base 16
D. Calcolando il valore in base 10 e determinando la sequenza corrispondente in base 16

404. Una pseudoistruzione è:
A. Una istruzione del Linguaggio Assembly non implementata a livello Hardware, che esegue operazioni mediante altre istruzioni Assembly implementate
B. La traduzione in Linguaggio Macchina della corrispondente istruzione in Linguaggio Assembly
C. L'istruzione in Linguaggio ad alto Livello che corrisponde ad una istruzione in Linguaggio Assembly
D. Una istruzione non sintatticamente corretta che viene segnalata come errore dal programma traduttore Assembler

405. Il codice oggetto contiene:
A. Il programma in Linguaggio ad Alto Livello scritto dall'utente
B. La traduzione del programma in Linguaggio Assembly fornita dal Compilatore
C. Il programma eseguibile fornito dal Linker
D. La traduzione del programma in Linguaggio Macchina fornita dall'Assembler

406. Il codice oggetto di un programma che utilizza una libreria deve:
A. Essere passato al programma Loader per la traduzione in Linguaggio Macchina
B. Essere passato all'Assembler per la traduzione in Linguaggio Macchina
C. Essere passato al Compilatore per la traduzione in Assembly
D. Essere passato al programma Linker che effettua i collegamenti tra il codice oggetto del programma e il codice oggetto delle procedure che utilizza

407. Il Linker effettua:
A. Il caricamento in Memoria del programma eseguibile
B. I collegamenti tra il codice oggetto del programma e il codice oggetto delle procedure che utilizza
C. L'esecuzione del programma caricato in Memoria
D. La traduzione del programma in Linguaggio Macchina

408. Il Loader effettua:
A. La traduzione del programma in Linguaggio Assembly
B. Il caricamento del programma eseguibile in Memoria, l'assegnazione dello spazio alle strutture dati utilizzate e le inizializzazioni necessarie ad avviarne l'esecuzione
C. La traduzione del programma in Linguaggio Macchina
D. I collegamenti tra il programma e le procedure

409. L'approccio alla compilazione basato sul caricamento dinamico delle librerie effettua
A. La chiamata di procedura nel programma principale
B. I collegamenti tra il codice oggetto del programma e il codice oggetto di una procedura solo quando la procedura è chiamata in fase di esecuzione
C. La traduzione in Linguaggio Macchina della procedura chiamata
D. La traduzione in Linguaggio Assembly della procedura chiamata

410. Il programma eseguibile è prodotto:
A. Dal Linker
B. Dall'Assembler
C. Dal programmatore
D. Dal Sistema Operativo

411. Il Bytecode Java è:
A. Eseguibile solo sull'Hardware della Java Virtual Machine
B. Eseguibile solo mediante un web browser
C. Eseguibile su qualunque computer che disponga di un Interprete Java
D. Direttamente eseguibile su qualunque computer

412. La Java Virtual Machine è:
A. Il programma che carica il bytecode Java in Memoria
B. L'Hardware che esegue il bytecode Java
C. La macchina astratta capace di eseguire il bytecode Java
D. L'Hardware che traduce il Bytecode Java in Linguaggio macchina

413. Un Interprete Java è:
A. Uno specifico dispositivo Hardware interno al computer che emula la Java Virtual Machine
B. Un programma Software che esegue il bytecode Java emulando la Java Virtual Machine su una specifica piattaforma
C. Una implementazione Harware dell'Architettura della Java Virtual Machine
D. Il programma scritto dall'utente in Linguaggio ad Alto Livello Java

414. Un sistema dinamico ha la caratteristica detta feedback (retroazione) quando:
A. Il comportamento del sistema descritto dallo stato in un istante di tempo non influenza il comportamento nell'istante di tempo successivo
B. Il comportamento del sistema descritto dallo stato in un istante di tempo rimane invariato nell'istante di tempo successivo
C. Il comportamento del sistema descritto dallo stato in un istante di tempo è uguale all'output del sistema nell'istante di tempo successivo
D. Il comportamento del sistema descritto dallo stato in un istante di tempo influenza il comportamento nell'istante di tempo successivo

415. L'Algebra di Boole è:
A. L'insieme degli elementi {0, 1}
B. L'insieme degli elementi 'vero' e 'falso'
C. Una struttura di calcolo definita da un Dominio costituito da due elemeti e dagli operatori AND, OR e NOT
D. Un insieme di due elementi cui si attribuiscono i valori di verità 'vero' e 'falso'

416. Le funzioni Booleane sono:
A. Solo le funzioni di due variabili AND e OR
B. Tutte le funzioni binarie di variabili binarie
C. Le funzioni che calcolano le operazioni aritmetiche con due operandi
D. Solo le funzioni AND, OR e NOT

417. L'operatore XOR assume valore 'vero' solo quando:
A. Almeno uno dei valori delle variabili è 'vero'
B. Uno solo dei valori delle variabili è 'vero'
C. Entrambe le variabili assumono il valore 'vero'
D. Entrambe le variabili assumono il valore 'falso'

418. Una porta logica è:
A. Un dispositivo che memorizza il segnale di ingresso
B. Un circuito digitale capace di calcolare una qualsiasi funzione Booleana
C. Un dispositivo che amplifica il segnale di ingresso
D. Un circuito digitale capace di calcolare un operatore logico dell'Algebra di Boole

419. La valutazione di una Espressione Booleana è rappresentata:
A. Dalle Tavole di verità degli operatori logici presenti nell'Espressione
B. Dalla Tavola di verità della funzione calcolata dall'Espressione
C. Dal valore di verità assunto dalle variabili dell'Espressione
D. Dal numero di variabili dell'Espressione che assumono valore "vero"

420. Due Espressioni Booleane sono equivalenti quando:
A. Hanno la stessa lunghezza
B. Hanno lo stesso numero di operatori AND, OR e NOT
C. Le loro valutazioni forniscono Tavole di verità uguali
D. Hanno le stesse variabili

421. Le proprietà degli operatori logici rappresentate da identità tra Espressioni Booleane consentono di:
A. Sostituire l'AND con l'OR e il valore 0 con 1, e viceversa
B. Modificare il valore di verità degli operatori logici
C. Determinare le Tavole di verità degli operatori logici
D. Trasformare una Espressione Booleana in un'altra equivalente

422. La forma canonica Somma di Prodotti e data da:
A. Un AND di OR
B. Un OR di AND tale che ogni AND contiene tutte le variabile in forma normale o complementata
C. Un OR di AND
D. Un AND di OR tale che ogni OR contiene tutte le variabile in forma normale o complementata

423. Un mintermine è:
A. Una funzione la cui tavola di verità contiene un solo valore 1, data dall'AND di tutte le variabili in forma normale o complementata
B. Una funzione di una sola variabile binaria
C. Una funzione la cui tavola di verità contiene un solo valore 0, data dall'OR di tutte le variabili in forma normale o complementata
D. La negazione di un AND di variabili Booleane

424. La forma canonica Prodotto di Somme e data da:
A. Un OR di AND
B. Un AND di OR tale che ogni OR contiene tutte le variabile in forma normale o complementata
C. Un AND di OR
D. Un OR di AND tale che ogni AND contiene tutte le variabile in forma normale o complementata

425. Un Maxtermine è:
A. Una funzione la cui tavola di verità contiene un solo valore 0, data dall'OR di tutte le variabili in forma normale o complementata
B. Una funzione che assume tutti i valori del Dominio dell'Algebra di Boole
C. Una funzione la cui tavola di verità contiene un solo valore 1, data dall'AND di tutte le variabili in forma normale o complementata
D. La negazione di un OR di variabili Booleane

426. La proprietà dell'insieme di opertatori AND, OR, NOT di essere funzionalmente completo significa che:
A. Ogni Espressione Booleana che contiene questi operatori può essere valuta
B. Tutti questi operatori possono essere valutati mediante Tavole di verità
C. Le tavole di verità di questi operatori contengono almeno un valore diverso da 0
D. Data una qualunque funzione Booleana si può determinare una Espressione Booleana in cui figurano solo gli operatori AND, OR, NOT, e la cui valutazione è uguale alla funzione data

427. Una Rete Combinatoria è:
A. Un circuito digitale costituito dalla connessione di porte logiche senza determinare la presenza di cicli
B. Un circuito digitale costituito dalla connessione di porte logiche in cui è presente almeno un ciclo
C. Un collegamento tra computer tramite server
D. Un dispositivo capace di memorizzare sequenze binarie

428. In circuito digitale è presente un ciclo quando:
A. Il circuito fornisce come output un valore costante nel tempo
B. Un segnale di uscita torna ad alimentare una porta che ha contribuito a generarlo
C. L'input del circuito è uguale all'output del circuito
D. Il segnale di uscita non dipende dall'input del circuito

429. La funzione Booleana calcolata da una Rete Combinatoria è:
A. La funzione che fornisce il numero intero rappresentato dalla sequenza binaria costituita dall'output della rete
B. La funzione che fornisce la sequenza binaria che rappresenta lo stato della rete
C. La funzione corrispondente all'operatore logico che fornisce l'output della rete
D. La funzione binaria di variabili binarie che fornisce la corrispondenza tra i valori applicati ai terminali input della rete e i valori che si ottengono sui terminali output della rete

430. L'Analisi di una Rete Combinatoria si effettua:
A. Verificando che ad una sequenza di valori posta sui terminali input corrisponde sempre lo stesso valore sui terminali output
B. In due passi, associando alla Rete Combinatoria la equivalente Espressione Booleana e valutando la funzione Booleana realtiva a tale Espressione
C. Convertendo la sequenza binaria ottenuta sui terminali output in notazione decimale
D. In due passi, determinando l'Espressione canonica Somma di Prodotti della funzione Booleana e costruendo la Rete Combinatoria ad essa associata

431. La Sintesi di una Rete Combinatoria capace di calcolare una funzione Booleana si effettua:
A. Convertendo la sequenza binaria ottenuta sui terminali output in notazione decimale
B. In due passi, determinando l'Espressione canonica Somma di Prodotti della funzione Booleana e costruendo la Rete Combinatoria ad essa associata
C. Verificando che ad una sequenza di valori posta sui terminali input corrisponde sempre lo stesso valore sui terminali output
D. In due passi, associando alla Rete Combinatoria la equivalente Espressione Booleana e valutando la funzione Booleana realtiva a tale Espressione

432. La Rete Combinatoria corrispondente ad una Espressione canonica Somma di Prodotti è detta:
A. Rete completa
B. Rete canonica
C. Rete Booleana
D. Rete AND to OR

433. I criteri di minimizzazione di un circuito digitale cercano di ridurre:
A. Il costo del circuito digitale
B. Il numero dei terminali output del circuito digitale
C. Il numero dei terminali input del circuito digitale
D. Lo spazio occupato e la velocità del circuito digitale

434. Il numero di livelli attraversati da un segnale in una Rete Combinatoria è dato da:
A. Il numero di porte che il segnale attraversa in un ciclo della Rete Combinatoria
B. Il numero dei terminali input della Rete Combinatoria a cui il segnale può essere applicato
C. Il numero di porte che il segnale attraversa a partire da un terminale input fino a raggiungere un terminale output della Rete Combinatoria
D. Il numero dei terminali output della Rete Combinatoria che forniscono segnali distinti

435. Per ottenere una Rete Combinatoria minimale occorre ridurre
A. Il numero delle porte logiche e il massimo numero di livelli attraversato da un segnale nella Rete
B. Il costo della Rete Combinatoria
C. Il numero dei terminali input della Rete Combinatoria
D. Il numero dei terminali output della Rete Combinatoria

436. La funzione realizzata dal Multiplexer 2<sup>N</sup> a 1 è:
A. Se la sequenza binaria degli N segnali di Controllo rappresenta il numero K, allora sul terminale output è instradato il valore del dato input relativo al terminale associato al numero K
B. Se la sequenza binaria degli N segnali input rappresenta il numero K, allora solo il terminale output associato al numero K ha valore 1, tutti gli altri terminali output hanno valore 0
C. Se la sequenza binaria degli N segnali dei dati input rappresenta il numero K, allora sul terminale output è instradato il valore del segnale di Controllo relativo al terminale associato al numero K
D. Se la sequenza binaria degli N segnali input rappresenta il numero K, allora solo il terminale output associato al numero K ha valore 0, tutti gli altri terminali output hanno valore 1

437. Per scegliere un valore tra 16 dati input disponibili e instradarlo su un solo terminale output si utilizza il modulo combinatorio:
A. Decodificatore 4 a 24 = 16
B. Multiplexer 24=16 a 1
C. Multiplexer 216 a 1
D. Decodificatore 16 a 216

438. La funzione realizzata dal Decodificatore N a 2<sup>N</sup> è:
A. Se la sequenza binaria degli N segnali input rappresenta il numero K, allora solo il terminale output associato al numero K ha valore 1, tutti gli altri terminali output hanno valore 0
B. Se la sequenza binaria degli N segnali di Controllo rappresenta il numero K, allora sul terminale output è instradato il valore del dato input relativo al terminale associato al numero K
C. Se la sequenza binaria degli N segnali dei dati input rappresenta il numero K, allora sul terminale output è instradato il valore del segnale di Controllo relativo al terminale associato al numero K
D. Se la sequenza binaria degli N segnali input rappresenta il numero K, allora solo il terminale output associato al numero K ha valore 0, tutti gli altri terminali output hanno valore 1

439. Per assegnare il valore 1 al terminale output individuato tra 16 possibili uscite disponibili e il valore 0 ai rimanenti output si utilizza il modulo combinatorio:
A. Multiplexer 24=16 a 1
B. Multiplexer 216 a 1
C. Decodificatore 4 a 24 = 16
D. Decodificatore 16 a 216

440. Per individuare la locazione da raggiungere in un blocco di registri si utilizza:
A. Un Multiplexer con un numero N di terminali input uguale alla lunghezza dell'indirizzo dei registri
B. Un Decodificatore con un numero N di terminali input uguale alla lunghezza dell'indirizzo dei registri
C. Un Multiplexer con un numero N di segnali di Controllo uguale alla lunghezza dell'indirizzo dei registri
D. Un Decodificatore con un numero N di terminali output uguale alla lunghezza dell'indirizzo dei registri

441. Per selezionare uno dei 32 registri del processore MIPS si utilizza:
A. Un Multiplexer 25 = 32 a 1 perché l'indirizzo dei registri è di 5 bit
B. Un Multiplexer 232 a 1 perché bisogna scegliere tra 32 registri
C. Un Decodificatore 5 a 25 = 32 perché l'indirizzo dei registri è di 5 bit
D. Un Decodificatore 32 a 232 perché bisogna scegliere tra 32 registri

442. La Rete Combinatoria dell'ALU a 32 bit è implementata:
A. Mediante una Rete Sequenziale
B. Collegando 32 ALU ad un bit relative alle specifiche posizioni con propagazione dei riporti calcolati
C. Collegando l'ALU a 32 bit che effettua le operazioni logiche con l'ALU a 32 bit che effettua le operazioni aritmetiche.
D. Costruendo una rete AND to OR per ciascuna operazione implementata

443. La propagazione del riporto nell'ALU si effettua:
A. Inviando il segnale di controllo Operation S1S0 a tutte le ALU ad un bit relative alle singole posizioni
B. Inviando il riporto CarryOut calcolato dall'ALU ad un bit relativa ad una posizione come dato input del multiplexer 4 a 1 dell'ALU ad un bit relativa alla posizione successiva
C. Inviando il riporto CarryOut calcolato dall'ALU ad un bit relativa ad una posizione come segnale di controllo del multiplexer 4 a 1 dell'ALU ad un bit relativa alla posizione successiva
D. Inviando il riporto CarryOut calcolato dall'ALU ad un bit relativa ad una posizione come riporto input CarryIn dell'ALU ad un bit relativa alla posizione successiva

444. Il riporto CarryIn0 input dell'ALU ad un bit relativa alla posizione meno significativa è utilizzato:
A. Come segnale di controllo posto al valore 0 nel caso dell'Addizione, e al valore 1 nel caso della Sottrazione; negli altri casi il suo valore non influenza il risultato
B. Per l'esecuzione delle istruzioni relative agli operatori logici AND, OR
C. Per il controllo dell'Overflow nell'esecuzione dell'Addizione
D. Sempre con il valore 0

445. In base alla Legge di De Morgan l'operatore logico NOR è uguale:
A. All'Addizione degli operandi complementati
B. All'OR degli operandi complementati
C. All'OR esclusivo degli operandi
D. All'AND degli operandi complementati

446. La pseudoistruzione dell'Assembly MIPS not $s1, $t0 è eseguita mediante:
A. L'istruzione sub $s1, $zero, $t0
B. L'istruzione nor $s1, $t0, $zero
C. L'istruzione or $s1, $t0, $zero
D. L'istruzione and $s1, $t0, $zero

447. Il valore del segnale Zero utilizzato nell'esecuzione dell'istruzione BEQ è calcolato dall'ALU mediante:
A. La porta NOR che calcola l'OR negato dei bit del risultato della sottrazione dei due operandi dell'istruzione BEQ
B. La porta XOR che calcola l'OR esclusivo dei riporti CarryIn e CarryOut nell'ALU ad un bit relativa alla posizione più significativa
C. I segnali Ainvert e Bnegate entrambi posti uguali a 1
D. Il valore output CarryOut calcolato dal Sommatore dell'ALU a un bit relativa alla posizione più significativa

448. Il processo di computazione di una Rete Sequenziale è analogo a quello di una Macchina di Turing perché:
A. La Rete Sequenziale computa una funzione senza capacità di memorizzazione
B. La Rete Sequenziale può assumere un numero finito di stati e il valore dello stato successivo dipende dal valore dello stato attuale e dell'input esterno
C. La Rete Sequenziale è realizzata connettendo porte logiche
D. La Rete Sequenziale invia i risultati calcolati su dispositivi output esterni

449. Il circuito di una Rete Sequenziale è caratterizzato da:
A. Un numero finito di terminali input e output
B. Presenza di porte logiche AND, OR e NOT connesse tra loro
C. Assenza di cicli nei collegamenti tra le porte logiche che costituiscono la Rete
D. Presenza di cicli nei collegamenti tra le porte logiche, che determinano il verificarsi di feedback nel comportamento dinamico del circuito

450. Dal punto di vista implementativo l'Unità Centrale di Elaborazione (CPU) di un computer è:
A. Una Rete Sequenziale
B. Un circuito digitale che calcola la corrispondenza tra input e output descritta da una funzione binaria di variabili binarie
C. Una Rete Combinatoria
D. Un dispositivo di memorizzazione

451. In una Rete Sequenziale il segnale periodico clock è utilizzato per:
A. Sospendere l'esecuzione del programma per consentire la lettura di dati provenienti da dispositivi esterni
B. Interrompere l'esecuzione di un programma se diventa troppo lunga
C. Individuare l'istante in cui avviene il cambiamento di stato della Rete Sequenzialecon con la scrittura dei registri, e assicurare la stabilità dei valori dei segnali calcolati
D. Avviare l'esecuzione del programma

452. La relazione che lega la Frequenza con la Durata di un segnale periodico è:
A. Frequenza /Durata = 1
B. Frequenza + Durata = 1
C. Frequenza = 1 / Durata
D. Frequenza = - Durata

453. La Frequenza di un segnale periodico è data da:
A. Il numero di ripetizioni del periodo che si verificano nell'unità di tempo
B. La durata del periodo del segnale
C. L'ampiezza dell'intervallo di tempo in cui il segnale ha valore alto
D. Il rapporto tra le ampiezze degli intervalli in cui il segnale è alto e basso

454. L'unità di misura della Frequenza di un segnale periodico, denominata Hertz e rappresentata dal simbolo Hz, è riferita a:
A. Il rapporto tra la durata del periodo del segnale e l'unità di tempo di un secondo
B. Il numero di ripetizioni del periodo che si verificano in un secondo
C. Il rapporto tra la durata del periodo del segnale e l'unità di tempo di un minuto
D. Il numero di ripetizioni del periodo che si verificano in un minuto

455. La frequenza di un segnale periodico data da un Giga Hertz corrisponde al valore:
A. 1 GHz = 1012 cicli al secondo
B. B. 1 GHz = 106 cicli al secondo
C. 1 GHz = 103 cicli al secondo
D. 1 GHz = 109 cicli al secondo

456. La tecnica di Temporizzazione sensibile ai fronti utilizzata per sincronizzare una Rete Sequenziale sceglie uno dei fronti del segnale di clock (di salita o di discesa), detto "fronte attivo", come istante di tempo in cui:
A. Memorizzare il cambiamento di stato nei registri della Rete Sequenziale
B. Eseguire i calcoli nella parte combinatoria della Rete Sequenziale
C. Avviare l'esecuzione del programma
D. Consentire la lettura di dati provenienti da dispositivi esterni

457. I dispositivi di memorizzazione posti all'interno della Unità Centrale di Elaborazione a ciclo singolo del MIPS (CPU) sono:
A. Il registro Program Counter
B. Il registro Program Counter ed il blocco dei 32 Registri del processore
C. Il blocco dei 32 Registri del processore
D. La Memoria e l'ALU

458. L'implementazione della Unità Centrale di Elaborazione (CPU) in base all'approccio a ciclo singolo richiede che:
A. Le operazioni relative alla esecuzione di una istruzione devono avvenire tutte durante un unico ciclo di clock
B. Il prelievo dell'istruzione dalla Memoria deve avvenire in un ciclo di clock separato dall'esecuzione delle relative operazioni
C. Ogni operazione relativa all'esecuzione di una istruzione deve avvenire in un ciclo separato
D. La durata del ciclo di clok deve variare a seconda dell'istruzione da eseguire

459. La temporizzazione sensibile ai fronti della Unità Centrale di Elaborazione (CPU) richiede che:
A. La durata del ciclo di clock deve variare a seconda dell'istruzione da eseguire
B. Ogni operazione relativa all'esecuzione di una istruzione deve avvenire in un ciclo di clock separato
C. Il cambiamento di stato determinato dalla scrittura dei registri deve avvenire nell'istante di tempo individuato dal fronte di salita o di discesa scelto come fronte attivo del segnale di clock
D. La durata dell'esecuzione deve essere calcolata in base agli istanti di tempo individuati dal fronte di salita o di discesa scelto come fronte attivo del segnale di clock

460. La fase di Prelievo con cui inizia l'esecuzione di ogni istruzione consiste nella:
A. Lettura in Memoria degli operandi dell'istruzione
B. Lettura nel blocco dei Registri del processore dei 6 bit del Codice Operativo contenuto nella sequenza binaria che rappresenta l'istruzione in Linguaggio Macchina
C. Lettura in Memoria della sequenza binaria che rappresenta l'istruzione in Linguaggio Macchina
D. Lettura nel blocco dei Registri del processore degli operandi dell'istruzione

461. L'indirizzo di accesso in Memoria utilizzato nella fase di prelievo dell'istruzione è contenuto:
A. Nel blocco dei registri del processore
B. Nel registro Program Counter
C. Sui terminali output del Sommatore che calcola l'aggiornamento dell'indirizzo
D. Nella Unità di Controllo (UC)

462. La lettura anticipata di due Registri del processore, fatta dopo la fase di Prelievo mentre l'Unità di Controllo calcola il valore dei segnali di controllo, è effettuata allo scopo di:
A. Ridurre il tempo di esecuzione delle istruzioni che richiedono la lettura degli operandi nei Registri
B. Calcolare l'indirizzo da scrivere nel Program Counter
C. Leggere il codice operativo dell'istruzione
D. Calcolare l'indirizzo della prossima istruzione da eseguire

463. Se l'istruzione in esecuzione non richiede operandi, la lettura anticipata dei due Registri, fatta dopo la fase di Prelievo mentre l'Unità di Controllo calcola il valore dei segnali di controllo, risulta:
A. Utile perché serve per calcolare l'indirizzo della prossima istruzione da eseguire
B. Utile perché serve per calcolare l'indirizzo da scrivere nel Program Counter
C. Utile perché serve per leggere il codice operativo dell'istruzione
D. Inutile, ma non determina spreco di tempo perché è effettuata contemporaneamente ad altre operazioni necessarie per l'esecuzione dell'istruzione

464. Quando l'Unità di Controllo termina il calcolo dei valori dei segnali di controllo l'esecuzione dell'istruzione viene completata dalla Unità di Elaborazione Dati effettuando:
A. La lettura in Memoria della sequenza binaria che rappresenta l'istruzione in Linguaggio Macchina
B. La lettura nel Program Counter della sequenza binaria che rappresenta l'istruzione in Linguaggio Macchina
C. Le operazioni relative all'istruzione e la scrittura dei registri
D. La lettura del campo Codice Operativo

465. I 32 bit contenuti nel Program Counter forniscono:
A. Il numero di istruzioni del programma già eseguite
B. L'indirizzo del Registro del processore che contiene l'istruzione da eseguire rappresentata in Linguaggio Macchina
C. La sequenza che rappresenta l'istruzione in Linguaggio Macchina da eseguire
D. L'indirizzo del primo dei 4 Byte della parola di Memoria che contiene l'istruzione da eseguire rappresentata in Linguaggio Macchina

466. Nell'implementazione delle istruzioni Aritmetico-Logiche di Tipo R l'indirizzo del registro in cui viene scritto il risultato è nel campo:
A. Istruzione[31-26] dell'istruzione letta dalla Memoria
B. Istruzione[15-11] dell'istruzione letta dalla Memoria
C. Istruzione[25-21] dell'istruzione letta dalla Memoria
D. Istruzione[20-16] dell'istruzione letta dalla Memoria

467. Per le istruzioni Aritmetico-Logiche MIPS di Tipo R la lettura anticipata dei Registri del processore è una ottimizzazione del tempo di esecuzione perché:
A. Fornisce sui terminali output Dato letto 1 e Dato letto 2 i valori dei due operandi dell'ALU contenuti nei Registri con indirizzi nei campi Istruzione[25-21] e Istruzione[20-16]
B. Fornisce sui terminali output Dato letto 1 e Dato letto 2 i valori dei due operandi dell'ALU contenuti nei Registri con indirizzi nei campi Istruzione[31-26] e Istruzione[20-16]
C. Fornisce sui terminali output Dato letto 1 e Dato letto 2 i valori dei due operandi dell'ALU contenuti nei Registri con indirizzi nei campi Istruzione[25-21] e Istruzione[15-0]
D. Fornisce sui terminali output Dato letto 1 e Dato letto 2 i valori dei due operandi dell'ALU contenuti nei Registri con indirizzi nei campi Istruzione[20-16] e Istruzione[15-11]

468. Per le istruzioni di trasferimento dati Load word e Store word la lettura anticipata dei Registri del processore è una ottimizzazione del tempo di esecuzione perché:
A. Fornisce sul terminale output Dato letto 1 l'indirizzo di accesso in Memoria
B. Fornisce sul terminale output Dato letto 2 il contenuto del Registro Base di indirizzo Istruzione[15-0] come operando dell'ALU per il calcolo dell'indirizzo di accesso in Memoria
C. Fornisce sul terminale output Dato letto 1 il contenuto del Registro da cui leggere o in cui scrivere il dato che viene trasferito
D. Fornisce sul terminale output Dato letto 1 il contenuto del Registro Base di indirizzo Istruzione[25-21] come operando dell'ALU per il calcolo dell'indirizzo di accesso in Memoria

469. Per l'istruzione di salto condizionato su uguaglianza BEQ l'implementazione della regola per il calcolo dell'indirizzo di salto è data da:
A. Valore contenuto nel Registro Base con indirizzo nel campo Istruzione[25-21] addizionato al numero di istruzioni da saltare contenuto nel campo Istruzione[15-0] Esteso di segno a 32 bite Shiftato a sinistra di 2 posizioni
B. Valore contenuto nel Registro Base con indirizzo nel campo Istruzione[25-21] addizionato al valore dell'Offset contenuto nel campo Istruzione[15-0] Esteso di segno a 32 bit
C. Valore contenuto nel Program Counter addizionato al valore contenuto nel Registro Base con indirizzo nel campo Istruzione[25-21]
D. Valore contenuto nel Program Counter addizionato al numero di istruzioni da saltare contenuto nel campo Istruzione[15-0] Esteso di segno a 32 bit e Shiftato a sinistra di 2 posizioni

470. Per l'istruzione di salto condizionato su uguaglianza BEQ la lettura anticipata dei Registri del processore è una ottimizzazione del tempo di esecuzione perché:
A. Fornisce sui terminali output Dato letto 1 e Dato letto 2 il contenuto dei Registri di indirizzo Istruzione[31-26] e Istruzione[15-11] come operandi dell'ALU per il calcolo dell'indirizzo di salto
B. Fornisce sui terminali output Dato letto 1 e Dato letto 2 il contenuto dei Registri di indirizzo Istruzione[25-21] e Istruzione[20-16] come operandi dell'ALU per il calcolo dell'indirizzo di salto
C. Fornisce sui terminali output Dato letto 1 e Dato letto 2 il contenuto dei Registri di indirizzo Istruzione[25-21] e Istruzione[20-16] come operandi dell'ALU da confrontare per stabilire la condizione di salto
D. Fornisce sui terminali output Dato letto 1 e Dato letto 2 il contenuto dei Registri di indirizzo Istruzione[31-26] e Istruzione[15-0] come operandi dell'ALU da confrontare per stabilire la condizione di salto

471. Per la realizzazione della CPU a ciclo singolo, l'Unità di Controllo e l'Unità di controllo dell'ALU sono implementate mediante:
A. Due multiplexer separati, realizzati sulla base delle funzioni Booleane costituite dalle relazioni input-output che forniscono i valori dei segnali di controllo per l'esecuzione delle istruzioni
B. Due Reti Combinatorie separate, realizzate sulla base delle funzioni Booleane costituite dalle relazioni input-output che forniscono i valori dei segnali di controllo per l'esecuzione delle istruzioni
C. Una Rete Sequenziale che mediante transizioni di stato consente di tenere memoria della successione delle operazioni relative alla esecuzione dell'istruzione
D. La memorizzazione nei Registri del processore delle Tavole di verità delle relazioni input-output che forniscono i valori dei segnali di controllo per l'esecuzione delle istruzioni

472. Nella realizzazione della CPU in base all'approccio multiciclo l'Unità di Controllo è implementata mediante:
A. Una Rete Sequenziale che, per l'esecuzione di una istruzione, consente di tenere memoria mediante transizioni di stato della successione delle operazioni che avvengono in cicli di clock separati
B. Una Rete Combinatoria realizzata sulla base della successione dei valori dei segnali di controllo per l'esecuzione delle operazioni dell'istruzione nei relativi cicli di clock
C. La memorizzazione nei Registri del processore della successione dei valori dei segnali di controllo per l'esecuzione delle operazioni dell'istruzione nei relativi cicli di clock
D. Un decodificatore che fornisce i valori dei segnali di controllo per l'esecuzione dell'istruzione nei relativi cicli di clock

473. Lo stato SET del LATCH SR che rappresenta il simbolo 1 corrisponde alla configurazione in cui:
A. Gli output sono entrambi uguali a 1
B. Gli output sono diversi e l'output Q=0
C. Gli output sono diversi e l'output Q=1
D. Gli output sono entrambi uguali a 0

474. Lo stato RESET del LATCH SR che rappresenta il simbolo 0 corrisponde alla configurazione in cui:
A. Gli output sono diversi e l'output Q=1
B. Gli output sono entrambi uguali a 1
C. Gli output sono entrambi uguali a 0
D. Gli output sono diversi e l'output Q=0

475. Nel Flip-Flop SR l'input S=0 ed R=0 determina:
A. La transizione dei valori output nello stato SET
B. Il mantenimento invariato dello stato rappresentato dai valori output
C. La transizione dei valori output nello stato RESET
D. Nessuna transizione perché è una configurazione input esclusa

476. Nel Flip-Flop SR l'input S=1 ed R=0 determina:
A. La transizione dei valori output nello stato RESET
B. La transizione dei valori output nello stato SET
C. Il mantenimento invariato dello stato rappresentato dai valori output
D. Nessuna transizione perché è una configurazione input esclusa

477. Nel Flip-Flop SR l'input S=0 ed R=1 determina:
A. Nessuna transizione perché è una configurazione input esclusa
B. La transizione dei valori output nello stato SET
C. Il mantenimento invariato dello stato rappresentato dai valori output
D. La transizione dei valori output nello stato RESET

478. Nel Flip-Flop SR l'input S=1 ed R=1 determina:
A. La transizione dei valori output nello stato RESET
B. La transizione dei valori output nello stato SET
C. Nessuna transizione perché è una configurazione input esclusa
D. Il mantenimento invariato dello stato rappresentato dai valori output

479. Nel Flip-Flop D l'input D=1 determina:
A. Nessuna transizione perché è una configurazione input esclusa
B. La transizione dei valori output nello stato RESET
C. Il mantenimento invariato dello stato rappresentato dai valori output
D. La transizione dei valori output nello stato SET

480. Nel Flip-Flop D l'input D=0 determina:
A. Il mantenimento invariato dello stato rappresentato dai valori output
B. La transizione dei valori output nello stato SET
C. La transizione dei valori output nello stato RESET
D. Nessuna transizione perché è una configurazione input esclusa

481. Il circuito di Lettura dei Registri del processore MIPS utilizza:
A. Il campo Istruzione [5-0] che fornisce l'indirizzo che consente di selezionare il Registro
B. Un decodificatore 5 a 25 per selezionare il Registro mediante il relativo indirizzo di 5 bit
C. Il contenuto del Program Counter che contiene l'indirizzo di accesso in lettura al Registro
D. Un multiplexer 25 a 1 per selezionare il Registro mediante il relativo indirizzo di 5 bit Answer:

482. L'attivazione della Lettura per proteggere i 32 Registri del processore MIPS:
A. Viene implementata mediante il segnale di controllo MemtoReg
B. Viene implementata mediante il segnale di controllo RegRead
C. Non è implementata non essendo necessaria la protezione in lettura poiché non è distruttiva
D. Viene implementata mediante il segnale di controllo MemRead

483. Nel circuito di Lettura il contenuto dei Registri del processore MIPS è collegato:
A. Ai terminali output del multiplexer relativi ai dati da selezionare utilizzando i valori sui terminali input di controllo del multiplexer costituiti dall'indirizzo del Registro
B. Ai terminali output del decodificatore che vengono selezionati utilizzando i valori sui terminali input di controllo del decodificatore costituiti dall'indirizzo del Registro
C. Ai terminali input del multiplexer relativi ai dati da selezionare utilizzando i valori sui terminali input di controllo del multiplexer costituiti dall'indirizzo del Registro
D. Ai terminali input del decodificatore che vengono selezionati utilizzando i valori sui terminali input di controllo del decodificatore costituiti dall'indirizzo del Registro

484. Il circuito di Scrittura dei Registri del processore MIPS utilizza:
A. Il contenuto del Program Counter che contiene l'indirizzo di accesso in scrittura al Registro
B. Un multiplexer 25 a 1 per selezionare il Registro mediante il relativo indirizzo di 5 bit
C. Il campo Istruzione [5-0] che fornisce l'indirizzo che consente di selezionare il Registro
D. Un decodificatore 5 a 25 per selezionare il Registro mediante il relativo indirizzo di 5 bit

485. L'attivazione della Scrittura nei 32 Registri del processore MIPS è controllata mediante:
A. Il segnale di controllo MemWrite
B. Il segnale output dell'AND tra il segnale di controllo RegWrite e l'output del decodificatore relativo a ciascun registro
C. Il segnale output dell'AND tra il segnale di controllo MemWrite e l'output del decodificatore relativo a ciascun registro
D. Un multiplexer che controlla la scelta del registro

486. Nel circuito di Scrittura il Dato da scrivere in un Registro del processore MIPS è collegato:
A. In input al contenuto di tutti i Registri, ma la scrittura è attivata solo nel registro che corrisponde all'indirizzo fornito in input al multiplexer
B. In input al contenuto di tutti i Registri, ma la scrittura è attivata solo nel registro che corrisponde all'indirizzo fornito in input al decodificatore
C. In input al multiplexer che seleziona il Registro in cui scrivere mediante l'indirizzo fornito in input
D. In input al decodificatore che seleziona il Registro in cui scrivere mediante l'indirizzo fornito in input

487. Il Codice a controllo di parità consente di:
A. Correggere ogni errore su un singolo bit
B. Riconoscere il verificarsi di un errore sui bit diversi dal bit di parità
C. Riconoscere ma non correggere il verificarsi di un numero dispari di errori
D. Riconoscere ma non correggere il verificarsi di un numero pari di errori

488. Il Codice di Hamming consente di:
A. Riconoscere il verificarsi di un errore sui bit diversi dal bit di parità
B. Correggere ogni errore su un singolo bit
C. Riconoscere ma non correggere il verificarsi di un numero pari di errori
D. Riconoscere ma non correggere il verificarsi di un numero dispari di errori

489. Nell'ambito della valutazione delle prestazioni, con il termine metrica si indica:
A. Una valutazione in termini numerici di un aspetto del comportamento del sistema
B. L'unità di misura della grandezza adottata per valutare le prestazioni
C. Un parametro della prestazione da valutare
D. L'intervallo dei possibili valori assunti da un parametro della prestazione da valutare

490. Nell'ambito della valutazione delle prestazioni Hardware con il termine benchmark si indica:
A. Il numero delle istruzioni del programma utilizzato per effettuare la valutazione delle prestazioni della CPU
B. Il limite massimo entro il quale la valutazione della prestazione fornisce un valore accettabile
C. L'intervallo dei valori in cui ricade la valutazione della prestazione
D. Un insieme di programmi campione appositamente scelto per impegnare un dispositivo nell'esecuzione di un numero adeguato di istruzioni significative ai fini della valutazione da effettuare

491. Ai fini della valutazione delle prestazioni Hardware, il tempo di CPU viene definito come:
A. Il tempo di CPU utente speso per l'esecuzione delle istruzioni del programma utente
B. Il tempo di CPU utente speso per l'esecuzione delle istruzioni del programma utente più il tempo di CPU di sistema speso per l'esecuzione delle funzioni del Sistema Operativo necessarie per eseguire il programma utente
C. Il tempo di CPU di sistema speso per l'esecuzione delle funzioni del Sistema Operativo necessarie per eseguire il programma utente
D. Il tempo speso negli accessi alla Memoria principale per il prelievo delle istruzioni

492. La relazione che lega la frequenza di clock al periodo di clock è data da:
A. Frequenza diviso periodo uguale a 1
B. Frequenza uguale all'inverso del periodo
C. Frequenza più periodo uguale tempo di CPU
D. Frequenza uguale a 1 meno periodo

493. Utilizzando il periodo di clock, il tempo di CPU utente relativo alla esecuzione di un programma può essere calcolato con la formula:
A. Numero di cicli di clock impiegati per l'esecuzione del programma meno il periodo di clock
B. Numero di cicli di clock impiegati per l'esecuzione del programma diviso per il periodo di clock
C. Numero di cicli di clock impiegati per l'esecuzione del programma più il periodo di clock
D. Numero di cicli di clock impiegati per l'esecuzione del programma moltiplicato per il periodo di clock

494. Utilizzando la frequenza di clock, il tempo di CPU utente relativo alla esecuzione di un programma può essere calcolato con la formula:
A. Numero di cicli di clock impiegati per l'esecuzione del programma più la frequenza di clock
B. Numero di cicli di clock impiegati per l'esecuzione del programma moltiplicato per la frequenza di clock
C. Numero di cicli di clock impiegati per l'esecuzione del programma diviso la frequenza di clock
D. Numero di cicli di clock impiegati per l'esecuzione del programma meno la frequenza di clock

495. La relazione che lega il tempo di CPU utente con la frequenza di clock e il periodo di clock è:
A. Inversa proporzionalità con il periodo e diretta proporzionalità con la frequenza
B. Inversa proporzionalità con la frequenza e diretta proporzionalità con il periodo
C. Diretta proporzionalità con entrambi
D. Inversa proporzionalità con entrambi

496. Per migliorare le prestazioni di un computer la frequenza di clock può essere:
A. Mantenuta costante diminuendo il periodo di clock
B. Diminuita, ma senza superare il limite fisico costituito dalla possibilità di disperdere il calore generato
C. Aumentata, ma senza superare il limite fisico costituito dalla possibilità di disperdere il calore generato
D. Mantenuta costante aumentando il periodo di clock

497. In una gerarchia di memorie, il livello più vicino alla CPU è:
A. Più veloce e meno grande
B. Meno veloce e più grande
C. Più veloce e più grande
D. Meno veloce e meno grande

498. La tecnica detta mappatura diretta di una cache costituita da K = 2<sup>s</sup> locazioni pone:
A. Gli indirizzi della cache costituita da K=2s locazioni uguali agli indirizzi delle prime K locazioni della Memoria principale
B. Gli indirizzi della cache uguali allo stesso valore degli indirizzi delle locazioni della Memoria principale
C. Gli indirizzi della cache costituita da K=2s locazioni uguali al valore modulo s degli indirizzi delle locazioni della Memoria principale, che coincide con il valore rappresentato dagli s bit meno significativi di tali indirizzi
D. Gli indirizzi della cache costituita da K=2s locazioni uguali al valore degli indirizzi delle ultime K locazioni della Memoria principale

499. Il campo tag di un elemento della Tabella associata alla cache fornisce:
A. I bit del contenuto della locazione nella Memoria principale associata alla locazione nella cache relativa alla riga della Tabella
B. I rimanenti bit dell'indirizzo della locazione nella Memoria principale associata alla locazione nella cache relativa alla riga della Tabella, che vengono persi effettuando l'operazione modulo prevista dalla tecnica di mappatura diretta della cache
C. Il valore di un bit uguale a 1 se la locazione nella cache relativa alla riga della Tabella è occupata da un dato copiato dalla Memoria principale, uguale a 0 se tale locazione nella cache è libera
D. Il valore di un bit uguale a 0 se la locazione nella cache relativa alla riga della Tabella è occupata da un dato copiato dalla Memoria principale, uguale a 1 se tale locazione nella cache è libera

500. Il campo di validità di un elemento della Tabella associata alla cache fornisce:
A. I bit del contenuto della locazione nella Memoria principale associata alla locazione nella cache relativa alla riga della Tabella
B. Il valore di un bit uguale a 0 se la locazione nella cache relativa alla riga della Tabella è occupata da un dato copiato dalla Memoria principale, uguale a 1 se tale locazione nella cache è libera
C. I rimanenti bit dell'indirizzo della locazione nella Memoria principale associata alla locazione nella cache relativa alla riga della Tabella, che vengono persi effettuando l'operazione modulo prevista dalla tecnica di mappatura diretta della cache
D. Il valore di un bit uguale a 1 se la locazione nella cache relativa alla riga della Tabella è occupata da un dato copiato dalla Memoria principale, uguale a 0 se tale locazione nella cache è libera

501. I termini hit rate e miss rate indicano:
A. Le metriche che forniscono rispettivamente il tempo medio necessario per stabilire se si è verificato un hit o un miss nel trovare un elemento nel livello superiore della gerarchia di memorie
B. Le metriche che forniscono rispettivamente il tempo speso per gli hit e i miss che si verificano in un intervallo di tempo in una gerarchia di memorie
C. Le metriche che forniscono rispettivamente la frequenza di hit e la frequenza di miss che si verificano in un fissato numero di accessi in memoria.
D. Le metriche che forniscono rispettivamente il numero totale di hit e di miss che si verificano nell'esecuzione di un programma

502. La penalità di miss è:
A. La metrica che fornisce il tempo per sostituire un blocco della memoria Virtuale con un nuovo blocco copiato dalla memoria di massa che contiene il dato cercato
B. La metrica che fornisce il tempo che si spende per accedere al livello superiore della gerarchia di memorie nel caso che il dato venga trovato
C. La metrica che fornisce il tempo totale dei miss che si verificano nell'esecuzione di un programma
D. La metrica che fornisce il tempo per sostituire un blocco nel livello superiore con un nuovo blocco copiato dal livello inferiore che contiene il dato cercato

503. Il tempo di hit:
A. La metrica che fornisce il tempo per sostituire un blocco nel livello superiore con un nuovo blocco copiato del livello inferiore che contiene il dato cercato
B. La metrica che fornisce il tempo che si spende per accedere al livello superiore della gerarchia di memorie nel caso che il dato venga trovato
C. La metrica che fornisce il tempo totale degli hit che si verificano nell'esecuzione di un programma
D. La metrica che fornisce il tempo che si spende per accedere alla Memoria Virtuale nel caso che il dato venga trovato

504. Con il termine Memoria Virtuale si indica:
A. Una memoria in cui tutti i programmmi che vengono eseguiti in parallelo possono condividere i dati effettuando operazioni di lettura/scrittura
B. Il livello più basso di una gerarchia di memorie che corrisponde alla Memoria di massa
C. Una tecnica di gestione della memoria capace di simulare uno spazio di Memoria principale indirizzabile maggiore di quello fisicamente disponibile, utilizzando spazio della memoria di massa
D. La memoria riservata alle funzioni svolte dal Sistema Operativo

505. Si verifica un page fault quando:
A. Si richiede l'accesso ad una pagina della Memoria Virtuale che non corrisponde ad una pagina della Memoria principare perché la pagina cercata risiede nella memoria di massa
B. Il dato non viene trovato nella relativa pagina nell'accesso al livello superiore della gerarchia di memoria costituito dalla cache
C. Il dato non viene trovato nella relativa pagina contenuta nel livello più basso della gerarchia di memorie
D. Si richiede l'accesso ad una pagina della Memoria Virtuale che corrisponde ad una pagina della Memoria principare

506. La MMU (Memory Management Unit) è:
A. Un dispositivo Hardware che effettua il prelievo dei dati presenti nella cache
B. Un dispositivo Hardware per la gestione dei livelli di una gerarchia di memorie che fornisce la traduzione degli indirizzi del livello superiore in indirizzi della memoria di massa
C. Un dispositivo Hardware per la gestione della Memoria Virtuale che fornisce la traduzione degli indirizzi virtuali in indirizzi fisici della Memoria principale
D. Un dispositivo Hardware per assegnare lo spazio della cache alle operazioni del Sistema operativo

507. Il parallelismo della tecnica di pipelining per il miglioramento delle prestazioni di un computer consiste:
A. Nell'uso di una unità di elaborazione grafica ad alto parallelismo che offre la possibiltà di programmare un ampio spettro di applicazioni utilizzando un linguaggio di programmazione tipicamente basato sul Linguaggio C
B. Nella possibilità di eseguire in parallelo le istruzioni su un computer in cui è presente più di una CPU
C. Nella esecuzione in parallelo di più istruzioni come in una catena di montaggio, suddividendo l'esecuzione di ogni istruzione in fasi e svolgendo le operazioni di ogni fase in un ciclo di clock.
D. Nell'effettuare gli accessi ai dati ed alle istruzioni attraverso una gerarchia di livelli di memoria copiando i blocchi da un livello a quello immediantamente superiore

508. L'esecuzione di una istruzione del Linguaggio Macchina MIPS nell'applicazione del pipeling è suddivisa in:
A. 6 fasi denominate: Fetch, lettura dei registri, decodifica del codice operativo, calcolo effettuato dall'ALU, lettura/scrittura di un dato in Memoria, scrittura nel blocco dei Registri
B. 4 fasi denominate: Fetch e decodifica, lettura dei registri e calcolo effettuato dall'ALU, lettura/scrittura di un dato in Memoria, scrittura nel blocco dei Registri
C. 5 fasi denominate: Fetch, lettura dei registri e decodifica, calcolo effettuato dall'ALU, lettura/scrittura di un dato in Memoria, scrittura nel blocco dei Registri
D. 5 fasi denominate: Fetch e decodifica, lettura dei registri, calcolo effettuato dall'ALU, lettura/scrittura di un dato in Memoria, scrittura nel blocco dei Registri

509. Per l'implementazione della tecnica di pipelining è necessario:
A. Aggiungere delle General Purpose GPU tra cui suddividere l'esecuzione delle istruzioni in parallelo
B. Aggiungere delle CPU tra cui suddividere l'esecuzione delle istruzioni in parallelo
C. Aggiungere dei registri per memorizzare le informazioni necessarie alla esecuzione in parallelo delle istruzioni
D. Aggiungere dei bus di comunicazione tra le CPU che concorrono alla esecuzione in parallelo delle istruzioni

510. Si verifica una criticità strutturale quando:
A. Le risorse Hardware presenti non sono in grado di supportare le operazioni richieste da diverse fasi della pipeline in esecuzione
B. Una fase deve aspettare i risultati delle operazioni eseguite in un altra fase della pipeline.
C. Il prelievo di una istruzione nella fase di Fetch dipende dall'esito del test di una istruzione di salto condizionato in esecuzione nella pipeline
D. La pipeline non riceve i dati necessari a causa di un Page Fault

511. Si verifica una criticità sui dati quando:
A. La pipeline non riceve i dati necessari a causa di un Page Fault
B. Le risorse Hardware presenti non sono in grado di supportare le operazioni richieste da diverse fasi della pipeline in esecuzione
C. Il prelievo di una istruzione nella fase di Fetch dipende dall'esito del test di una istruzione di salto condizionato in esecuzione nella pipeline
D. Una fase deve aspettare i risultati delle operazioni eseguite in un altra fase della pipeline

512. Per risolvere una criticità sui dati:
A. Si utilizza una tecnica di predizione dell'esito del salto condizionato, che nel caso più semplice consiste nel continuare sempre l'esecuzione senza effettuare il salto
B. Si utilizza la tecnica detta di propagazione (bypassing) che consente all'istruzione successiva di leggere direttamente i risultati output calcolati dall'ALU senza dover attendere che siano memorizzati nel blocco dei Registri
C. Si aggiungono dei dispositivi di controllo per evitare i conflitti tra fasi di esecuzione di istruzioni diverse che richiedono lo stesso Hardware
D. Si duplicanno i dispositivi che determinano i conflitti tra fasi di esecuzione di istruzioni diverse che richiedono lo stesso Hardware

513. Si verifica una criticità sul controllo quando:
A. Una fase deve aspettare i risultati delle operazioni eseguite in un altra fase della pipeline
B. Il prelievo di una istruzione nella fase di Fetch dipende dall'esito del test di una istruzione di salto condizionato in esecuzione nella pipeline
C. Le risorse Hardware presenti non sono in grado di supportare le operazioni richieste da diverse fasi della pipeline in esecuzione
D. La pipeline non riceve i dati necessari a causa di un Page Fault

514. Per risolvere una criticità sul controlo:
A. Si utilizza una tecnica di predizione dell'esito del salto condizionato, che nel caso più semplice consiste nel continuare sempre l'esecuzione senza effettuare il salto
B. Si utilizza la tecnica detta di propagazione (bypassing) che consente all'istruzione successiva di leggere direttamente i risultati output calcolati dall'ALU senza dover attendere che siano memorizzati nel blocco dei Registri
C. Si aggiungono dei dispositivi di controllo per evitare i conflitti tra fasi di esecuzione di istruzioni diverse che richiedono lo stesso Hardware
D. Si duplicanno i dispositivi che determinano i conflitti tra fasi di esecuzione di istruzioni diverse che richiedono lo stesso Hardware

515. Il termine multicore è riferito a una Architettura:
A. Che implementa una gerarchia di Memorie
B. In cui è presente più di una Graphic Processing Unit (GPU)
C. Che implementa la Memoria Virtuale
D. In cui è presente più di una Central Processing Unit (CPU)

516. Una General Purpose GPU è:
A. Una Unità di elaborazione grafica ad alto parallelismo che offre la possibiltà di programmare un ampio spettro di applicazioni utilizzando un linguaggio di programmazione tipicamente basato sul Linguaggio C
B. Una Architettura in cui è presente più di una Central Processing Unit (CPU)
C. Una Atrchitettura che suddivide l'esecuzione di ogni istruzione in fasi svolgendo le operazioni di ogni fase in un ciclo di clock.
D. Una Architettura che implementa le istruzioni con un numero variabili di cicli di clock

517. I progressi della tecnologia hanno:
A. Migliorato le prestazioni ed aumentatol'insieme dei problemi algoritmicamente risolubili
B. Ridotto i costi ed aumentato l'insieme dei problemi algoritmicamente risolubili
C. Cambiato i risultati teorici relativi alla computazione algoritmica
D. Migliorato le prestazioni del computer ma non hanno cambiato l'insieme dei problemi algoritmicamente risolubili

518. Il Codice Operativo di una istruzione aritmetica dell'Assembly stabilisce:
A. Solo l'operazione aritmetica da eseguire
B. L'operazione aritmetica da eseguire e come reperire gli operandi
C. Solo gli operandi dell'operazione aritmetica da eseguire
D. Solo dove scrivere il risultato dell'operazione dopo l'esecuzione

519. L'operatore AND ha valore 1 quando:
A. Un solo operando ha valore 1
B. Sempre
C. Gli operandi hanno entrambi valore 1
D. Almeno un operando ha valore 1

520. La suddivisione in campi del Formato dell'istruzione load word 10001110000010010000000000000111 in Linguaggio Macchina MIPS è data da :
A. Le 6 sottosequenze 100011, 10000, 01001, 00000, 00000, 000111
B. Le 4 sottosequenze 100011, 10000, 01001, 0000000000000111
C. Le 4 sottosequenze 100011, 1000001001000000, 00000, 00111
D. Le 3 sottosequenze 100011, 10000, 010010000000000000111

521. Q456. L'esecuzione dell'istruzione Assembly MIPS beq $t1, $t2, NOME determina:
A. La scrittura nei registri di indirizzi $t1 e $t2 del contenuto della locazione Memoria che corrisponde all'etichetta NOME
B. Un salto all'esecuzione dell'istruzione con etichetta NOME se i contenuti dei registri con indirizzi $t1 e $t2 sono DIVERSI
C. Un salto all'esecuzione dell'istruzione con etichetta NOME se i contenuti dei registri con indirizzi $t1 e $t2 sono UGUALI
D. La scrittura nel registro di indirizzo $t1 del contenuto del registro $t2, ed il salto all'istruzione con etichetta NOME

522. Q457. La Modalità di Indirizzamento relativo al Program Counter calcola l'indirizzo:
A. Della istruzione da leggere in memoria, addizionando al contenuto del Program Counter il contenuto del registro Base
B. Della istruzione a cui saltare, addizionando al contenuto del Program Counter il valore del registro Base
C. Della istruzione a cui saltare, addizionando al contenuto del Program Counter il valore del campo immediato esteso di segno
D. Della istruzione a cui saltare, addizionando al contenuto del Program Counter il valore del campo immediato esteso di segno e moltiplicato per 4

523. Q458. Nella rappresentazione con 32 bit del Tipo di dato unsigned il bit più a sinistra è:
A. Associato al peso negativo > -2^31
B. Associato al peso positivo > 2^31
C. Il bit di segno separato dal modulo
D. Sempre uguale a 0

524. Q459. Il codice ASCII esteso utilizza sequenze binarie:
A. Di lunghezza 16
B. Di lunghezza 8
C. Di lunghezza 32
D. Di lunghezza 7

525. Q461. La traduzione in Linguaggio Macchina dell'istruzione sh utilizza:
A. Il Formato di Tipo R e l'Indirizzamento Immediato
B. Il Formato di Tipo I e l'Indirizzamento tramite Base e Offset
C. Il Formato di Tipo I e l'Indirizzamento immediato
D. Il Formato di Tipo I e l'Indirizzamento tramite relativo al Program Counter

526. Q462. La traduzione in Assembly MIPS dell'assegnamento val = A[6] con $s3 registro Base dell'Array di INTERI A[] e assegnado il registro $t0 alla variabile val è data:
A. Dell'istruzione sw $t0, 24 ($s3)
B. Dell'istruzione lw $t0, 6 ($s3)
C. Dell'istruzione lw $s3, 24 ($t0)
D. Dell'istruzione lw $t0, 24 ($s3)

527. Q463. La traduzione in Assembly MIPS dell'assegnamento val = testo[9] con $t1 registro Base dell'Array di caratteri ASCII testo[] e assegnado il registro $s5 alla variabile val è data:
A. Dell'istruzione lbu $t1, 9 ($s5)
B. Dell'istruzione sb $s5, 9 ($t1)
C. Dell'istruzione lbu $s5, 9 ($t1)
D. Dell'istruzione lbu $s5, 36 ($t1)

528. Q464. Il calcolo dell'indirizzo dell'elemento A[k] di un Array che implementa una stringa di CARATTERI Unicode a 16 bit si effettua:
A. Moltiplicando l'indice k per 4 e addizionando il valore ottenuto al contenuto del registro Base dell'Array
B. Moltiplicando l'indice k per 2
C. Addizionando il valore dell'indice k al contenuto del registro Base dell'Array
D. Moltiplicando l'indice k per 2 e addizionando il valore ottenuto al contenuto del registro Base dell'Array

529. Q465. La rappresentazione troncata con errore di arrotondamento di un numero frazionario si ottiene:
A. Sempre eliminando la parte frazionaria del numero
B. Sostituendo cifre meno significative del numero con il valore 0
C. Sempre eliminando la parte intera del numero
D. Sempre considerando solo una cifra dopo la virgola

530. Q466. Il codice oggetto contiene:
A. Il programma in Linguaggio ad Alto Livello scritto dall'utente
B. La traduzione del programma in Linguaggio Assembly fornita dal Compilatore
C. Il programma eseguibile fornito dal Linker
D. La traduzione del programma in Linguaggio Macchina fornita dall'Assembler

531. Q467. Il programma eseguibile è prodotto:
A. Dal Linker
B. Dall'Assembler
C. Dal programmatore
D. Dal Sistema Operativo

532. Q468. La valutazione di una Espressione Booleana è rappresentata:
A. Dalle Tavole di verità degli operatori logici presenti nell'Espressione
B. Dalla Tavola di verità della funzione calcolata dall'Espressione
C. Dal valore di verità assunto dalle variabili dell'Espressione
D. Dal numero di variabili dell'Espressione che assumono valore "vero"

533. Q473. L'implementazione della Unità Centrale di Elaborazione (CPU) in base all'approccio a ciclo singolo richiede che:
A. Le operazioni relative alla esecuzione di una istruzione devono avvenire tutte durante un unico ciclo di clock
B. Il prelievo dell'istruzione dalla Memoria deve avvenire in un ciclo di clock separato dall'esecuzione delle relative operazioni
C. Ogni operazione relativa all'esecuzione di una istruzione deve avvenire in un ciclo separato
D. La durata del ciclo di clok deve variare a seconda dell'istruzione da eseguire

534. Q474. La temporizzazione sensibile ai fronti della Unità Centrale di Elaborazione (CPU) richiede che:
A. La durata del ciclo di clock deve variare a seconda dell'istruzione da eseguire
B. Ogni operazione relativa all'esecuzione di una istruzione deve avvenire in un ciclo di clock separato
C. Il cambiamento di stato determinato dalla scrittura dei registri deve avvenire nell'istante di tempo individuato dal fronte di salita o di discesa scelto come fronte attivo del segnale di clock
D. La durata dell'esecuzione deve essere calcolata in base agli istanti di tempo individuati dal fronte di salita o di discesa scelto come fronte attivo del segnale di clock

535. Q475. Nell'implementazione delle istruzioni Aritmetico-Logiche di Tipo R l'indirizzo del registro in cui viene scritto il risultato è nel campo:
A. Istruzione[31-26] dell'istruzione letta dalla Memoria
B. Istruzione[15-11] dell'istruzione letta dalla Memoria
C. Istruzione[25-21] dell'istruzione letta dalla Memoria
D. Istruzione[20-16] dell'istruzione letta dalla Memoria

536. Q478. Nel Flip-Flop SR l'input S=1 ed R=0 determina:
A. La transizione dei valori output nello stato RESET
B. La transizione dei valori output nello stato SET
C. Il mantenimento invariato dello stato rappresentato dai valori output
D. Nessuna transizione perché è una configurazione input esclusa

537. Q479. Il campo tag di un elemento della Tabella associata alla cache fornisce:
A. I bit del contenuto della locazione nella Memoria principale associata alla locazione nella cache relativa alla riga della Tabella
B. I rimanenti bit dell'indirizzo della locazione nella Memoria principale associata alla locazione nella cache relativa alla riga della Tabella, che vengono persi effettuando l'operazione modulo prevista dalla tecnica di mappatura diretta della cache
C. Il valore di un bit uguale a 1 se la locazione nella cache relativa alla riga della Tabella è occupata da un dato copiato dalla Memoria principale, uguale a 0 se tale locazione nella cache è libera
D. Il valore di un bit uguale a 0 se la locazione nella cache relativa alla riga della Tabella è occupata da un dato copiato dalla Memoria principale, uguale a 1 se tale locazione nella cache è libera

538. Q480. La penalità di miss è:
A. La metrica che fornisce il tempo per sostituire un blocco della memoria Virtuale con un nuovo blocco copiato dalla memoria di massa che contiene il dato cercato
B. La metrica che fornisce il tempo che si spende per accedere al livello superiore della gerarchia di memorie nel caso che il dato venga trovato
C. La metrica che fornisce il tempo totale dei miss che si verificano nell'esecuzione di un programma
D. La metrica che fornisce il tempo per sostituire un blocco nel livello superiore con un nuovo blocco copiato dal livello inferiore che contiene il dato cercato

539. Q481. Per risolvere una criticità sui dati:
A. Si utilizza una tecnica di predizione dell'esito del salto condizionato, che nel caso più semplice consiste nel continuare sempre l'esecuzione senza effettuare il salto
B. Si utilizza la tecnica detta di propagazione (bypassing) che consente all istruzione successiva di leggere direttamente i risultati output calcolati dall ALU senza dover attendere che siano memorizzati nel blocco dei Registri
C. Si aggiungono dei dispositivi di controllo per evitare i conflitti tra fasi di esecuzione di istruzioni diverse che richiedono lo stesso Hardware
D. Si duplicanno i dispositivi che determinano i conflitti tra fasi di esecuzione di istruzioni diverse che richiedono lo stesso Hardware

540. Q482. La valutazione delle prestazioni di un computer misura:
A. A. I costi del Software
B. B. I costi dell'Hardware
C. C. La correttezza della soluzione fornita da un programma
D. D. L'efficienza della esecuzione di un programma su un computer

541. Q483. La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione a=a*2; con l'associazione a--&gt; $s0 è:
A. addi $s0, $s0, 2
B. add $s0, $s0, $s0
C. addi $s0, $s0, $s0
D. add $s0, $s0, 2

542. Q484. In Notazione posizionale pesata la sequenza binaria 11011 rappresenta il valore:
A. Del numero 19 in base 10
B. Del numero 54 in base 10
C. Del numero 27 in base 10
D. Del numero 25 in base 10

543. Q485. In Notazione in complemento a 2, la rappresentazione dell'opposto del valore rappresentato da una sequenza di N bit si ottiene:
A. Complementando la sequenza bit a bit ed aggiungendo il valore> -2^n
B. Complementando la sequenza bit a bit ed aggiungendo il valore 1
C. Cambiando il bit più significativo da 0 in 1 e da 1 in 0
D. Aggiungendo il valore 1 alla sequenza

544. Q486. Nel Linguaggio Macchina MIPS, la Modalità di Indirizzamento delle istruzioni and ed or è:
A. Immediato per entrambe
B. Tramite registro per entrambe
C. Di Tipo R per entrambe
D. Di Tipo I per entrambe

545. Q487. La traduzione in Assembly MIPS dell'AND bit a bit con operandi nei registri $s1 e $s2 e risultato nel registro $s5 è:
A. L'istruzione and $s1, $s5, $s2
B. L'istruzione and $s1, $s2, $s5
C. L'istruzione and $s2, $s5, $s1
D. L'istruzione and $s5, $s1, $s2

546. Q488. La Modalità di Indirizzamento immediato è utilizzata con:
A. Il formato di Tipo R e il Formato di Tipo I
B. Solo il Formato di Tipo I
C. Solo il Formato di Tipo R
D. Il formato di Tipo J

547. Q489. La traduzione in Assembly MIPS dell'assegnamento A[5] = val, associando a val il registro di indirizzo $s2 ed assumendo che l'indirizzo del registro Base dell'Array di numeri interi è $t3, è data da:
A. L'istruzione lw $s2, 20 ($t3)
B. L'istruzione sw $s2, 20 ($t3)
C. L'istruzione sw $t3, 20 ($s2)
D. L'istruzione lw $t3, 20 ($s2)

548. Q490. La Modalità di Indirizzamento relativo al Program Counter è associata:
A. All'istruzione jump
B. Alle istruzioni beq e bne
C. All'istruzione sw
D. All'istruzione jal

549. Q491. Nel Linguaggio Macchina MIPS i valori calcolati dalla procedura chiamata vengono passati al programma chiamante:
A. Nella esecuzione della procedura scrivendoli nel registro $ra prima di effettuare il salto di ritorno al programma chiamante
B. Nella esecuzione della procedura scrivendoli nei registri $a0, $a1, $a2, $a3 durante l'esecuzione della procedura
C. Nella esecuzione della procedura scrivendoli nei registri $v0, $v1 durante l'esecuzione della procedura
D. Nella esecuzione della procedura scrivendoli nei registri $t e $s durante l'esecuzione della procedura

550. Q492. Nel Linguaggio Macchina MIPS l'indirizzo di ritorno al programma chiamante è salvato:
A. Nella esecuzione della procedura scrivendolo nel registro $v0 prima di effettuare il salto di ritorno alla esecuzione del programma chiamante
B. Nella esecuzione del programma chiamante scrivendolo nel registro $a0, prima di effettuare il salto alla esecuzione della procedura
C. Nel registro riservato $ra nella esecuzione della istruzione jal che effettua il salto alla procedura
D. Nella esecuzione del programma chiamante scrivendolo in uno dei registri $t e $s, prima di effettuare il salto alla esecuzione della procedura

551. Q493. Nel Linguaggio macchina MIPS il Formato e la Modalità di Indirizzamento dell'istruzione jr sono:
A. Formato di Tipo R e Indirizzamento immediato
B. Formato di Tipo J e Indirizzamento pseudodiretto
C. Formato di Tipo R e Indirizzamento tramite registro
D. Formato di Tipo I e Indirizzamento relativo al Program Counter

552. Q494. La traduzione in Linguaggio Macchina MIPS dell'istruzione slt $s1, $t3, $t4 ha:
A. Formato di Tipo R e Indirizzamento tramite registro
B. Formato di Tipo R e Indirizzamento immediato
C. Formato di Tipo I e Indirizzamento relativo al Program Counter
D. Formato di Tipo J e Indirizzamento pseudodiretto

553. Q495. La Modalità di Indirizzamento di sb fornisce:
A. L'idirizzo della locazine di Memoria da cui leggere il dato rappresentato da 8 bit
B. L'idirizzo della prima delle due locazini di Memoria in cui scrivere il dato rappresentato da 16 bit
C. L'idirizzo della locazine di Memoria in cui scrivere il dato rappresentato da 8 bit
D. L'idirizzo della prima delle due locazini di Memoria da cui leggere il dato rappresentato da 16 bit

554. Q497. La misura dell'errore di arrotondamento della rappresentazione troncata 79854,84000 del numero 79854,84219 è data:
A. Dal valore 1
B. Dal valore 0,84
C. Dal valore 0,85219
D. Dal valore 0,00219

555. Q498. Le istruzioni aritmetiche Assembly MIPS per operandi rappresentati in virgola mobile hanno codice operativo:
A. Con un numero doppio di simboli per la doppia precisione
B. Uguale alle istruzioni con operandi interi
C. Con suffisso .s per la singola precisione e .d per la doppia precisione
D. Con prefisso .s per la singola precisione e .d per la doppia precisione

556. Q499. Due Espressioni Booleane sono equivalenti quando:
A. Hanno la stessa lunghezza
B. Hanno lo stesso numero di operatori AND, OR e NOT
C. Le loro valutazioni forniscono Tavole di verità uguali
D. Hanno le stesse variabili

557. Q500. Il segnale Less è selezionato dal multiplexed 4 a 1 nella Rete Combinatoria in figura per l'esecuzione:
A. Dell'istruzione di salto condizionato su disuguaglianza
B. Dell'istruzione set on less then
C. Del calcolo dell'indirizzo di accesso in Memoria per le istruzioni load e store
D. Per l'esecuzione della sottrazione dei due operandi

558. Q503. Per le istruzioni Aritmetico-Logiche MIPS di Tipo R la lettura anticipata dei Registri del processore è una ottimizzazione del tempo di esecuzione perché:
A. Fornisce sui terminali output Dato letto 1 e Dato letto 2 i valori dei due operandi dell'ALU contenuti nei Registri con indirizzi nei campi Istruzione[25-21] e Istruzione[20-16]
B. Fornisce sui terminali output Dato letto 1 e Dato letto 2 i valori dei due operandi dell'ALU contenuti nei Registri con indirizzi nei campi Istruzione[31-26] e Istruzione[20-16]
C. Fornisce sui terminali output Dato letto 1 e Dato letto 2 i valori dei due operandi dell'ALU contenuti nei Registri con indirizzi nei campi Istruzione[25-21] e Istruzione[15-0]
D. Fornisce sui terminali output Dato letto 1 e Dato letto 2 i valori dei due operandi dell'ALU contenuti nei Registri con indirizzi nei campi Istruzione[20-16] e Istruzione[15-11]

559. Q507. Per l'istruzione di salto condizionato su uguaglianza BEQ l'implementazione della regola per il calcolo dell'indirizzo di salto è data da:
A. Valore contenuto nel Registro Base con indirizzo nel campo Istruzione[25-21] addizionato al numero di istruzioni da saltare contenuto nel campo Istruzione[15-0] Esteso di segno a 32 bite Shiftato a sinistra di 2 posizioni
B. Valore contenuto nel Registro Base con indirizzo nel campo Istruzione[25-21] addizionato al valore dell'Offset contenuto nel campo Istruzione[15-0] Esteso di segno a 32 bit
C. Valore contenuto nel Program Counter addizionato al valore contenuto nel Registro Base con indirizzo nel campo Istruzione[25-21]
D. Valore contenuto nel Program Counter addizionato al numero di istruzioni da saltare contenuto nel campo Istruzione[15-0] Esteso di segno a 32 bit e Shiftato a sinistra di 2 posizioni

560. Q510. Nel circuito di Scrittura il Dato da scrivere in un Registro del processore MIPS è collegato:
A. In input al contenuto di tutti i Registri, ma la scrittura è attivata solo nel registro che corrisponde all'indirizzo fornito in input al multiplexer
B. In input al contenuto di tutti i Registri, ma la scrittura è attivata solo nel registro che corrisponde all'indirizzo fornito in input al decodificatore
C. In input al multiplexer che seleziona il Registro in cui scrivere mediante l'indirizzo fornito in input
D. In input al decodificatore che seleziona il Registro in cui scrivere mediante l'indirizzo fornito in input

561. Q511. Il termine multicore è riferito a una Architettura:
A. Che implementa una gerarchia di Memorie
B. In cui è presente più di una Graphic Processing Unit (GPU)
C. Che implementa la Memoria Virtuale
D. In cui è presente più di una Central Processing Unit (CPU)

562. Q513. Un programma scritto in un Linguaggio ad Alto Livello ed uno scritto in Assembly possono essere eseguiti:
A. Il primo solo su un computer con l'Architettura corrispondente al Linguaggio ad Alto Livello il secondo su un qualunque computer
B. Entrambi solo su un computer con Architettura corrispondente all'Assembly
C. Il primo su un qualunque computer il secondo solo su un computer con Architettura corrispondente all'Assembly
D. Entrambi su un qualunque computer

563. Q514. La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione h=b+c; con l'associazione b--&gt;$s5	c-- &gt;$s2 h--&gt; $t0 è:
A. add $s5, $s2, $t0
B. add $t0, $s5, $s2
C. add $s2, $s5, $t0
D. add $t0, $s5, $s0

564. Q517. In Notazione in complemento a 2, l'estensione del segno:
A. A. Trasforma un numero positivo in negativo e viceversa
B. B. Aumenta la lunghezza di una sequenza aggiungendo cifre uguali a 0 a sinistra della cifra più significativa
C. C. Aumenta la lunghezza di una sequenza aggiungendo cifre uguali a 1 a sinistra della cifra più significativa
D. D. Aumenta la lunghezza di una sequenza senza modificarne il valore rappresentato

565. Q519. L'operatore OR ha valore 0 quando:
A. A. Gli operandi hanno entrambi valore 0
B. B. Mai
C. C. Un solo operando ha valore 0
D. D. Almeno un operando ha valore 0

566. Q520. La traduzione in Assembly MIPS dell'assegnamento val = b - 300 con l'associazione tra variabi e indirizzi di registri b--&gt;$s1 e val--&gt;$t0 è:
A. A. L'istruzione sub $t0, $s1, 300
B. B. L'istruzione addi $t0, $s1, -300
C. C. L'istruzione addi $s1, $t0, -300
D. D. L'istruzione sub $s1, $t0, 300

567. Q521. I campi del Formato dell'istruzione in Linguaggio Macchina MIPS 00001011111000000000011111000011 che traduce l'istruzione Assembly j NOME sono dati dalle:
A. A. Sottosequenze 000010, 11111, 00000, 00000, 11111, 000011 di lunghezze 6, 5, 5, 5, 5, 6
B. B. Sottosequenze 000010, 11111, 00000, 0000011111000011 di lunghezze 6, 5, 5, 16
C. C. Sottosequenze 000010, 11111000000000011111000011 di lunghezze 6, 26
D. D. Sottosequenze 000010, 1111100000000001, 11110, 00011 di lunghezze 6, 16, 5, 5

568. Q522. Nel Linguaggio Macchina MIPS l'Indirizzamento pseudodiretto è associato:
A. A. All'istruzione j ed al Formato di Tipo J
B. B. All'istruzione j ed al Formato di Tipo I immediato
C. C. Alle istruzioni beq e bne ed al Formato di Tipo I immediato
D. D. Alle istruzioni lw e sw ed al Formato di Tipo I immediato

569. Q526. L'istruzione Assembly MIPS ori $s0, $t3, 9 effettua:
A. A. L'OR bit a bit tra il valore contenuto nel registro $s0 e il valore 9 rappresentato nei 16 bit del campo immediato completato a 32 bit aggiungendo tutti bit uguali a 0, il risultato è posto in $t3
B. B. L'OR bit a bit tra il valore contenuto nel registro $t3 e il valore 9 rappresentato nei 16 bit del campo immediato completato a 32 bit aggiungendo tutti bit uguali a 0, il risultato è posto in $s0
C. C. Il confronto tra il valore contenuto nel registro $t3 e il valore 9 rappresentato nei 16 bit del campo immediato, e pone in $s0 il valore minore
D. D. Il confronto tra il valore contenuto nel registro $t3 e il valore 9 rappresentato nei 16 bit del campo immediato, e pone in $s0 il valore maggiore

570. Q527. Un valore la cui rappresentazione richiede più di 16 bit significativi:
A. Può essere l'operando immediato di una istruzione Assembly MIPS con Formato di Tipo I solo se è un numero positivo
B. Non può essere l'operando immediato di una istruzione Assembly MIPS con Formato di Tipo I
C. Può essere l'operando immediato di una istruzione Assembly MIPS con Formato di Tipo I utilizzando la Notazione in modulo e segno
D. Può essere l'operando immediato di una istruzione Assembly MIPS con Formato di Tipo I solo per le istruzioni con operandi unsigned

571. Q528. La moltiplicazione per 4 dell'indice k si effettua:
A. Mediante l'istruzione sll di shift logico a sinistra indicando uno shift di 4 posizioni
B. Mediante l'istruzione sld di shift logico a destra indicando uno shift di 2 posizioni
C. Mediante l'istruzione sll di shift logico a sinistra indicando uno shift di 2 posizioni
D. Mediante l'istruzione sld di shift logico a destra indicando uno shift di 4 posizioni

572. Q530. Nello standard IEEE 754 il valore MASSIMO dell'esponente polarizzato con mantissa 0 è riservato a rappresentare:
A. L'uso della notazione in complemento a 2
B. Il valore 0
C. Il valore infinito, che segnala la situazione anomale di un valore non rappresentabile per errore di overflow
D. Il minimo modulo rappresentabile

573. Q531. Il Linker effettua:
A. Il caricamento in Memoria del programma eseguibile
B. I collegamenti tra il codice oggetto del programma e il codice oggetto delle procedure che utilizza
C. L'esecuzione del programma caricato in Memoria
D. La traduzione del programma in Linguaggio Macchina

574. Q532. Una porta logica è:
A. Un dispositivo che memorizza il segnale di ingresso
B. Un circuito digitale capace di calcolare una qualsiasi funzione Booleana
C. Un dispositivo che amplifica il segnale di ingresso
D. Un circuito digitale capace di calcolare un operatore logico dell'Algebra di Boole

575. Q534. Il processo di computazione di una Rete Sequenziale è analogo a quello di una Macchina di Turing perché:
A. La Rete Sequenziale computa una funzione senza capacità di memorizzazione
B. La Rete Sequenziale può assumere un numero finito di stati e il valore dello stato successivo dipende dal valore dello stato attuale e dell'input esterno
C. La Rete Sequenziale è realizzata connettendo porte logiche
D. La Rete Sequenziale invia i risultati calcolati su dispositivi output esterni

576. Q535. L'indirizzo di accesso in Memoria utilizzato nella fase di prelievo dell'istruzione è contenuto:
A. Nel blocco dei registri del processore
B. Nel registro Program Counter
C. Sui terminali output del Sommatore che calcola l'aggiornamento dell'indirizzo
D. Nella Unità di Controllo (UC)

577. Q536. Il risultato di un calcolo determina un overflow quando:
A. Il calcolo è troppo complesso
B. La cifra più significativa della sequenza che rappresenta il risultato ha il valore 1
C. Per rappresentare il risultato è necessario un numero di bit maggiore della lunghezza dei registri del processore
D. Il risultato è uguale a 0

578. Q537. In Notazione posizionale pesata, l'addizione di due interi positivi si effettua:
A. Ponendo a 0 il riporto sulla cifra meno significativa e sommando in sequenza su ogni posizione i bit degli operandi e del riporto a partire da sinistra
B. Ponendo a 0 il riporto sulla cifra meno significativa e sommando in sequenza su ogni posizione i bit degli operandi e del riporto a partire da destra
C. Sommando in sequenza su ogni posizione i bit degli operandi e del riporto a partire da sinistra
D. Ponendo a 1 il riporto sulla cifra meno significativa e sommando in sequenza su ogni posizione i bit degli operandi e del riporto a partire da destra

579. Q538. L'estensione del segno di una sequenza con bit più significativo uguale a 1 si effettua:
A. Ponendo a sinistra di tale bit tutte cifre uguali a 1
B. Cambiando in 0 il valore di tale bit
C. Ponendo a sinistra di tale bit tutte cifre uguali a 0
D. Complementando la sequenza bit a bit ed aggiungendo 1

580. Q539. Nel Flip-Flop SR l'input S=0 ed R=1 determina:
A. Nessuna transizione perché è una configurazione input esclusa
B. La transizione dei valori output nello stato SET
C. Il mantenimento invariato dello stato rappresentato dai valori output
D. La transizione dei valori output nello stato RESET

581. Q540. Il tempo di hit:
A. A. La metrica che fornisce il tempo per sostituire un blocco nel livello superiore con un nuovo blocco copiato del livello inferiore che contiene il dato cercato
B. B. La metrica che fornisce il tempo che si spende per accedere al livello superiore della gerarchia di memorie nel caso che il dato venga trovato
C. C. La metrica che fornisce il tempo totale degli hit che si verificano nell'esecuzione di un programma
D. D. La metrica che fornisce il tempo che si spende per accedere alla Memoria Virtuale nel caso che il dato venga trovato

582. Q540. La Modalità di Indirizzamento di una istruzione in Linguaggio Macchina stabilisce:
A. A. La regola per suddividere in campi la sequenza binaria che rappresenta l'istruzione
B. B. La regola per determinare gli indirizzi degli operandi utilizzando il contenuto dei campi stabiliti dal Formato
C. C. La Notazione da utilizzare per la rappresentazione degli operandi dell'istruzione
D. D. La modalità di accesso in Memoria in lettura o in scrittura

583. Q541. Si verifica una criticità sui dati quando:
A. A. La pipeline non riceve i dati necessari a causa di un Page Fault
B. B. Le risorse Hardware presenti non sono in grado di supportare le operazioni richieste da diverse fasi della pipeline in esecuzione
C. C. Il prelievo di una istruzione nella fase di Fetch dipende dall' esito del test di una istruzione di salto condizionato in esecuzione nella pipeline
D. D. Una fase deve aspettare i risultati delle operazioni eseguite in un altra fase della pipeline

584. Q542. La traduzione in Assembly MIPS dell'OR bit a bit con operandi nei registri $s1 e $s2 e risultato nel registro $t0 è:
A. A. L'istruzione or $s1, $s2, $t0
B. B. L'istruzione or t0, s1, s2
C. C. L'istruzione or $t0, $s1, $s2
D. D. L'istruzione or $s1, $t0, $s2

585. Q543. L'esecuzione dell'istruzione Assembly MIPS addi $s7, $t0, -35 ha l'effetto di:
A. A. Addizionare -35 al contenuto del registro di indirizzo $s7 e scrivere il risultato come contenuto del registro di indirizzo $t0
B. B. Addizionare i contenuti dei registri di indirizzi $s7 e $t0 a -35 e scrivere il risultato come contenuto del registro di indirizzo $s7
C. C. Addizionare -35 al contenuto del registro di indirizzo $t0 e scrivere il risultato come contenuto del registro di indirizzo $s7
D. D. Copiare -35 nel registro di indirizzo $t0 e addizionare al contenuto del registro di indirizzo $s7

586. Q544. Il contenuto di una locazioni della Memoria principale MIPS è dato da:
A. A. Una sequenza di 64 bit
B. B. Una sequenza di 32 bit
C. C. Una sequenza di 5 bit
D. D. Una sequenza di 8 bit

587. Q547. La traduzione in Assembly di un ciclo WHILE di un programma in Linguaggio ad Alto Livello determina un ciclo infinito:
A. A. Quando la condizione logica di controllo del ciclo risulta falsa
B. B. Mai perché l'istruzione Assembly che corrisponde al WHILE esegue solo un numero finito di cicli
C. C. Quando manca l'inizializzazione della variabile di controllo del ciclo
D. D. Quando il WHILE del programma in Linguaggio ad Alto Livello determina un ciclo infinito

588. Q548. Nel Linguaggio Macchina MIPS il ritorno alla esecuzione del programma chiamante è effettuato:
A. Da una istruzione contenuta nel call-stack
B. Mediante l'esecuzione della istruzione jal che alla fine della procedura effettua il salto di ritorno al programma chiamante
C. Mediante l'esecuzione della istruzione j che alla fine della procedura effettua il salto di ritorno al programma chiamante
D. Mediante l'esecuzione della istruzione jr che alla fine della procedura effettua il salto di ritorno al programma chiamante

589. Q549. L'errore di call stack overflow avviene quando:
A. Il numero delle chiamate di procedura effettuate non può essere rappresentato con 32 bit
B. Si esaurisce lo spazio di Memoria assegnato alla struttura dati call stack
C. Una procedura chiamata calcola un valore che non può essere rappresentato con 32 bit nel call stack
D. Il numero dei parametri della procedura non può essere rappresentato con 5 bit nel call stack

590. Q552. L'operazione effettuata dall'esecuzione dell'istruzione sb $t0, 30($s1) è:
A. Leggere la sequenza di 8 bit contenuti in una locazione di Memoria e scriverla negli 8 bit meno significativi del registro $t0 di 32 bit, con estensione del segno a 32 bit
B. Scrivere la sequenza di 8 bit in una locazione di Memoria dopo averla letta negli 8 bit meno significativi del registro
C. $t0
D. Leggere la sequenza di 16 bit contenuti in due locazioni successive di Memoria e scriverla nei 16 bit meno significativi del registro $t0 di 32 bit, ponendo a 0 il valore dei rimanenti bit

591. Scrivere 16 bit in due locazioni successive di Memoria dopo averli letti dai 16 bit meno significativi del registro $t0
A. Q554. Una pseudoistruzione è:
B. Una istruzione del Linguaggio Assembly non implementata a livello Hardware, che esegue operazioni mediante altre istruzioni Assembly implementate
C. La traduzione in Linguaggio Macchina della corrispondente istruzione in Linguaggio Assembly
D. L'istruzione in Linguaggio ad alto Livello che corrisponde ad una istruzione in Linguaggio Assembly

592. Una istruzione non sintatticamente corretta che viene segnalata come errore dal programma traduttore Assembler
A. Q561. Quando l'Unità di Controllo termina il calcolo dei valori dei segnali di controllo l'esecuzione dell'istruzione viene completata dalla Unità di Elaborazione Dati effettuando:
B. La lettura in Memoria della sequenza binaria che rappresenta l'istruzione in Linguaggio Macchina
C. La lettura nel Program Counter della sequenza binaria che rappresenta l'istruzione in Linguaggio Macchina
D. Le operazioni relative all'istruzione e la scrittura dei registri

593. La lettura del campo Codice Operativo
A. Q561. I problemi che possono essere risolti con un algoritmo sono:
B. Tutti i problemi
C. Solo i problemi con meno di un miliardo di dati
D. Solo i problemi con soluzione numerica

594. Un sottoinsieme di tutti i problemi
A. Q563. Gli indirizzi dei registri del Processore MIPS sono:
B. Sequenze binarie contenute nei registri del processore
C. I 32 numeri numeri da 1 a 32
D. I 32 numeri da 0 a 31

595. Sequenze binarie fornite da dispositivi esterni
A. Q564. La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione m=m+k; con l'associazione k--&gt; $s3 m-- &gt; $s0 è:
B. add $s3, $s0, $s0
C. add $s0, $s0, $s0
D. addi $s3, $s0, 2

596. add $s0, $s0, $s3
A. Q568. Il Formato dell'istruzione in Linguaggio Macchina MIPS 00000010000100010100000000100101 è:
B. Di Tipo I
C. Di Tipo K
D. Di Tipo J

597. Di Tipo R
A. Q569. Per l'istruzione load word la modalità di indirizzamento tramite Base e Offset calcola:
B. L'indirizzo di una parola di Memoria da cui leggere un dato
C. L'indirizzo di un registro del processore da cui leggere un dato
D. L'indirizzo di una locazione di Memoria in cui scrivere un dato

598. L'indirizzo di un registro del processore in cui scrivere un dato
A. Q570. Nel Linguaggio Macchina MIPS, la Modalità di Indirizzamento dell'istruzione store word calcola:
B. L'indirizzo del primo Byte della parola di Memoria dove leggere il dato da scrivere in un registro
C. L'indirizzo del registro che contiene l'operando da scrivere in Memoria
D. L'indirizzo del registro dove scrivere una copia dell'operando letto dalla Memoria

599. L'indirizzo del primo Byte della parola di Memoria dove scrivere il dato letto da un registro
A. Q571. L'Indirizzamento pseudodiretto completa i 26 bit nel campo del formato di Tipo J mediante:
B. L'estensione del segno a 32 bit
C. L'estensione del segno a 32 bit e la moltiplicazione per 4
D. L'aggiunta dei bit più significativi del Program Counter a sinistra

600. L'aggiunta di due bit 00 a destra, e dei 4 bit più significativi del Program Counter a sinistra
A. Q572. Le istruzioni Assembly MIPS con Codici Operativi addu e subu eseguono:
B. Addizione e sottrazione di operandi unsigned contenuti in due registri del processore
C. Addizione e sottrazione di operandi con segno contenuti in due registri del processore
D. Addizione e sottrazione di operandi unsigned contenuti in Memoria

601. Addizione e sottrazione di operandi con segno contenuti in Memoria
A. Q574. La traduzione in Assembly MIPS dell'assegnamento val = A[8] con $t4 registro Base dell'Array di caratteri Unicode a 16 bit A[] e assegnado il registro $s2 alla variabile val è data:
B. Dall'istruzione lbu $s2, 8 ($t4)
C. Dall'istruzione sh $s2, 16 ($t4)
D. Dall'istruzione sw $t4, 32 ($s2)

602. Dall'istruzione lhu $s2, 16 ($t4)
A. Q575. L'errore di arrotondamento è:
B. Minore del valore del peso associato alla cifra meno significativa della rappresentazione troncata
C. Maggiore del valore del peso associato alla cifra meno significativa della rappresentazione troncata
D. Uguale ad uno

603. Minore di 0.001
A. Q576. Nello standard IEEE 754 il numero 0 è rappresentato da una sequenza:
B. Con bit tutti uguali a 1
C. Con mantissa 0 ed esponente 0
D. Con mantissa 0 ed esponente dato dalla sequenza di tutti bit uguali ad 1

604. Con esponente 0 e mantissa data dalla sequenza di tutti bit uguali ad 1
A. Q578. L'Analisi di una Rete Combinatoria si effettua:
B. Verificando che ad una sequenza di valori posta sui terminali input corrisponde sempre lo stesso valore sui terminali output
C. In due passi, associando alla Rete Combinatoria la equivalente Espressione Booleana e valutando la funzione Booleana realtiva a tale Espressione
D. Convertendo la sequenza binaria ottenuta sui terminali output in notazione decimale

605. In due passi, determinando l'Espressione canonica Somma di Prodotti della funzione Booleana e costruendo la Rete Combinatoria ad essa associata
A. Q582. La tecnica di Temporizzazione sensibile ai fronti utilizzata per sincronizzare una Rete Sequenziale sceglie uno dei fronti del segnale di clock (di salita o di discesa), detto "fronte attivo", come istante di tempo in cui:
B. Memorizzare il cambiamento di stato nei registri della Rete Sequenziale
C. Eseguire i calcoli nella parte combinatoria della Rete Sequenziale
D. Avviare l'esecuzione del programma

606. Consentire la lettura di dati provenienti da dispositivi esterni
A. Q584. In ogni transizioni di stato della Macchina di Turing lo stato successivo dipende:
B. Dalla lunghezza della sequenza scritta sul nastro
C. Dallo stato attuale e dal simbolo letto sul nasto
D. Dal primo stato assunto dalla macchina

607. Dal numero totale degli stati
A. Q585. La Sintassi di un Linguaggio Formale stabilisce:
B. Il significato dell'istruzione
C. Le regole per rappresentare i numeri con segno
D. Le regole per scrivere ogni istruzione del Linguaggio Formale in modo corretto

608. Le regole per eseguire l'istruzione
A. Q586. Il registro destinazione nell'istruzione add $s2, $t0, $t1 è:
B. $s2
C. $t1
D. $t0

609. $t2
A. Q587. Nella Notazione in complemento a 2, la somma di due interi con segni opposti viene eseguita:
B. Sottraendo il numero di modulo minore dal numero di modulo maggiore
C. Addizionando al primo l'opposto del secondo
D. Sottraendo dal primo l'opposto del secondo

610. Addizionando i due numeri
A. Q588. I termini hit rate e miss rate indicano:
B. Le metriche che forniscono rispettivamente il tempo medio necessario per stabilire se si è verificato un hit o un miss nel trovare un elemento nel livello superiore della gerarchia di memorie
C. Le metriche che forniscono rispettivamente il tempo speso per gli hit e i miss che si verificano in un intervallo di tempo in una gerarchia di memorie
D. Le metriche che forniscono rispettivamente la frequenza di hit e la frequenza di miss che si verificano in un fissato numero di accessi in memoria.

611. Le metriche che forniscono rispettivamente il numero totale di hit e di miss che si verificano nell'esecuzione di un programma
A. Q588. Nella Notazione in complemento a 2, la sequenza binaria 0101 rappresenta:
B. Il valore +5
C. Il valore +3
D. Il valore -5

612. Il valore -3
A. Q589. La MMU (Memory Management Unit) è:
B. Un dispositivo Hardware che effettua il prelievo dei dati presenti nella cache
C. Un dispositivo Hardware per la gestione dei livelli di una gerarchia di memorie che fornisce la traduzione degli indirizzi del livello superiore in indirizzi della memoria di massa
D. Un dispositivo Hardware per la gestione della Memoria Virtuale che fornisce la traduzione degli indirizzi virtuali in indirizzi fisici della Memoria principale

613. Un dispositivo Hardware per assegnare lo spazio della cache alle operazioni del Sistema operativo
A. Q589. Nella Notazione in complemento a 2, la sequenza binaria 1001 rappresenta:
B. Il valore +7
C. Il valore -5
D. Il valore -7

614. Il valore +5
A. Q590. Si verifica una criticità sul controllo quando:
B. Una fase deve aspettare i risultati delle operazioni eseguite in un altra fase della pipeline
C. Il prelievo di una istruzione nella fase di Fetch dipende dall' esito del test di una istruzione di salto condizionato in esecuzione nella pipeline
D. Le risorse Hardware presenti non sono in grado di supportare le operazioni richieste da diverse fasi della pipeline in esecuzione

615. La pipeline non riceve i dati necessari a causa di un Page Fault
A. Q591. Nel Linguaggio Macchina MIPS, il campo shamt del Formato di Tipo R contiene:
B. L'indicazione di shift a sinistra o shift a destra
C. L'indirizzo del registro dell'operando
D. Il codice della funzione shift

616. Il numero di posizioni da scorrere nelle istruzioni di shift, altrimenti 0
A. Q592.	Nel Linguaggio Macchina MIPS, la suddivisione in campi dell'istruzione 00100001000010011000000000100101 con Formato di Tipo I è data:
B. Dalle sequenze 0010000100001001, 10000, 00000, 100101
C. Dalle sequenze 001000, 01000, 01001, 10000, 00000, 100101
D. Dalle sequenze 001000, 01000, 010011000000000, 100101

617. Dalle sequenze 001000, 01000, 01001, 1000000000100101
A. Q598. L'istruzione in Linguaggio Macchina MIPS che traduce set on less then immediato ha:
B. Formato di Tipo I e Indirizzamento pseudodiretto
C. Formato di Tipo I e Indirizzamento tramite Base e Offset
D. Formato di Tipo R e Indirizzamento immediato

618. Formato di Tipo I e Indirizzamento immediato
A. Q599. L'assegnamento val='A' con val corrispondente al registro $s1 si traduce in Assembly MIPS:
B. Con l'istruzione add $s1, $zero, 'A'
C. Con l'istruzione ori $s1, $zero, 65
D. Con l'istruzione ori $s1, $zero, 'A'

619. Con l'istruzione ori $zero, $s1, 65
A. Q602. Nello standard IEEE 754 le cifre significative del numero rapresentato si ottengono:
B. Considerando la sequenza binaria contenuta nel campo mantissa come parte intera, e 0 come parte frazionaria
C. Considerando 0 come parte intera, e la sequenza binaria contenuta nel campo mantissa come parte frazionaria
D. In base alla sequenza binaria contenuta nel campo esponente

620. Considerando un bit sottinteso uguale a 1 come parte intera, e la sequenza binaria contenuta nel campo mantissa come parte frazionaria
A. Q603. La notazione in doppia precisione consente:
B. Di eliminare l'errore di underflow e di estendere l'intervallo del minimo e massimo modulo rappresentabile
C. Di eliminare l'errore di arrotondamento e di estendere l'intervallo del minimo e massimo modulo rappresentabile
D. Di estendere l'intervallo del minimo e massimo modulo rappresentabile aumentando l'esponente, e di ridurre l'errore di arrotondamento aumentando il numero di cifre significative

621. Di rappresentare tutte le cifre significative del numero
A. Q604. Nello standard IEEE 754 il valore 0 dell'esponente polarizzato con mantissa diversa da 0 è riservato a rappresentare:
B. L'uso della notazione dei numeri denormalizzati che restringe l'intervallo dei numeri per i quali si ha l'errore di underflow
C. L'uso della notazione in complemento a 2
D. Il valore 0

622. Il massimo modulo rappresentabile
A. Q605. Nel Linguaggio Assembly del MIPS il simbolo $ seguito da caratteri alfanumerici rappresenta:
B. Il contenuto di un registro del processore
C. il valore dell'operando di una istruzione
D. L'indirizzo di un registro del processore

623. La sequenza di 32 bit che fornisce l'operando di una istruzione
A. Q607. La traduzione in Assembly MIPS dell'assegnamento val = A[3], associando a val il registro di indirizzo $t0, ed assumendo che l'indirizzo del registro Base dell'Array di numeri interi è $s1, è data da:
B. L'istruzione sw $s1, 12 ($t0)
C. L'istruzione sw $t0, 12 ($s1)
D. L'istruzione lw $s1, 12 ($t0)

624. L'istruzione lw $t0, 12 ($s1)
A. Q609. L'indirizzo di Memoria dell'elemento B[9] di un Array di numeri interi è dato da:
B. L'indirizzo dell'elemento B[0] sommato all'Offset 9
C. L'indirizzo del primo Byte dell'elemento B[9] ottenuto sommando l'Offset 9 al contenuto del registro Base dell'Array
D. L'indirizzo del primo Byte dell'elemento B[9] ottenuto sommando l'Offset 36 al contenuto del registro Base dell'Array

625. L'indirizzo dell'elemento B[1] sommato all'Offset 9
A. Q610. Per la realizzazione della CPU a ciclo singolo, l'Unità di Controllo e l'Unità di controllo dell'ALU sono implementate mediante:
B. Due multiplexer separati, realizzati sulla base delle funzioni Booleane costituite dalle relazioni input-output che forniscono i valori dei segnali di controllo per l'esecuzione delle istruzioni
C. Due Reti Combinatorie separate, realizzate sulla base delle funzioni Booleane costituite dalle relazioni input-output che forniscono i valori dei segnali di controllo per l'esecuzione delle istruzioni
D. Una Rete Sequenziale che mediante transizioni di stato consente di tenere memoria della successione delle operazioni relative alla esecuzione dell'istruzione

626. La memorizzazione nei Registri del processore delle Tavole di verità delle relazioni input-output che forniscono i valori dei segnali di controllo per l'esecuzione delle istruzioni
A. Q610. L'istruzione FOR nel Linguaggio Assembly:
B. Viene tradotta da una analoga istruzione FOR che permette l esecuzione ripetuta di istruzioni fino a quando il valore di verità di una espressione logica è vero
C. Non ha una corrispondente istruzione e viene tradotta combinando istruzioni di salto condizionato ed incondizionato
D. Viene tradotta come una chiamata di procedura che permette l esecuzione ripetuta di istruzioni fino a quando il valore di verità di una espressione logica è vero

627. Viene tradotta scrivendo un numero di copie delle istruzioni da ripetere pari al numero di ripetizioni
A. Q611. Nel Flip-Flop SR l'input S=1 ed R=1 determina:
B. La transizione dei valori output nello stato RESET
C. La transizione dei valori output nello stato SET
D. Nessuna transizione perché è una configurazione input esclusa

628. Il mantenimento invariato dello stato rappresentato dai valori output
A. Q611. La traduzione della inizializzazione del ciclo FOR in Linguaggio Assembly è posta:
B. Prima dell'insieme di istruzioni che viene ciclicamente ripetuto
C. All'interno dell'insieme di istruzioni che viene ciclicamente ripetuto
D. All'interno dell'istruzione Assembly che corrisponde a FOR

629. All'uscita del ciclo FOR
A. Q613. L'operazione effettuata dall'esecuzione dell'istruzione sh $t0, 30($s1) è:
B. Scrivere la sequenza di 8 bit in una locazione di Memoria dopo averla letta negli 8 bit meno significativi del registro
C. $t0
D. Leggere la sequenza di 16 bit contenuti in due locazioni successive di Memoria e scriverla nei 16 bit meno significativi del registro $t0 di 32 bit, ponendo a 0 il valore dei rimanenti bit

630. Leggere la sequenza di 8 bit contenuti in una locazione di Memoria e scriverla negli 8 bit meno significativi del registro $t0 di 32 bit, con estensione del segno a 32 bit
A. Scrivere la sequenza di 16 bit in due locazioni successive di Memoria dopo averla letta nei 16 bit meno significativi del registro $t0
B. Q614. Le istruzioni lhu, sh possono essere utilizzate:
C. Per il trasferimento di caratteri Unicode a 16 bit e di valori dichiarati short
D. Per il trasferimento di caratteri ASCII

631. Per il trasferimento di valori dichiarati int
A. Per il trasferimento di valori dichiarati long
B. Q618. In Notazione polarizzata il valore del numero rappresentato dalla sequenza binaria si ottiene:
C. Calcolando il valore in modulo e segno
D. Sottraendo la costante di polarizzazione dal valore della sequenza binaria calcolato in Notazione posizionale pesata

632. Addizionando la costante di polarizzazione al valore della sequenza binaria calcolata in Notazione posizionale pesata
A. Sottraendo la costante di polarizzazione al valore della sequenza binaria calcolato in Notazione in complemento a 2
B. Q619. La Rete Combinatoria corrispondente ad una Espressione canonica Somma di Prodotti è detta:
C. Rete completa
D. Rete canonica

633. Rete Booleana
A. Rete AND to OR
B. Q622. La pseudoistruzione dell'Assembly MIPS not $s1, $t0 è eseguita mediante:
C. A. L'istruzione sub $s1, $zero, $t0
D. B. L'istruzione nor $s1, $t0, $zero

634. C. L'istruzione or $s1, $t0, $zero
A. D. L'istruzione and $s1, $t0, $zero
B. Q625. Se l'istruzione in esecuzione non richiede operandi, la lettura anticipata dei due Registri, fatta dopo la fase di Prelievo mentre l'Unità di Controllo calcola il valore dei segnali di controllo, risulta:
C. A. Utile perché serve per calcolare l'indirizzo della prossima istruzione da eseguire
D. B. Utile perché serve per calcolare l'indirizzo da scrivere nel Program Counter

635. C. Utile perché serve per leggere il codice operativo dell'istruzione
A. D. Inutile, ma	non determina spreco di tempo perché è effettuata contemporaneamente ad altre operazioni necessarie per l'esecuzione dell'istruzione
B. 625. L'Assembler è:
C. A. Un programma che traduce un programma scritto in Assembly in un programma scritto in Linguaggio Macchina
D. B. Un linguaggio di programmazione

636. C. Un programma che traduce un programma scritto in un Linguaggio ad Alto Livello in un programma scritto in Linguaggio Macchina
A. D. Un programma che traduce un programma scritto in Linguaggio Macchina in un programma scritto in Assembly
B. Q626. Per specificare l'indirizzo di un registro del processore MIPS occorre:
C. A. Una sequenza di 32 bit
D. B. Una sequenza di 16 bit

637. C. Una sequenza di 8 bit
A. D. Una sequenza di 5 bit
B. Q628. In Notazione in complemento a 2, la sottrazione di due operandi si esegue:
C. A. Addizionando al primo operando il secondo complementato bit a bit
D. B. Sottraendo dal primo operando il secondo

638. C. Addizionando al primo operando il secondo complementato bit a bit e sommato con il valore 1
A. D. Sottraendo l'operando con modulo minore da quello con modulo maggiore
B. Q631. La relazione che lega la frequenza di clock al periodo di clock è data da:
C. A. Frequenza diviso periodo uguale a 1
D. B. Frequenza uguale all'inverso del periodo

639. C. Frequenza più periodo uguale tempo di CPU
A. D. Frequenza uguale a 1 meno periodo
B. Q631. L'istruzione del Linguaggio Macchina MIPS che traduce l'istruzione Assembly j NOME ha:
C. A. Formato di Tipo J e Indirizzamento relativo al Program Counter
D. B. Formato di Tipo J e Indirizzamento pseudodiretto

640. C. Formato di Tipo I e Indirizzamento immediato
A. D. Formato di Tipo I e Indirizzamento relativo al Program Counter
B. Q632. Utilizzando il periodo di clock, il tempo di CPU utente relativo alla esecuzione di un programma può essere calcolato con la formula:
C. Numero di cicli di clock impiegati per l'esecuzione del programma meno il periodo di clock
D. Numero di cicli di clock impiegati per l'esecuzione del programma diviso per il periodo di clock

641. Numero di cicli di clock impiegati per l'esecuzione del programma più il periodo di clock
A. Numero di cicli di clock impiegati per l'esecuzione del programma moltiplicato per il periodo di clock
B. Q632. L'esecuzione dell'istruzione Assembly MIPS slti $s1, $t2, 35:
C. Sottrae al contenuto del registro di indirizzo $t2 il valore costante 35, e pone il risultato in $s1
D. Stabilisce se il contenuto del registro di indirizzo $t2 è minore del valore costante 35, e pone in $s1 il valore 1 se la relazione è vera altrimenti pone 0

642. Stabilisce se il contenuto del registro di indirizzo $s1 è minore del valore costante 35, e pone in $t2 il valore 1 se la relazione è vera altrimenti pone 0
A. Stabilisce se il contenuto del registro di indirizzo $t2 è minore del valore costante 35, e pone in $s1 il contenuto di
B. $t2 se la relazione è vera altrimenti pone 35
C. Q634. Per l'implementazione della tecnica di pipelining è necessario:
D. Aggiungere delle General Purpose GPU tra cui suddividere l'esecuzione delle istruzioni in parallelo

643. Aggiungere delle CPU tra cui suddividere l'esecuzione delle istruzioni in parallelo
A. Aggiungere dei registri per memorizzare le informazioni necessarie alla esecuzione in parallelo delle istruzioni
B. Aggiungere dei bus di comunicazione tra le CPU che concorrono alla esecuzione in parallelo delle istruzioni
C. Q636. L'errore di underflow si verifica quando:
D. Il numero da rappresentare ha modulo minore del massimo modulo rappresentabile

644. Il numero da rappresentare ha modulo maggiore del minimo modulo rappresentabile
A. Il numero da rappresentare ha modulo minore del minimo modulo rappresentabile
B. Il numero da rappresentare ha modulo maggiore del massimo modulo rappresentabile
C. Q638. La conversione di una sequenza binaria nella corrispondente rappresentazione ottale si può effettuare direttamente:
D. Calcolando il valore della sequenza binaria utilizzando come pesi potenze della base 8

645. Suddividendo la sequenza binaria in gruppi di 4 simboli a partire da destra (cifre meno significative), e sostituendo ad ogni gruppo il corrispondente simbolo della base 16
A. Suddividendo la sequenza binaria in gruppi di 3 simboli a partire da destra (cifre meno significative), e sostituendo ad ogni gruppo il corrispondente simbolo della base 8
B. Calcolando il valore in base 10 e determinando la sequenza corrispondente in base 8
C. Q641. La funzione Booleana calcolata da una Rete Combinatoria è:
D. La funzione che fornisce il numero intero rappresentato dalla sequenza binaria costituita dall'output della rete

646. La funzione che fornisce la sequenza binaria che rappresenta lo stato della rete
A. La funzione corrispondente all'operatore logico che fornisce l'output della rete
B. La funzione binaria di variabili binarie che fornisce la corrispondenza tra i valori applicati ai terminali input della rete e i valori che si ottengono sui terminali output della rete
C. Q644. I criteri di minimizzazione di un circuito digitale cercano di ridurre:
D. Il costo del circuito digitale

647. Il numero dei terminali output del circuito digitale
A. Il numero dei terminali input del circuito digitale
B. Lo spazio occupato e la velocità del circuito digitale
C. Q645. Il riporto CarryIn0 input dell'ALU ad un bit relativa alla posizione meno significativa è utilizzato:
D. Come segnale di controllo posto al valore 0 nel caso dell'Addizione, e al valore 1 nel caso della Sottrazione; negli altri casi il suo valore non influenza il risultato

648. Per l'esecuzione delle istruzioni relative agli operatori logici AND, OR
A. Per il controllo dell'Overflow nell'esecuzione dell'Addizione
B. Sempre con il valore 0
C. Q645. Il Formato di una istruzione in Linguaggio Macchina è definito da:
D. Una regola per il calcolo degli indirizzi degli operandi dell'istruzione

649. Una suddivisione fisica della sequenza binaria che rappresenta l'istruzione in sottosequenze di lunghezza e posizione fissata
A. Una suddivisione concettuale della sequenza binaria che rappresenta l'istruzione in sottosequenze di lunghezza e posizione fissata
B. Una regola che stabilisce la Notazione degli operandi dell'istruzione
C. Q646. Nel Linguaggio Macchina MIPS, il campo Codice Operativo di una istruzione stabilisce:
D. La Notazione da adottare per gli operandi

650. L'indirizzo dove memorizzare il risultato dell'esecuzione dell'istruzione
A. L'operazione da eseguire ed il Formato dell'istruzione
B. Se l'istruzione è una addizione oppure una sottrazione
C. Q647. In una Rete Sequenziale il segnale periodico clock è utilizzato per:
D. Sospendere l'esecuzione del programma per consentire la lettura di dati provenienti da dispositivi esterni

651. Interrompere l'esecuzione di un programma se diventa troppo lunga
A. Individuare l'istante in cui avviene il cambiamento di stato della Rete Sequenzialecon con la scrittura dei registri, e assicurare la stabilità dei valori dei segnali calcolati
B. Avviare l'esecuzione del programma
C. Q647. Le lunghezze dei campi dell'istruzione in Linguaggio Macchina MIPS che traduce l'istruzione Assembly add $t0, $s0, $s1 sono:
D. I valori 6, 5, 5, 16

652. I valori 6, 5, 5, 5, 5, 6
A. I valori 7, 5, 5, 5, 5, 5
B. I valori 5, 5, 5, 5, 6, 6
C. Q648. L'Unità Centrale di Elaborazione (CPU) è una Rete Sequenziale costituita da:
D. L'Unità di Controllo e la Memoria

653. L'Unità di Controllo e l'Unità di Elaborazione Dati (datapath)
A. L'Unità Aritmetico Logica (ALU) e la Memoria
B. L'Unità di Elaborazione Dati (datapath) e la Memoria
C. Q648. Le istruzioni del Linguaggio Macchina MIPS con Codice operativo 0 hanno:
D. Il Formato di Tipo I

654. Il Formato di Tipo S
A. Il Formato di Tipo R
B. Il Formato di Tipo J
C. Q649. I dispositivi di memorizzazione posti all'interno della Unità Centrale di Elaborazione a ciclo singolo del MIPS (CPU) sono:
D. Il registro Program Counter

655. Il registro Program Counter ed il blocco dei 32 Registri del processore.
A. Il blocco dei 32 Registri del processore
B. La Memoria e l'ALU
C. Q649. La suddivisione in campi dell'istruzione in Linguaggio Macchina MIPS 00000010000100010100000000100000 in base al suo Formato è data:
D. Dalle sottosequenze 0000001, 000010001, 010000000, 0100000

656. Dalle sottosequenze 0000001, 00001, 00010, 10000, 00001, 00000
A. Dalle sottosequenze 000000, 10000, 10001, 01000, 00000, 100000
B. Dalle sottosequenze 000000, 10000, 10001, 0100000000100000
C. Q650. Nell'istruzione in Linguaggio Macchina MIPS con valori dei campi del Formato dati da 000000, 01000, 01001, 10000, 00000, 100010 l'indirizzo del registro che contiene il risultato è:
D. Il campo 01000

657. Il campo 01001
A. Il campo 100010
B. Il campo 10000
C. Q651. La traduzione in Assembly MIPS dell'assegnamento val = A[0], associando a val il registro di indirizzo $t0, ed assumendo che l'indirizzo del registro Base dell'Array di numeri interi è $s1, è data da:
D. L'istruzione sw $s1, 0 ($t0)

658. L'istruzione sw $t0, 0 ($s1)
A. L'istruzione lw $t0, 0 ($s1)
B. L'istruzione lw $s1, 0 ($t0)
C. Q653. Nel Linguaggio Macchina MIPS i valori dei parametri vengono passati alla procedura chiamata:
D. Nella esecuzione del programma chiamante scrivendoli nei registri $a0, $a1, $a2, $a3 prima di effettuare il salto alla esecuzione della procedura

659. Nella esecuzione del programma chiamante scrivendoli nei registri $v0, $v1 prima di effettuare il salto alla esecuzione della procedura
A. Nella esecuzione del programma chiamante scrivendoli nel registro $ra prima di effettuare il salto alla esecuzione della procedura
B. Nella esecuzione del programma chiamante scrivendoli nei registri $t e $s durante l'esecuzione della procedura
C. Q655. Nel Linguaggio macchina MIPS il Formato e la Modalità di Indirizzamento dell'istruzione jal sono:
D. Formato di Tipo I e Indirizzamento relativo al Program Counter

660. Formato di Tipo R e Indirizzamento immediato
A. Formato di Tipo J e Indirizzamento pseudodiretto
B. Formato di Tipo J e Indirizzamento tramite registro
C. Q656. La traduzione in Assembly MIPS dell'assegnamento testo[9] = val con $t1 registro Base dell'Array di caratteri ASCII testo[] e assegnado il registro $s5 alla variabile val è data:
D. Dell'istruzione lbu $s5, 9 ($t1)

661. Dell'istruzione sb $t1, 9 ($s5)
A. Dell'istruzione sb $s5, 9 ($t1)
B. Dell'istruzione sb $s5, 36 ($t1)
C. Q657. Nello standard IEEE 754 precisione SINGOLA le 24 cifre binarie significative corrispondono:
D. A 12 cifre decimali significative

662. A 15 cifre decimali significative
A. A 7 cifre decimali significative
B. A 11 cifre decimali significative
C. Q658. I numeri dichiarati float con più di 7 cifre decimali significative sono rappresentati:
D. Con 32 bit in notazione in complemento a 2

663. Con 32 bit nello standard IEEE 754 singola precisione con errore di arrotondamento
A. Con 64 bit nello standard IEEE 754 doppia precisione con errore di arrotondamento
B. Con 32 bit nello standard IEEE 754 singola precisione sempre in maniera esatta
C. Q659. L'Algebra di Boole è:
D. L'insieme degli elementi {0, 1}

664. L'insieme degli elementi "vero" e "falso"
A. Una struttura di calcolo definita da un Dominio costituito da due elemeti e dagli operatori AND, OR e NOT
B. Un insieme di due elementi cui si attribuiscono i valori di verità "vero" e "falso"
C. Q664. La Macchina di Turing e la Macchina di Von Neuman sono:
D. Computer che non vengono più venduti

665. Modelli di computer che risolvono specifici problemi matematici
A. Computer di marca diversa
B. Modelli teorici di computazione algoritmica
C. Q666. Rispetto alla Macchina di Turing la Macchina di Von Neuman risolve:
D. Un numero di problemi minore

666. Gli stessi problemi
A. Un numero di problemi maggiore
B. Solo i problemi con soluzione numerica
C. Q668. La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione max=200; con l'associazione max--&gt; $s5 è:
D. addi $s5, $s5, 200

667. add $s5, $zero, 200
A. sub $s5, $zero, 200
B. addi $s5, $zero, 200
C. Q669. L'attivazione della Scrittura nei 32 Registri del processore MIPS è controllata mediante:
D. Il segnale di controllo MemWrite

668. Il segnale output dell'AND tra il segnale di controllo RegWrite e l'output del decodificatore relativo a ciascun registro
A. Il segnale output dell'AND tra il segnale di controllo MemWrite e l'output del decodificatore relativo a ciascun registro
B. Un multiplexer che controlla la scelta del registro
C. Q671. In una gerarchia di memorie, il livello più vicino alla CPU è:
D. Più veloce e meno grande

669. Meno veloce e più grande
A. Più veloce e più grande
B. Meno veloce e meno grande
C. Q672. Si verifica un page fault quando:
D. Si richiede l'accesso ad una pagina della Memoria Virtuale che non corrisponde ad una pagina della Memoria principare perché la pagina cercata risiede nella memoria di massa

670. Il dato non viene trovato nella relativa pagina nell'accesso al livello superiore della gerarchia di memoria costituito dalla cache
A. Il dato non viene trovato nella relativa pagina contenuta nel livello più basso della gerarchia di memorie
B. Si richiede l'accesso ad una pagina della Memoria Virtuale che corrisponde ad una pagina della Memoria principare
C. Q672. Le dimensioni di 1 Kappa, 1 Mega, 1 Giga corrisponsono:
D. Ai valori 1 Kappa = circa un Milione, 1 Mega= circa un Miliardo, 1 Giga = circa Mille Miliardi

671. Ai valori 1 Kappa = circa Cento, 1 Mega= circa Mille, 1 Giga = circa un Milione
A. Ai valori 1 Kappa = circa Mille, 1 Mega= circa un Milione, 1 Giga = circa un Miliardo
B. Ai valori 1 Kappa = circa Mille, 1 Mega= circa 10 Milioni, 1 Giga = circa 10 Miliardi
C. Q676. Rappresentando i numeri frazionari con sequenze di lunghezza fissata si può:
D. Rappresentare con esattezza tutti i numeri compresi tra il minimo ed il massimo rappresentabili

672. Rappresentare con esattezza un sottoinsieme finito di numeri nell'intervallo compreso tra il minimo ed il massimo rappresentabili, e con errore di arrotondamento i rimanenti infiniti numeri in tale intervallo
A. Rappresentare con esattezza solo i numeri interi compresi tra il minimo ed il massimo rappresentabili
B. Rappresentare con esattezza solo i numeri razionali compressi tra il minimo ed il massimo rappresentabili, e con errore di arrotondamento gli irrazionali
C. Q679. Un Interprete Java è:
D. Uno specifico dispositivo Hardware interno al computer che emula la Java Virtual Machine

673. Un programma Software che esegue il bytecode Java emulando la Java Virtual Machine su una specifica piattaforma
A. Una implementazione Harware dell'Architettura della Java Virtual Machine
B. Il programma scritto dall'utente in Linguaggio ad Alto Livello Java
C. Q681. Le funzioni Booleane sono:
D. Solo le funzioni di due variabili AND e OR

674. Tutte le funzioni binarie di variabili binarie
A. Le funzioni che calcolano le operazioni aritmetiche con due operandi
B. Solo le funzioni AND, OR e NOT
C. Q682. I registri del Processore MIPS con indirizzi da $t0 a $t9 e da $s0 a $s7 sono utilizzati per:
D. Memorizzare sequenze di 32 bit che rappresentano gli indirizzi degli operandi delle istruzioni

675. Gestire la chiamata di procedura
A. Gestire le funzioni svolte dal Software di Sistema
B. Memorizzare sequenze di 32 bit che rappresentano il valore degli operandi delle istruzioni
C. Q683. L'overflow può verificarsi:
D. Addizionando numeri con lo stesso segno

676. Addizionando numeri con segni diversi
A. Mai con numeri negativi
B. Mai addizionando numeri con lo stesso segno
C. Q684. Per le istruzioni Aritmetico-Logiche del Linguaggio Macchina MIPS il campo Codice Operativo contiene:
D. La sequenza di 5 bit 00000

677. La sequenza di 6 bit 100000
A. La sequenza di 6 bit 000000
B. La sequenza di 5 bit 00001
C. Q685. La traduzione	in Assembly MIPS dello Shift a sinistra di 4 posizioni con registro operando $s3 e registro destinazione $t0 è:
D. L'istruzione sll $s3, $t0, 4

678. L'istruzione shift $t0 , $s3, 4
A. L'istruzione sll $t0, $s3, 4
B. L'istruzione shift $s3, $t0, 4
C. Q686. Gli indirizzi della Memoria principale MIPS sono dati da:
D. Sequenze di 32 bit

679. Sequenze di 5 bit
A. Sequenze di 8 bit
B. Sequenze di 64 bit
C. Q687. Nel Linguaggio Assembly MIPS il salto ad una istruzione con etichetta NEW se il valore dei registri con indirizzi
D. $s0, $s1 sono DIVERSI è eseguito dalla:

680. Istruzione jump $s0, $s1, NEW
A. Istruzione bne $s0, $s1, NEW
B. Istruzione beq $s0, $s1, NEW
C. Istruzione jr $s1, $s0, NEW
D. Q688. Per le istruzioni di trasferimento dati Load word e Store word la lettura anticipata dei Registri del processore è una ottimizzazione del tempo di esecuzione perché:

681. Fornisce sul terminale output Dato letto 1 l'indirizzo di accesso in Memoria
A. Fornisce sul terminale output Dato letto 2 il contenuto del Registro Base di indirizzo Istruzione[15-0] come operando dell'ALU per il calcolo dell'indirizzo di accesso in Memoria
B. Fornisce sul terminale output Dato letto 1 il contenuto del Registro da cui leggere o in cui scrivere il dato che viene trasferito
C. Fornisce sul terminale output Dato letto 1 il contenuto del Registro Base di indirizzo Istruzione[25-21] come operando dell'ALU per il calcolo dell'indirizzo di accesso in Memoria
D. Q688. I valori unsigned rappresentati da sequenze di 32 bit sono compresi:

682. Nell'intervallo [-128, 127 ]
A. Nell'intervallo [-231, 231-1 ]
B. Nell'intervallo [0, 232-1 ]
C. Nell'intervallo [0, 127 ]
D. Q689. I caratteri rappresentati nella codifica ASCII sono:

683. In totale 64 caratteri stampabili
A. In totale 52 costituiti da 26 simboli dell'alfabeto inglese minuscolo e maiuscolo
B. In totale 32 costituiti dai 26 caratteri dell'alfabeto inglese minuscolo e 6 simboli di punteggiatura
C. In totale 128 costituiti da 95 caratteri stampabili e 33 simboli non stampabili
D. Q690. Lo stato SET del LATCH SR che rappresenta il simbolo 1 corrisponde alla configurazione in cui:

684. Gli output sono entrambi uguali a 1
A. Gli output sono diversi e l'output Q=0
B. Gli output sono diversi e l'output Q=1
C. Gli output sono entrambi uguali a 0
D. Q690. Il sistema di codifica Unicode UTF-16 utilizza sequenze binarie:

685. Di lunghezza 32
A. Di lunghezza 8
B. Di lunghezza 16
C. Di lunghezza 7
D. Q692. Il Codice di Hamming consente di:

686. Riconoscere il verificarsi di un errore sui bit diversi dal bit di parità
A. Correggere ogni errore su un singolo bit
B. Riconoscere ma non correggere il verificarsi di un numero pari di errori
C. Riconoscere ma non correggere il verificarsi di un numero dispari di errori
D. Q696. Il codice oggetto di un programma che utilizza una libreria deve:

687. Essere passato al programma Loader per la traduzione in Linguaggio Macchina
A. Essere passato all'Assembler per la traduzione in Linguaggio Macchina
B. Essere passato al Compilatore per la traduzione in Assembly
C. Essere passato al programma Linker che effettua i collegamenti tra il codice oggetto del programma e il codice oggetto delle procedure che utilizza
D. Q697. Un sistema dinamico ha la caratteristica detta feedback (retroazione) quando:

688. Il comportamento del sistema descritto dallo stato in un istante di tempo non influenza il comportamento nell'istante di tempo successivo
A. Il comportamento del sistema descritto dallo stato in un istante di tempo rimane invariato nell'istante di tempo successivo
B. Il comportamento del sistema descritto dallo stato in un istante di tempo è uguale all'output del sistema nell'istante di tempo successivo
C. Il comportamento del sistema descritto dallo stato in un istante di tempo influenza il comportamento nell'istante di tempo successivo
D. Q698. Un Maxtermine è:

689. Una funzione la cui tavola di verità contiene un solo valore 0, data dall'OR di tutte le variabili in forma normale o complementata
A. Una funzione che assume tutti i valori del Dominio dell'Algebra di Boole
B. Una funzione la cui tavola di verità contiene un solo valore 1, data dall'AND di tutte le variabili in forma normale o complementata
C. La negazione di un OR di variabili Booleane
D. Q702. Nella Notazione in complemento a 2, la sequenza binaria 1111 rappresenta:

690. Il valore +15
A. Il valore -1
B. Il valore -7
C. Il valore +7
D. Q706. Nel Linguaggio Assembly MIPS l'istruzione j NOME esegue:

691. Il salto all'istruzione del programma preceduta dall'etichetta NOME se il contenuto di due registri è uguale
A. Il ritorno al programma principale dopo l'esecuzione della procedura NOME
B. Il salto alla esecuzione della procedura NOME
C. Il salto incondizionato all'istruzione del programma preceduta dall'etichetta NOME
D. Q707. Nel circuito di Lettura il contenuto dei Registri del processore MIPS è collegato:

692. Ai terminali output del multiplexer relativi ai dati da selezionare utilizzando i valori sui terminali input di controllo del multiplexer costituiti dall'indirizzo del Registro
A. Ai terminali output del decodificatore che vengono selezionati utilizzando i valori sui terminali input di controllo del decodificatore costituiti dall'indirizzo del Registro
B. Ai terminali input del multiplexer relativi ai dati da selezionare utilizzando i valori sui terminali input di controllo del multiplexer costituiti dall'indirizzo del Registro
C. Ai terminali input del decodificatore che vengono selezionati utilizzando i valori sui terminali input di controllo del  decodificatore costituiti dall'indirizzo del Registro
D. Q707. L'istruzione Assembly MIPS di salto incondizionato ha:

693. La forma sintattica j ETICHETTA
A. La forma sintattica jump ETICHETTA
B. La forma sintattica branch ETICHETTA
C. La forma sintattica b ETICHETTA
D. Q708. Ai fini della valutazione delle prestazioni Hardware, il tempo di CPU viene definito come:

694. Il tempo di CPU utente speso per l'esecuzione delle istruzioni del programma utente
A. Il tempo di CPU utente speso per l'esecuzione delle istruzioni del programma utente più il tempo di CPU di sistema speso per l esecuzione delle funzioni del Sistema Operativo necessarie per eseguire il programma utente
B. Il tempo di CPU di sistema speso per l' esecuzione delle funzioni del Sistema Operativo necessarie per eseguire il programma utente
C. Il tempo speso negli accessi alla Memoria principale per il prelievo delle istruzioni
D. Q708. Le chiamate di procedura annidate sono gestite:

695. Dal Compilatore
A. Utilizzando una struttura dati di Tipo Array, ponendo le informazioni relative ad ogni procedura negli elementi dell'Array
B. Utilizzando i registri del processore
C. Utilizzando una struttura dati di Tipo stack, scrivendo le informazioni relative ad ogni procedura in un segmento, detto frame, delle locazioni di Memoria assegnate allo stack
D. Q709. L'esecuzione dell'istruzione Assembly MIPS sltu $t0, $s1, $s2:

696. Pone nel registro $t0 il valore 1 se, in Notazione posizionale pesata senza segno, il valore contenuto nel registro $s1 è minore del valore contenuto nel registro $s2 , altrimenti pone 0
A. Salta all'indirizzo contenuto nel registro $t0 se il valore unsigned contenuto nel registro $s1 è minore del valore unsigned contenuto nel registro $s2, altrimenti continua in sequenza
B. Pone nel registro $t0 il più piccolo dei valori unsigned contenuti nei registri $s1 e $s2
C. Pone nel registro $t0 il più grande dei valori unsigned contenuti nei registri $s1 e $s2
D. Q710. Si verifica una criticità strutturale quando:

697. Le risorse Hardware presenti non sono in grado di supportare le operazioni richieste da diverse fasi della pipeline in esecuzione
A. Una fase deve aspettare i risultati delle operazioni eseguite in un altra fase della pipeline.
B. Il prelievo di una istruzione nella fase di Fetch dipende dall esito del test di una istruzione di salto condizionato in esecuzione nella pipeline
C. La pipeline non riceve i dati necessari a causa di un Page Fault
D. Q710. La traduzione in Assembly MIPS dell'assegnamento A[3] = val con $s3 registro Base dell'Array di INTERI A[] e assegnado il registro $t0 alla variabile val è data:

698. Dell'istruzione sw $s3, 24 ($t0)
A. Dell'istruzione lw $t0, 24 ($s3)
B. Dell'istruzione sw $t0, 12 ($s3)
C. Dell'istruzione sw $t0, 3 ($s3)
D. Q713. La proprietà dell'insieme di opertatori AND, OR, NOT di essere funzionalmente completo significa che:

699. Ogni Espressione Booleana che contiene questi operatori può essere valuta
A. Tutti questi operatori possono essere valutati mediante Tavole di verità
B. Le tavole di verità di questi operatori contengono almeno un valore diverso da 0
C. Data una qualunque funzione Booleana si può determinare una Espressione Booleana in cui figurano solo gli operatori AND, OR, NOT, e la cui valutazione è uguale alla funzione data
D. Q719. La Frequenza di un segnale periodico è data da:

700. Il numero di ripetizioni del periodo che si verificano nell'unità di tempo
A. La durata del periodo del segnale
B. L'ampiezza dell'intervallo di tempo in cui il segnale ha valore alto
C. Il rapporto tra le ampiezze degli intervalli in cui il segnale è alto e basso
D. Q721. La lettura anticipata di due Registri del processore, fatta dopo la fase di Prelievo mentre l'Unità di Controllo calcola il valore dei segnali di controllo, è effettuata allo scopo di:

701. Ridurre il tempo di esecuzione delle istruzioni che richiedono la lettura degli operandi nei Registri
A. Calcolare l'indirizzo da scrivere nel Program Counter
B. Leggere il codice operativo dell'istruzione
C. Calcolare l'indirizzo della prossima istruzione da eseguire
D. Q723. L'operando costante dell'istruzione slti $s0, $t1, -70 si ottiene:

702. Effettuando l'estensione del segno a 32 bit della sequenza di 16 bit nel campo immediato che rappresenta il valore costante
A. Completando a 32 bit la sequenza di 16 bit nel campo immediato, che rappresenta il valore costante, aggiungendo sempre bit tutti uguali a 0
B. Leggendo il valore contenuto nel registro $t1
C. Leggendo il valore contenuto nel registro $s0
D. Q724. L'attivazione della Lettura per proteggere i 32 Registri del processore MIPS:

703. Viene implementata mediante il segnale di controllo MemtoReg
A. Viene implementata mediante il segnale di controllo RegRead
B. Non è implementata non essendo necessaria la protezione in lettura poiché non è distruttiva
C. Viene implementata mediante il segnale di controllo MemRead
D. Q724. Le componenti Hardware del computer comunicano tra loro utilizzando:

704. La Memoria
A. Canali di comunicazione detti bus
B. Il Clock in fissati intervalli di tempo
C. Il Compilatore
D. Q725. La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione n=0; con l'associazione n--&gt; $s3 è:

705. addi $s3, $zero, $zero
A. addi $zero, $s3, 0
B. add $zero, $s3, 0
C. addi $s3, $zero, 0
D. Q726. Nella notazione in modulo e segno, il segno del risultato dell'addizione è:

706. Sempre positivo
A. Quello del primo numero
B. Quello del numero con modulo maggiore
C. Quello del numero con modulo minore
D. Q727. L'esecuzione di una istruzione del Linguaggio Macchina MIPS nell'applicazione del pipeling è suddivisa in:

707. 6 fasi denominate: Fetch, lettura dei registri, decodifica del codice operativo,	calcolo effettuato dall'ALU, lettura/scrittura di un dato in Memoria, scrittura nel blocco dei Registri
A. 4 fasi denominate: Fetch e decodifica, lettura dei registri e calcolo effettuato dall'ALU, lettura/scrittura di un dato in Memoria, scrittura nel blocco dei Registri
B. 5 fasi denominate: Fetch, lettura dei registri e decodifica, calcolo effettuato dall'ALU, lettura/scrittura di un dato in Memoria, scrittura nel blocco dei Registri
C. 5 fasi denominate: Fetch e decodifica, lettura dei registri, calcolo effettuato dall'ALU, lettura/scrittura di un dato in Memoria, scrittura nel blocco dei Registri
D. Q727. La Modalità di Indirizzamento di lh fornisce:

708. L'idirizzo della prima delle due locazini di Memoria in cui scrivere il dato rappresentato da 16 bit
A. L'idirizzo della locazine di Memoria da cui leggere il dato rappresentato da 8 bit
B. L'idirizzo della prima delle due locazini di Memoria da cui leggere il dato rappresentato da 16 bit
C. L'idirizzo della locazine di Memoria in cui scrivere il dato rappresentato da 8 bit
D. Q727. Nella Modalità di Indirizzamento relativo al Program Counter il contenuto del campo immediato è moltiplicato per 4 perchè:

709. Rappresenta il numero di istruzioni da saltare e ogni istruzione occupa 4 Byte di Memoria
A. Rappresenta il contenuto di un registro e ogni registro è costituito da 4 Byte
B. L'estensione del segno estende il campo immediato a 32 bit che corrispondono a 4 Byte
C. Il Program Counter è costitutito da 32 bit che corrispondono a 4 Byte
D. Q728. Se il minimo modulo rappresentabile è 0.01 ed il massimo è 999 l'errore di underflow si verifica quando il valore da rappresentare è:

710. Esterno all'intervallo [-999 , 999]
A. Esterno all'intervallo [-0.01 , 0.01]
B. Compreso nell'intervallo (-999 , 999)
C. Compreso nell'intervallo (-0.01 , 0.01)
D. Q728. Il campo di 26 bit del Formato di Tipo J del Linguaggio Macchina MIPS contiene:

711. L'indirizzo di salto incondizionato dell'istruzione Assembly j
A. Una parte dell'indirizzo di salto incondizionato dell'istruzione Assembly j
B. Un operando immediato da aggiungere al contenuto di un registro dell'istruzione Assembly addi
C. L'indirizzo di Memoria da cui prelevare un operando dell'istruzione Assembly lw
D. Q729. Il numero in Base 10 rappresentato in virgola fissa dalla sequenza 53498,03 è rappresentato in Notazione scientifica in virgola mobile:

712. Dalla sequenza 5349803E-2
A. Dalla sequenza 5,349803E+4
B. Dalla sequenza 0,5349803E+5
C. Dalla sequenza 0,05349803E+6
D. Q729. I campi del Formato J dell'istruzione del Linguaggio Macchina MIPS che traduce l'istruzione Assembly j NOME contengono:

713. Sottosequenze binarie di lunghezze 6, 5, 5, 16
A. Sottosequenze binarie di lunghezze 6, 16, 5, 5
B. Sottosequenze binarie di lunghezze 6, 5, 5, 5, 5, 6
C. Sottosequenze binarie di lunghezze 6, 26
D. Q731. Una Rete Combinatoria è:

714. Un circuito digitale costituito dalla connessione di porte logiche senza determinare la presenza di cicli
A. Un circuito digitale costituito dalla connessione di porte logiche in cui è presente almeno un ciclo
B. Un collegamento tra computer tramite server
C. Un dispositivo capace di memorizzare sequenze binarie
D. Q732. Nel Linguaggio Macchina per passare alla esecuzione di una procedura è necessario:

715. Scrivere il nome della procedura in Memoria seguito dall'elenco dei relativi parametri con una istruzione load word
A. Scrivere in una istruzione il nome della procedura seguito dall'elenco dei relativi parametri
B. Scrivere il nome della procedura in un registro del processore seguito dall'elenco dei relativi parametri con una istruzione store word
C. Porre l'indirizzo della prima istruzione della procedura nel Program Counter, e salvare l'indirizzo di ritorno all'esecuzione del programma chiamante con una istruzione di salto
D. Q733. Per le istruzione Logiche and, or il Linguaggio Assembly:

716. Ha le corrispondenti istruzioni per operandi unsigned andu, oru
A. Ha la corrispondente istruzione andu per operandi unsigned solo per l'operatore AND
B. Non ha le corrispondenti istruzioni per operandi unsigned perché le operazioni sono eseguite bit a bit
C. Ha la corrispondente istruzione oru per operandi unsigned solo per l'operatore OR
D. Q734. Il codice ASCII utilizza sequenze binarie:

717. Di lunghezza 16
A. Di lunghezza 32
B. Di lunghezza 7
C. Di lunghezza 8
D. Q735. I codici ASCII sono compresi tra:

718. Il minimo -64 e il massimo 63
A. Il minimo 0 e il massimo 63
B. Il minimo -128 e il massimo 127
C. Il minimo 0 e il massimo 127
D. Q737. L'operazione effettuata dall'esecuzione dell'istruzione lhu $t0, 30($s1) è:

719. Leggere la sequenza di 16 bit contenuti in due locazioni successive di Memoria e scriverla nei 16 bit meno significativi del registro $t0 di 32 bit, ponendo a 0 il valore dei rimanenti bit
A. Scrivere la sequenza di 16 bit in due locazioni successive di Memoria dopo averla letta nei 16 bit meno significativi del registro $t0
B. Leggere la sequenza di 8 bit contenuti in una locazione di Memoria e scriverla negli 8 bit meno significativi del registro $t0 di 32 bit, con estensione del segno a 32 bit
C. Scrivere la sequenza di 8 bit in una locazione di Memoria dopo averla letta negli 8 bit meno significativi del registro
D. $t0

720. Q738. La Rete Combinatoria dell'ALU a 32 bit è implementata:
A. Mediante una Rete Sequenziale
B. Collegando 32 ALU ad un bit relative alle specifiche posizioni con propagazione dei riporti calcolati
C. Collegando l'ALU a 32 bit che effettua le operazioni logiche con l'ALU a 32 bit che effettua le operazioni aritmetiche.
D. Costruendo una rete AND to OR per ciascuna operazione implementata

721. Q738. Il Sistema Operativo è un programma che:
A. Traduce un programma scritto in un Linguaggio ad Alto Livello in un programma in Linguaggio Macchina
B. Esegue le operazioni aritmetiche e logiche
C. Gestisce le risorse Hardware del computer assegnandole ai programmi da eseguire e l'interazione con l'utente
D. Valuta le prestazioni dell'Unità Aritmetico-Logica

722. Q740. La fase di Prelievo con cui inizia l'esecuzione di ogni istruzione consiste nella:
A. Lettura in Memoria degli operandi dell'istruzione
B. Lettura nel blocco dei Registri del processore dei 6 bit del Codice Operativo contenuto nella sequenza binaria che
C. rappresenta l'istruzione in Linguaggio Macchina
D. Lettura in Memoria della sequenza binaria che rappresenta l'istruzione in Linguaggio Macchina

723. Lettura nel blocco dei Registri del processore degli operandi dell'istruzione
A. Q743. L'operando immediato dell'istruzione Assembly MIPS addi $t0, $s1, 30 è rappresentato in Linguaggio Macchina mediante:
B. Una sequenza di 16 bit in Notazione posizionale pesata
C. Una sequenza di 16 bit in Notazione modulo e segno
D. Una sequenza di 16 bit in Notazione in complemento a 2

724. Una sequenza di 16 bit in Notazione posizionale pesata senza segno
A. Q747. L'esecuzione dell'istruzione Assembly MIPS slt $t0, $s1, $s2:
B. Pone nel registro $t0 il più piccolo dei valori contenuti nei registri $s1 e $s2
C. Salta all'indirizzo contenuto nel registro $t0 se il valore contenuto nel registro $s1 è minore del valore contenuto nel registro $s2, altrimenti continua in sequenza
D. Pone nel registro $t0 il valore 1 se, in Notazione in complemento a 2, il valore contenuto nel registro $s1 è minore del valore contenuto nel registro $s2 , altrimenti pone 0

725. Pone nel registro $t0 il più grande dei valori contenuti nei registri $s1 e $s2
A. Q750. Nella Macchina di Turing gli stati, le trasizioni di stato, i simboli dell'alfabeto, i caratteri della sequenza scritta sul nastro sono:
B. Insiemi infiniti nel caso di algoritmi risolutivi di problemi complessi
C. Insiemi sia finiti che infiniti
D. Insiemi comunque grandi, ma sempre finiti

726. Sempre insiemi infiniti
A. Q751. Nel Linguaggio Macchina MIPS, con l'Indirizzamento tramite registro gli indirizzi degli operandi sono contenuti:
B. Nei campi rt e shamt del Formato di Tipo R
C. Nei campi rd e funct del Formato di Tipo R
D. Nei campi rs e rt del Formato di Tipo I

727. Nei campi rs e rt del Formato di Tipo R
A. Q754. L'errore "Array out of bounds" avviene quando:
B. Si accede all'ultimo elemento dell'Array
C. Si dichiara una dimensione di Array maggiore dello spazio di Memoria disponibile
D. Si utilizza un valore dell'indice dell'Array che determina un accesso a locazioni di Memoria fuori dallo spazio destinato a contenere gli elementi dell Array

728. Il valore di un elemento in un Array di interi non è rappresentabilie con 32 bit
A. Q756. La conversione di una sequenza binaria nella corrispondente rappresentazione esadecimale si può effettuare direttamente:
B. Suddividendo la sequenza binaria in gruppi di 3 simboli a partire da destra (cifre meno significative), e sostituendo ad ogni gruppo il corrispondente simbolo della base 8
C. Suddividendo la sequenza binaria in gruppi di 4 simboli a partire da destra (cifre meno significative), e sostituendo ad ogni gruppo il corrispondente simbolo della base 16
D. Calcolando il valore della sequenza binaria utilizzando come pesi potenze della base 16

729. Calcolando il valore in base 10 e determinando la sequenza corrispondente in base 16
A. Q763. Per accedere al contenuto di un particolare registro è necessario conoscere:
B. La lunghezza di tale registro
C. Il tipo di dato scritto in tale registro
D. l'indirizzo scritto in tale registro

730. L'indirizzo di tale registro
A. Q765. La Java Virtual Machine è:
B. Il programma che carica il bytecode Java in Memoria
C. L'Hardware che esegue il bytecode Java
D. La macchina astratta capace di eseguire il bytecode Java

731. L'Hardware che traduce il Bytecode Java in Linguaggio macchina
A. Q767. Nel Linguaggio Macchina MIPS, la Modalità di Indirizzamento immediato fornisce due operandi mediante due campi del Formato di Tipo I che contengono:
B. Gli indirizzi dei registri che contengono i due operandi
C. Due numeri interi in Notazione in complemento a 2 che costituiscono i due operandi
D. I valori Codice Operativo e funzione

732. Un numero intero in Notazione in complemento a 2 che costituisce un operando e l'indirizzo di un registro che contiene l'altro operando
A. Q768. Nella Modalità di Indirizzamento relativo al Program Counter il contenuto del campo immediato è esteso di segno a 32 bit perchè:
B. Il contenuto del campo immediato viene copiato in 4 Byte di Memoria che corrispondono a 32 bit
C. Il contenuto del campo immediato viene copiato in un registro e i registri del processore MIPS contengono 32 bit
D. Il contenuto del campo immediato moltiplicato per 4 è addizionato al valore del Program Counter dall'ALU che richiede operandi a 32 bit

733. Il contenuto del campo immediato viene confrontato con il contenuto del Program Counter che contiene 32 bit
A. Q771. La relazione che lega la Frequenza con la Durata di un segnale periodico è:
B. Frequenza / Durata = 1
C. Frequenza + Durata = 1
D. Frequenza = 1 / Durata

734. Frequenza = - Durata
A. Q772. I 32 bit contenuti nel Program Counter forniscono:
B. Il numero di istruzioni del programma già eseguite
C. L'indirizzo del Registro del processore che contiene l'istruzione da eseguire rappresentata in Linguaggio Macchina
D. La sequenza che rappresenta l'istruzione in Linguaggio Macchina da eseguire

735. L'indirizzo del primo dei 4 Byte della parola di Memoria che contiene l'istruzione da eseguire rappresentata in Linguaggio Macchina
A. Q773. Lo stato RESET del LATCH SR che rappresenta il simbolo 0 corrisponde alla configurazione in cui:
B. Gli output sono diversi e l'output Q=1
C. Gli output sono entrambi uguali a 1
D. Gli output sono entrambi uguali a 0

736. Gli output sono diversi e l'output Q=0
A. Q774. Per l'istruzione di salto condizionato su uguaglianza BEQ la lettura anticipata dei Registri del processore è una ottimizzazione del tempo di esecuzione perché:
B. Fornisce sui terminali output Dato letto 1 e Dato letto 2 il contenuto dei Registri di indirizzo Istruzione[31-26] e Istruzione[15-11] come operandi dell'ALU per il calcolo dell'indirizzo di salto
C. Fornisce sui terminali output Dato letto 1 e Dato letto 2 il contenuto dei Registri di indirizzo Istruzione[25-21] e Istruzione[20-16] come operandi dell'ALU per il calcolo dell'indirizzo di salto
D. Fornisce sui terminali output Dato letto 1 e Dato letto 2 il contenuto dei Registri di indirizzo Istruzione[25-21] e Istruzione[20-16] come operandi dell'ALU da confrontare per stabilire la condizione di salto

737. Fornisce sui terminali output Dato letto 1 e Dato letto 2 il contenuto dei Registri di indirizzo Istruzione[31-26] e Istruzione[15-0] come operandi dell'ALU da confrontare per stabilire la condizione di salto
A. Q774. Nello standard IEEE 754 il valore MASSIMO dell'esponente polarizzato con mantissa diversa da 0 è riservato a rappresentare:
B. Il valore NaN (not a number) che segnala la situazione anomale di un calcolo non ammissibile come la divisione per zero
C. L'uso della notazione in complemento a 2
D. Il massimo modulo rappresentabile

738. Il valore 0
A. Q775. Nel Flip-Flop D l'input D=1 determina:
B. Nessuna transizione perché è una configurazione input esclusa
C. La transizione dei valori output nello stato RESET
D. Il mantenimento invariato dello stato rappresentato dai valori output

739. La transizione dei valori output nello stato SET
A. Q775. In un registro del Processore MIPS si può memorizzare:
B. Una sequenza di più di 32 cifre binarie
C. Una sequenzadi 32 simboli dell'alfabero inglese
D. Una sequenza di cifre binarie di lunghezza variabile

740. Una sequenza di 32 cifre binarie
A. Q777. Il Codice a controllo di parità consente di:
B. Correggere ogni errore su un singolo bit
C. Riconoscere il verificarsi di un errore sui bit diversi dal bit di parità
D. Riconoscere ma non correggere il verificarsi di un numero dispari di errori

741. Riconoscere ma non correggere il verificarsi di un numero pari di errori
A. Q778. Una General Purpose GPU è:
B. Una Unità di elaborazione grafica ad alto parallelismo che offre la possibiltà di programmare un ampio spettro di applicazioni utilizzando un linguaggio di programmazione tipicamente basato sul Linguaggio C
C. Una Architettura in cui è presente più di una Central Processing Unit (CPU)
D. Una Atrchitettura che suddivide l'esecuzione di ogni istruzione in fasi svolgendo le operazioni di ogni fase in un ciclo di clock.

742. Una Architettura che implementa le istruzioni con un numero variabili di cicli di clock
A. Q778. Un mintermine è:
B. Una funzione la cui tavola di verità contiene un solo valore 1, data dall'AND di tutte le variabili in forma normale o complementata
C. Una funzione di una sola variabile binaria
D. Una funzione la cui tavola di verità contiene un solo valore 0, data dall'OR di tutte le variabili in forma normale o complementata

743. La negazione di un AND di variabili Booleane
A. Q779. Il registro Base di un Array contiene:
B. L'indirizzo del primo Byte della parola di Memoria in cui è memorizzato l'elemento A[0]
C. Il valore dell'elemento A[0]
D. L'indirizzo di Memoria in cui è memorizzato l'elemento A[1]

744. Il valore dell'elemento A[1]
A. Q780. L'istruzione IF_ELSE del Linduaggio ad Alto Livello, nel Linguaggio Assembly:
B. Viene tradotta come una chiamata di procedura che permette l esecuzione condizionale di due istruzioni in alternativa, a seconda del valore di verità di una espressione logica
C. Viene tradotta da una analoga istruzione if-else che permette l esecuzione condizionale di due istruzioni in alternativa, a seconda del valore di verità di una espressione logica
D. Non ha una corrispondente istruzione e viene tradotta combinando istruzioni di salto condizionato ed incondizionato

745. Non ha una corrispondente istruzione e viene sempre tradotta combinando istruzioni di accesso alla Memoria principale
A. Q784. La dichiarazione di tipo intero per una variabile in un Linguaggio ad Alto Livello indica al Compilatore che:
B. Per la variabile si deve utilizzare la Notazione posizionale pesata
C. Per la variabile si deve utilizzare la Notazione con segno separato dal modulo
D. Per la variabile si deve utilizzare la Notazione in complemento a 2

746. La variabile ha segno positivo
A. Q785. L'operatore XOR assume valore "vero" solo quando:
B. Almeno uno dei valori delle variabili è "vero"
C. Uno solo dei valori delle variabili è "vero"
D. Entrambe le variabili assumono il valore "vero"

747. Entrambe le variabili assumono il valore "falso"
A. Q786. Una Architettura RISC è caratterizzata da:
B. Istruzioni in Linguaggio Macchina più semplici ed un Hardware meno complesso
C. Istruzioni in Linguaggio Macchina che si possono eseguire su un qualunque computer
D. Istruzioni in Linguaggio Macchina più numerose ed un Hardware più complesso

748. Istruzioni in Linguaggio Macchina più lente ed un Hardware più complesso
A. Q787. Nella realizzazione della CPU in base all'approccio multiciclo l'Unità di Controllo è implementata mediante:
B. Una Rete Sequenziale che, per l'esecuzione di una istruzione, consente di tenere memoria mediante transizioni di stato della successione delle operazioni che avvengono in cicli di clock separati
C. Una Rete Combinatoria realizzata sulla base della successione dei valori dei segnali di controllo per l'esecuzione delle operazioni dell'istruzione nei relativi cicli di clock
D. La memorizzazione nei Registri del processore della successione dei valori dei segnali di controllo per l'esecuzione delle operazioni dell'istruzione nei relativi cicli di clock

749. Un decodificatore che fornisce i valori dei segnali di controllo per l'esecuzione dell'istruzione nei relativi cicli di clock
A. Q789. Per migliorare le prestazioni di un computer la frequenza di clock può essere:
B. Mantenuta costante diminuendo il periodo di clock
C. Diminuita, ma senza superare il limite fisico costituito dalla possibilità di disperdere il calore generato
D. Aumentata, ma senza superare il limite fisico costituito dalla possibilità di disperdere il calore generato

750. Mantenuta costante aumentando il periodo di clock
A. Q791. Il parallelismo della tecnica di pipelining per il miglioramento delle prestazioni di un computer consiste:
B. Nell'uso di una unità di elaborazione grafica ad alto parallelismo che offre la possibiltà di programmare un ampio spettro di applicazioni utilizzando un linguaggio di programmazione tipicamente basato sul Linguaggio C
C. Nella possibilità di eseguire in parallelo le istruzioni su un computer in cui è presente più di una CPU
D. Nella esecuzione in parallelo di più istruzioni come in una catena di montaggio, suddividendo l'esecuzione di ogni istruzione in fasi e svolgendo le operazioni di ogni fase in un ciclo di clock.

751. Nell'effettuare gli accessi ai dati ed alle istruzioni attraverso una gerarchia di livelli di memoria copiando i blocchi da un livello a quello immediantamente superiore
A. Q791. Nel Linguaggio Macchina MIPS, i campi del Formato di Tipo R sono:
B. Sottosequenze della sequenza binaria che rappresenta l'istruzione di lunghezze 8, 6, 6, 6, 6, 6
C. Sottosequenze della sequenza binaria che rappresenta l'istruzione di lunghezze 6, 5, 5, 16
D. Sottosequenze della sequenza binaria che rappresenta l'istruzione di lunghezze 5, 5, 5, 5, 6, 6

752. Sottosequenze della sequenza binaria che rappresenta l'istruzione di lunghezze 6, 5, 5, 5, 5, 6
A. Q793. La traduzione in Assembly MIPS dell'assegnamento A[8] = val con $t4 registro Base dell'Array di caratteri Unicode a 16 bit A[] e assegnado il registro $s2 alla variabile val è data:
B. Dall'istruzione lbu $s2, 8 ($t4)
C. Dall'istruzione sh $s2, 16 ($t4)
D. Dall'istruzione sw $t4, 32 ($s2)

753. Dall'istruzione lhu $s2, 16 ($t4)
A. Q793. Una istruzione Assembly corrisponde sempre a:
B. Più istruzioni in Linguaggio Macchina
C. Una sola istruzione in Linguaggio Macchina
D. Una sola istruzione in Linguaggio ad Alto Livello

754. Più istruzioni in Linguaggio ad Alto Livello
A. Q795. Nella traduzione in Linguaggio Macchina MIPS gli indirizzi dei registri che figurano nell'istruzione Assembly beq $s2, $s3, ETICHETTA sono posti:
B. Nei primi due campi di 5 bit del Formato di Tipo R nello stesso ordine che presentano nell'istruzione Assembly
C. Nei primi due campi di 5 bit del Formato di Tipo R invertendo l'ordine che presentano nell'istruzione Assembly
D. Nei campi di 5 bit del Formato di Tipo I nello stesso ordine che presentano nell'istruzione Assembly

755. Nei campi di 5 bit del Formato di Tipo I invertendo l'ordine che presentano nell'istruzione Assembly
A. Q796. I campi del Formato dell'istruzione in Linguaggio Macchina MIPS 00010010000010000000000000000111 che traduce l'istruzione Assembly beq $s0, $t0, ETICHETTA sono dati dalle:
B. Sottosequenze 000100, 1000001000000000, 00000, 00111 rispettivamente di lunghezza 6, 16, 5, 5
C. Sottosequenze 000100, 10000010000000000000000111 rispettivamente di lunghezza 6, 26
D. Sottosequenze 000100, 10000, 01000, 00000, 00000, 000111 rispettivamente di lunghezza 6, 5, 5, 5, 5, 6

756. Sottosequenze 000100, 10000, 01000, 0000000000000111 rispettivamente di lunghezza 6, 5, 5, 16
A. Q801. Nell'ambito della valutazione delle prestazioni Hardware con il termine benchmark si indica:
B. Il numero delle istruzioni del programma utilizzato per effettuare la valutazione delle prestazioni della CPU
C. Il limite massimo entro il quale la valutazione della prestazione fornisce un valore accettabile
D. L'intervallo dei valori in cui ricade la valutazione della prestazione

757. Un insieme di programmi campione appositamente scelto per impegnare un dispositivo nell'esecuzione di un numero adeguato di istruzioni significative ai fini della valutazione da effettuare
A. Q802. Una istruzione in Linguaggio Macchina del MIPS è rappresentata da:
B. Una sequenza di 32 simboli dell'alfabero inglese
C. Una sequenza di almeno 32 cifre binarie
D. Una sequenza di 32 cifre binarie

758. Una sequenza di cifre binarie di lunghezza variabile
A. Q803. Le proprietà degli operatori logici rappresentate da identità tra Espressioni Booleane consentono di:
B. Sostituire l'AND con l'OR e il valore 0 con 1, e viceversa
C. Modificare il valore di verità degli operatori logici
D. Determinare le Tavole di verità degli operatori logici

759. Trasformare una Espressione Booleana in un'altra equivalente
A. Q805. Il valore del segnale Zero utilizzato nell'esecuzione dell'istruzione BEQ è calcolato dall'ALU mediante:
B. La porta NOR che calcola l'OR negato dei bit del risultato della sottrazione dei due operandi dell'istruzione BEQ
C. La porta XOR che calcola l'OR esclusivo dei riporti CarryIn e CarryOut nell'ALU ad un bit relativa alla posizione più significativa
D. I segnali Ainvert e Bnegate entrambi posti uguali a 1

760. Il valore output CarryOut calcolato dal Sommatore dell'ALU a un bit relativa alla posizione più significativa
A. Q806. In Notazione posizionale pesata una sequenza binaria con cifra meno significativa uguale a 0 rappresenta:
B. Un numero pari
C. Un numero divisibile per 5
D. Un numero dispari

761. Un numero multiplo di 4
A. Q810. Utilizzando la frequenza di clock, il tempo di CPU utente relativo alla esecuzione di un programma può essere calcolato con la formula:
B. Numero di cicli di clock impiegati per l'esecuzione del programma più la frequenza di clock
C. Numero di cicli di clock impiegati per l'esecuzione del programma moltiplicato per la frequenza di clock
D. Numero di cicli di clock impiegati per l'esecuzione del programma diviso la frequenza di clock

762. Numero di cicli di clock impiegati per l'esecuzione del programma meno la frequenza di clock
A. Q810. La forma canonica Prodotto di Somme e data da:
B. Un OR di AND
C. Un AND di OR tale che ogni OR contiene tutte le variabile in forma normale o complementata
D. Un AND di OR

763. Un OR di AND tale che ogni AND contiene tutte le variabile in forma normale o complementata
A. Q812. Il numero di livelli attraversati da un segnale in una Rete Combinatoria è dato da:
B. Il numero di porte che il segnale attraversa in un ciclo della Rete Combinatoria
C. Il numero dei terminali input della Rete Combinatoria a cui il segnale può essere applicato
D. Il numero di porte che il segnale attraversa a partire da un terminale input fino a raggiungere un terminale output della Rete Combinatoria

764. Il numero dei terminali output della Rete Combinatoria che forniscono segnali distinti
A. Q816. Le cifre significative della rappresentazione di un numero sono:
B. Le cifre che occupano le posizioni più a sinistra e più a destra
C. Le cifre a destra della virgola
D. Le cifre a sinistra della virgola

765. Le cifre che contribuiscono alla determinazione del valore del numero
A. Q816. Il sistema di codifica Unicode UTF-8 utilizza:
B. Sequenze composte da un numero variabile di Byte per codificare i caratteri
C. Solo sequenze di un Byte per rappresentare i caratteri
D. Sempre sequenze di 32 bit per rappresentare i caratteri

766. Codici sia negativi che positivi per rapresentare i caratteri
A. Q817. Un algoritmo è:
B. Una lista anche infinita di azioni comprensibili ed eseguibili da una macchina
C. Una lista finita di azioni comprensibili ed eseguibili da una macchina
D. Un insieme di azioni comprensibili ed eseguibili da una macchina

767. Una lista di azioni senza particolari vincoli
A. Q818. Il calcolo dell'indirizzo dell'elemento A[k] di un Array che implementa una stringa di CARATTERI ASCII si effettua:
B. Addizionando il valore dell'indice k al contenuto del registro Base dell'Array
C. Moltiplicando l'indice k per 2 e addizionando il valore ottenuto al contenuto del registro Base dell'Array
D. Moltiplicando per 2 il contenuto del registro Base dell'Array

768. Moltiplicando l'indice k per 4 e addizionando il valore ottenuto al contenuto del registro Base dell'Array
A. Q818. La traduzione dal Linguaggio C in Assembly MIPS dell'istruzione val=i-k; con l'associazione val--&gt; $s1 i-- &gt; $s3 k--&gt; $s2 è:
B. sub $s1, $s2, $s3
C. sub $s2, $s3, $s1
D. sub $s3, $s2, $s1

769. sub $s1, $s3, $s2
A. Q820. La forma canonica Somma di Prodotti e data da:
B. Un AND di OR
C. Un OR di AND tale che ogni AND contiene tutte le variabile in forma normale o complementata
D. Un OR di AND

770. Un AND di OR tale che ogni OR contiene tutte le variabile in forma normale o complementata
A. Q821. Nel Linguaggio Macchina MIPS, i campi del Formato di Tipo I contengono:
B. Sequenze di lunghezza 6, 5, 5, 5, 5, 6
C. Sequenze di lunghezza 6, 5, 5, 16
D. Sequenze di lunghezza 6, 16, 5, 5

771. Sequenze di lunghezza 6, 26
A. Q822. La Sintesi di una Rete Combinatoria capace di calcolare una funzione Booleana si effettua:
B. Convertendo la sequenza binaria ottenuta sui terminali output in notazione decimale
C. In due passi, determinando l'Espressione canonica Somma di Prodotti della funzione Booleana e costruendo la Rete Combinatoria ad essa associata
D. Verificando che ad una sequenza di valori posta sui terminali input corrisponde sempre lo stesso valore sui terminali output

772. In due passi, associando alla Rete Combinatoria la equivalente Espressione Booleana e valutando la funzione Booleana realtiva a tale Espressione
A. Q825. Il circuito di una Rete Sequenziale è caratterizzato da:
B. Un numero finito di terminali input e output
C. Presenza di porte logiche AND, OR e NOT connesse tra loro
D. Assenza di cicli nei collegamenti tra le porte logiche che costituiscono la Rete

773. Presenza di cicli nei collegamenti tra le porte logiche, che determinano il verificarsi di feedback nel comportamento dinamico del circuito
A. Q829. Con il termine Memoria Virtuale si indica:
B. Una memoria in cui tutti i programmmi che vengono eseguiti in parallelo possono condividere i dati effettuando operazioni di lettura/scrittura
C. Il livello più basso di una gerarchia di memorie che corrisponde alla Memoria di massa
D. Una tecnica di gestione della memoria capace di simulare uno spazio di Memoria principale indirizzabile maggiore di quello fisicamente disponibile, utilizzando spazio della memoria di massa

774. La memoria riservata alle funzioni svolte dal Sistema Operativo
A. Q829. Quando si verifica l'errore di underflow:
B. Il valore del numero viene approssimato con il valore massimo rappresentabile
C. Il valore del numero viene approssimato con il numero 0
D. Il valore del numero viene approssimato con il numero -1

775. Il valore del numero viene approssimato con il numero +1
A. Q830. Il Loader effettua:
B. La traduzione del programma in Linguaggio Assembly
C. Il caricamento del programma eseguibile in Memoria, l'assegnazione dello spazio alle strutture dati utilizzate e le inizializzazioni necessarie ad avviarne l'esecuzione
D. La traduzione del programma in Linguaggio Macchina

776. I collegamenti tra il programma e le procedure
A. Q831. Nel Linguaggio Macchina MIPS, il campo funct è:
B. Un campo di 5 bit del Formato di Tipo R che indica l'indirizzo del registro che contiene il primo operando
C. Un campo di 6 bit del Formato di Tipo R che indica l'operazione Aritmetico-Logica da eseguire
D. Un campo di 6 bit del Formato di Tipo R che indica la modalità di indirizzamento dell'istruzione

777. Un campo di 5 bit del Formato di Tipo R che indica l'indirizzo del risultato della funzione eseguita dall'istruzione
A. Q832. Nell'istruzione in Linguaggio Macchina MIPS con campi del Formato dati da 000000, 01000, 01001, 11110, 00000, 100101 gli indirizzi degli operandi sono:
B. I valori binari 000000, 01000
C. I valori binari 01001, 11110
D. I valori binari 01000, 01001

778. I valori binari 10000, 100101
A. Q833. Prima della esecuzione di una istruzione con Formato di Tipo I il valore del campo immediato viene:
B. Inviato all'ALU aggiungendo 16 bit uguali a 0 a sinistra della sequenza contenuta nel campo
C. Inviato all'ALU aggiungendo 16 bit uguali a 0 a destra della sequenza contenuta nel campo
D. Inviato all'ALU aggiungendo 16 bit mediante estensione del segno alla sequenza contenuta nel campo

779. Copiato in un registro di 32 bit
A. Q838. L'Indirizzamento pseudodiretto richiede che:
B. L'aggiunta dell'Offset al registro Base non determini l'errore di overflow
C. Tutte le istruzioni del programma siano memorizzate in locazioni di Memoria i cui indirizzi hanno i 4 bit più significativi che non cambiano
D. Sia verificata la condizione di uguaglianza del contenuto di due registri

780. L'accesso in Memoria avvenga in scrittura
A. Q839. In Linguaggio Assembly la ripetizione di un insieme di istruzioni per un numero fissato di volte può essere ottenuta:
B. Mediante una specifica istruzione Assembly che corrisponde all'istruzione FOR
C. Solo scrivendo un numero di copie delle istruzioni da ripetere pari al fissato numero di ripetizioni
D. Mediante combinazioni delle istruzioni di salto condizionato e incondizionato

781. Mediante ripetute chiamate di procedura
A. Q840. Il Tipo di dato unsigned è rappresentato da:
B. Sequenze binarie nella Notazione in complemento a 2
C. Sequenze binarie nella Notazione posizionale pesata
D. Sequenze binarie nella Notazione in modulo e segno

782. Sequenze binarie nella Notazione in virgola mobile
A. Q841. Nell'istruzione addi dell'Assembly MIPS l'operando costante è contenuto:
B. Nel registro destinazione
C. Nel registro del primo operando
D. Nell'istruzione

783. Nel registro del secondo operando
A. Q846. Nello standard IEEE 754 precisione DOPPIA le 53 cifre binarie significative corrispondono:
B. A 11 cifre decimali significative
C. A 7 cifre decimali significative
D. A 23 cifre decimali significative

784. A 15 cifre decimali significative
A. Q847. I numeri dichiarati double con più di 15 cifre decimali significative sono rappresentati:
B. Con 64 bit nello standard IEEE 754 doppia precisione sempre in maniera esatta
C. Con 64 bit nello standard IEEE 754 doppia precisione con errore di arrotondamento
D. Con 32 bit nello standard IEEE 754 singola precisione con errore di arrotondamento

785. Con 64 bit in notazione in complemento a 2
A. Q848. Nel Linguaggio Macchina l'indirizzo di ritorno dalla chiamata di una procedura è:
B. L'indirizzo dell'ultima istruzione della procedura chiamata
C. L'indirizzo della istruzione del programma chiamante che precede l'istruzione jal di salto alla esecuzione della procedura
D. L'indirizzo della istruzione del programma chiamante successiva alla istruzione jal di salto alla esecuzione della procedura

786. L'indirizzo della prima istruzione della procedura chiamata
A. Q850. In circuito digitale è presente un ciclo quando:
B. Il circuito fornisce come output un valore costante nel tempo
C. Un segnale di uscita torna ad alimentare una porta che ha contribuito a generarlo
D. L'input del circuito è uguale all'output del circuito

787. Il segnale di uscita non dipende dall'input del circuito
A. Q852. La traduzione in Linguaggio Macchina dell'istruzione lbu utilizza:
B. Il Formato di Tipo I e l'Indirizzamento tramite relativo al Program Counter
C. Il Formato di Tipo R e l'Indirizzamento Immediato
D. Il Formato di Tipo I e l'Indirizzamento immediato

788. Il Formato di Tipo I e l'Indirizzamento tramite Base e Offset
A. Q853. L'istruzone Assembly MIPS sw $t1, 4($s5):
B. Legge la parola di Memoria che inizia dall'indirizzo dato dal contenuto del registro Base di indirizzo $s5 più l'Offset 4 e la scrive come contenuto del registro di indirizzo $t1
C. Scrive il contenuto del registro di indirizzo $s5 nella parola di Memoria che inizia dall'indirizzo dato dal contenuto del registro Base di indirizzo $t1 più l'Offset 4
D. Scrive il contenuto del registro di indirizzo $t1 nella parola di Memoria che inizia dall'indirizzo dato dal contenuto del registro Base di indirizzo $s5 più l'Offset 4

789. Legge la parola di Memoria che inizia dall'indirizzo dato dal contenuto del registro Base di indirizzo $t1 più l'Offset 4 e la scrive come contenuto del registro di indirizzo $s5
A. Q855. Il valore della costante presente nell'istruzione Assembly MIPS slti $s1, $t2, -50 viene scritto:
B. In Notazione in modulo e segno nei 16 bit del campo immediato del formato di Tipo I
C. In Notazione in complemento a 2 nei 16 bit del campo immediato del formato di Tipo I
D. In Notazione posizionale pesata nei 16 bit del campo immediato del formato di Tipo I

790. Nel registro destinazione del formato di Tipo I
A. Q856. Il valore dell'Offset nell'istruzione Assembly MIPS lw $t0, 5($s3) è rappresentato nel Formato corrispondente in Linguaggio Macchina mediante:
B. I 5 bit del campo rt del Formato di Tipo R
C. I 16 bit del campo immediato del Formato di Tipo I
D. I 6 bit del campo Funzione del Formato di Tipo R

791. I 5 bit del campo rs del Formato di Tipo I
A. Q858. Il campo immediato del Formato di Tipo I dell'istruzione in Linguaggio Macchina MIPS che traduce l'istruzione Assembly bne $t3, $t5, NOME contiene:
B. La sequenza binaria che rappresenta l'etichetta NOME
C. Il numero di istruzioni da saltare in Notazione binaria
D. Il valore da scrivere nel Program Counter

792. Il numero di istruzioni da saltare in Notazione in complemento a 2
A. Q862. Le istruzioni lbu, sb possono essere utilizzate:
B. Per il trasferimento di valori dichiarati int
C. Per il trasferimento di caratteri Unicode a 16 bit e di valori dichiarati short
D. Per il trasferimento di caratteri ASCII a 7 e 8 bit e di valori dichiarati byte

793. Per il trasferimento di valori dichiarati long
A. Q867. In base alla Legge di De Morgan l'operatore logico NOR è uguale:
B. All'Addizione degli operandi complementati
C. All'OR degli operandi complementati
D. All'OR esclusivo degli operandi

794. All'AND degli operandi complementati
A. Q867. Le istruzioni Assembly MIPS per operandi rappresentati in virgola mobile utilizzano:
B. Solo i registri $s
C. Gli stessi registri delle istruzioni con operandi interi
D. I registri riservati $a e $v

795. I 32 registri aggiuntivi indicati con le lettere $f
A. Q868. Nell'ambito della valutazione delle prestazioni, con il termine metrica si indica:
B. Una valutazione in termini numerici di un aspetto del comportamento del sistema
C. L'unità di misura della grandezza adottata per valutare le prestazioni
D. Un parametro della prestazione da valutare

796. L'intervallo dei possibili valori assunti da un parametro della prestazione da valutare
A. Q868. L'unità di misura della Frequenza di un segnale periodico, denominata Hertz e rappresentata dal simbolo Hz, è riferita a:
B. Il rapporto tra la durata del periodo del segnale e l'unità di tempo di un secondo
C. Il numero di ripetizioni del periodo che si verificano in un secondo
D. Il rapporto tra la durata del periodo del segnale e l'unità di tempo di un minuto

797. Il numero di ripetizioni del periodo che si verificano in un minuto
A. Q868. L'estensione del segno di una sequenza con bit più significativo uguale a 0 si effettua:
B. Cambiando in 1 il valore di tale bit
C. Ponendo a sinistra di tale bit tutte cifre uguali a 1
D. Complementando la sequenza bit a bit ed aggiungendo 1

798. Ponendo a sinistra di tale bit tutte cifre uguali a 0
A. Q869. L'approccio alla compilazione basato sul caricamento dinamico delle librerie effettua:
B. La chiamata di procedura nel programma principale
C. I collegamenti tra il codice oggetto del programma e il codice oggetto di una procedura solo quando la procedura è chiamata in fase di esecuzione
D. La traduzione in Linguaggio Macchina della procedura chiamata

799. La traduzione in Linguaggio Assembly della procedura chiamata
A. Q870. Il Bytecode Java è:
B. Eseguibile solo sull'Hardware della Java Virtual Machine
C. Eseguibile solo mediante un web browser
D. Eseguibile su qualunque computer che disponga di un Interprete Java

800. Direttamente eseguibile su qualunque computer
A. Q874. L'operando costante dell'istruzione ori $s0, $t2, 25 si ottiene:
B. Leggendo il valore contenuto nel registro $t1
C. Effettuando l'estensione del segno a 32 bit della sequenza di 16 bit nel campo immediato che rappresenta il valore costante
D. Completando a 32 bit la sequenza di 16 bit nel campo immediato, che rappresenta il valore costante, con bit tutti uguali a 0

801. Leggendo il valore contenuto nel registro $s0
A. Q878. Il calcolo dell'indirizzo dell'elemento A[k] di un Array di numeri INTERI si effettua:
B. Moltiplicando l'indice k per 4 e addizionando il valore ottenuto al contenuto del registro Base dell'Array
C. Addizionando il valore dell'indice k al contenuto del registro Base dell'Array
D. Moltiplicando l'indice k per 2 e addizionando il valore ottenuto al contenuto del registro Base dell'Array

802. Moltiplicando l'indice k per 4
A. Q878. L'indirizzo del registro Base nel Formato dell'istruzione in Linguaggio Macchina store word 101011, 01000, 01111, 0000000000000001 è dato da:
B. La sottosequenza 0000000000000001
C. La sottosequenza 01111
D. La sottosequenza 101011

803. La sottosequenza 01000
A. Q879. Nel Linguaggio Macchina MIPS l'Indirizzamento pseudodiretto calcola:
B. L'indirizzo di Memoria da cui leggere un operando
C. L'indirizzo dell'istruzione a cui saltare se i contenuti di due registri sono uguali
D. L'indirizzo di Memoria in cui scrivere il risultato di una operazione

804. L'indirizzo dell'istruzione a cui saltare
A. Q886. In Assembly MIPS, l'operazione di scrittura del contenuto del registro di indirizzo $s3 nella parola che inizia all'indirizzo di Memoria calcolato tramite il registro Base di indirizzo $t0 e l'Offset 8 è eseguita dalla:
B. Istruzione lw $s3, 8 ($t0)
C. Istruzione sw $t0, 8 ($s3)
D. Istruzione sw $s3, 8 ($t0)

805. Istruzione lw $t0, 8 ($s3)
A. Q886. La scelta dell'alfabeto binario consente di:
B. Minimizzare l'errore dovuto ad oscillazioni del valore dei segnali elettrici
C. Minimizzare le connessioni tra le componenti interne del computer
D. Effettuare calcoli più semplici

806. Aumentare il numero di valori che si possono memorizzare nei registri
A. Q887. Dal punto di vista implementativo l'Unità Centrale di Elaborazione (CPU) di un computer è:
B. Una Rete Sequenziale
C. Un circuito digitale che calcola la corrispondenza tra input e output descritta da una funzione binaria di variabili binarie
D. Una Rete Combinatoria

807. Un dispositivo di memorizzazione
A. Q888. Il sistema di codifica Unicode:
B. Include solo i codici ASCII dei caratteri stampabili
C. Non include la codifica ASCII
D. Include solo i codici ASCII dei caratteri non stampabili

808. Include la codifica ASCII come sottinsieme
A. Q892. Nel Flip-Flop SR l'input S=0 ed R=0 determina:
B. La transizione dei valori output nello stato SET
C. Il mantenimento invariato dello stato rappresentato dai valori output
D. La transizione dei valori output nello stato RESET

809. Nessuna transizione perché è una configurazione input esclusa
A. Q892. La regola che segnala l'Overflow per la somma di interi con segno nella Notazione in Complemento a 2 in base agli ultimi due riporti calcolati:
B. Si applica anche per gli interi unsigned
C. Si applica solo per gli interi positivi unsigned
D. Si applica solo per gli interi negativi unsigned

810. Non si applica per gli interi unsigned
A. Q892. Nel Linguaggio Macchina MIPS, il Formato e la Modalità di Indirizzamento dell'istruzione addi sono:
B. Formato di Tipo R con Indirizzamento immediato
C. Formato di Tipo I con Indirizzamento immediato
D. Formato di Tipo I con Indirizzamento tramite registro

811. Formato di Tipo I sia con Indirizzamento tramite registro sia con Indirizzamento immediato
A. Q893. Nella Notazione in complemento a 2, il segno del numero è determinato da:
B. Il bit più a destra con il relativo peso negativo
C. Il bit più a sinistra con il relativo peso negativo
D. Il bit della cifra meno significativa con il relativo peso negativo

812. Il bit più a sinistra non associato ad un peso
A. Q893. In Notazione posizionale pesata la cifra più significativa di una sequenza è:
B. La cifra più frequente all'interno della sequenza
C. La cifra che occupa la posizione più a sinistra
D. La cifra associata al peso di valore minore

813. La cifra che occupa la posizione più a destra
A. Q894. Per risolvere una criticità sul controlo:
B. Si utilizza una tecnica di predizione dell'esito del salto condizionato, che nel caso più semplice consiste nel continuare sempre l'esecuzione senza effettuare il salto
C. Si utilizza la tecnica detta di propagazione (bypassing) che consente all' istruzione successiva di leggere direttamente i risultati output calcolati dall' ALU senza dover attendere che siano memorizzati nel blocco dei Registri
D. Si aggiungono dei dispositivi di controllo per evitare i conflitti tra fasi di esecuzione di istruzioni diverse che richiedono lo stesso Hardware

814. Si duplicanno i dispositivi che determinano i conflitti tra fasi di esecuzione di istruzioni diverse che richiedono lo stesso Hardware
A. Q894. Per individuare la locazione da raggiungere in un blocco di registri si utilizza:
B. Un Multiplexer con un numero N di terminali input uguale alla lunghezza dell'indirizzo dei registri
C. Un Decodificatore con un numero N di terminali input uguale alla lunghezza dell'indirizzo dei registri
D. Un Multiplexer con un numero N di segnali di Controllo uguale alla lunghezza dell'indirizzo dei registri

815. Un Decodificatore con un numero N di terminali output uguale alla lunghezza dell'indirizzo dei registri
A. Q898. L'operazione effettuata dall'esecuzione dell'istruzione lb $t0, 30($s1) è:
B. Scrivere la sequenza di 8 bit in una locazione di Memoria dopo averla letta negli 8 bit meno significativi del registro
C. $t0
D. Leggere la sequenza di 8 bit contenuti in una locazione di Memoria e scriverla negli 8 bit meno significativi del registro $t0 di 32 bit, con estensione del segno a 32 bit

816. Leggere la sequenza di 16 bit contenuti in due locazioni successive di Memoria e scriverla nei 16 bit meno significativi del registro $t0 di 32 bit, ponendo a 0 il valore dei rimanenti bit
A. Scrivere 16 bit in due locazioni successive di Memoria dopo averli letti dai 16 bit meno significativi del registro $t0
B. Q898. L'istruzone Assembly MIPS lw $t5, 4($s0):
C. Legge la parola di Memoria che inizia dall'indirizzo dato dalla somma del contenuto del registro Base di indirizzo $t5 più l'Offset 4, e la scrive come contenuto del registro di indirizzo $s0
D. Legge la parola di Memoria che inizia dall'indirizzo dato dalla somma del contenuto del registro Base di indirizzo $s0 più l'Offset 4, e la scrive come contenuto del registro di indirizzo $t5

817. Scrive il contenuto del registro di indirizzo $t5 nella parola di Memoria che inizia dall'indirizzo dato dalla somma del contenuto del registro base di indirizzo $s0 più l'Offset 4
A. Scrive il contenuto del registro di indirizzo $s0 nella parola di Memoria che inizia dall'indirizzo dato dalla somma del contenuto del registro base di indirizzo $t5 più l'Offset 4
B. Q902. Per ottenere una Rete Combinatoria minimale occorre ridurre:
C. Il numero delle porte logiche e il massimo numero di livelli attraversato da un segnale nella Rete
D. Il costo della Rete Combinatoria

818. Il numero dei terminali input della Rete Combinatoria
A. Il numero dei terminali output della Rete Combinatoria
B. Q902. In Assembly MIPS, l'operazione di leggere la parola che inizia all'indirizzo di Memoria calcolato tramite il registro Base di indirizzo $t1 e l'Offset 9 e scriverla nel registro di indirizzo $s2 è eseguita dalla:
C. Istruzione sw $t1, 9 ($s2)
D. Istruzione lw $t1, 9 ($s2)

819. Istruzione sw $s2, 9 ($t1)
A. Istruzione lw $s2, 9 ($t1)
B. Q907. Per l'istruzione store word la modalità di indirizzamento tramite Base e Offset calcola:
C. A. L'indirizzo di un registro del processore in cui scrivere un dato
D. B. L'indirizzo di un registro del processore da cui leggere un dato

820. C. L'indirizzo di una locazione di Memoria da cui leggere un dato
A. D. L'indirizzo di una parola di Memoria in cui scrivere un dato
B. Q909. Nel Linguaggio Macchina MIPS l'istruzione beq ha:
C. Formato di Tipo J e Indirizzamento relativo al Program Counter
D. Formato di Tipo I e Indirizzamento immediato

821. Formato di Tipo I e Indirizzamento relativo al Program Counter
A. Formato di Tipo J e Indirizzamento immediato
B. Q912. La relazione che lega il tempo di CPU utente con la frequenza di clock e il periodo di clock è:
C. Inversa proporzionalità con il periodo e diretta proporzionalità con la frequenza
D. Inversa proporzionalità con la frequenza e diretta proporzionalità con il periodo

822. Diretta proporzionalità con entrambi
A. Inversa proporzionalità con entrambi
B. Q916. Nel Flip-Flop D l'input D=0 determina:
C. Il mantenimento invariato dello stato rappresentato dai valori output
D. La transizione dei valori output nello stato SET

823. La transizione dei valori output nello stato RESET
A. Nessuna transizione perché è una configurazione input esclusa
B. Q918. Il campo di validità di un elemento della Tabella associata alla cache fornisce:
C. I bit del contenuto della locazione nella Memoria principale associata alla locazione nella cache relativa alla riga della Tabella
D. Il valore di un bit uguale a 0 se la locazione nella cache relativa alla riga della Tabella è occupata da un dato copiato dalla Memoria principale, uguale a 1 se tale locazione nella cache è libera
